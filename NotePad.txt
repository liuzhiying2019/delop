—————————————————————————————————————————————
#帐号备忘录#
TTS公共帐号
nsd1807n_pm@tedu.cn
PM2017tarena
FTP笔记作业共享
ftp://176.121.0.120
静静老师e-mail:panglj@tedu.cn
—————————————————————————————————————————————
#Linux系统文档分类标识#
黑色：文本文件
蓝色：目录(文件夹)
绿色：可执行程序
青色：快捷方式
红色：压缩包
以.开头的文件：隐藏文件
—————————————————————————————————————————————
#Linux系统特殊名词解释#
文档：代表目录和文件
—————————————————————————————————————————————
—————————————————————————————————————————————
#其它#
截图工具命令:
gnome-screenshot -i
ssh选项:
-p 端口号 #指定端口号
tedu port :7920
—————————————————————————————————————————————

=================================================================================
			01.Admin-day01
=================================================================================

虚拟系统管理器（软件）：虚拟计算机的硬件

典型服务模式
C/S,Client/Server架构
由服务器提供资源或某种功能
客户机使用资源或功能

#####################################################
TCP/IP是  最广泛支持的通信协议

主机与主机之间通信的三个要素
IP地址(IP address)
子网掩码(subnet mask)
IP路由(IP router)
#####################################################

IP地址(IP address)：唯一标识 网络中一台主机   
地址组成(点分十进制):
一共32个二进制位
表示为4个十进制数,以.隔开

用于一般计算机网络
A类:1—127	网+主+主+主
B类:128—191	网+网+主+主
C类:192—223	网+网+网+主

组播及科研专用
D类:224—239  组播
E类:240—254  科研
  
IP地址由网络位与主机位

座机号：区号-号码
区号：标识区域
010-12345678
0316-7351111

192.168.1.1----->首先看第一个数字为192----->属于C类地址 网+网+网+主
192.168.1.2


192.168.1.1是192.168.1区域（网络）中，编号为1的主机
192.168.2.1是192.168.2区域（网络）中，编号为1的主机

########################################################
Internet协议版本4(TCP/IPv4)
代表一共32个二进制位---->4个十进制数以.隔开的点分十进制表示法
########################################################

配置IP地址：192.168.1.1   
子网掩码：255.255.255.0

子网掩码作用：区分以及标识IP地址的网络位与主机位
以数字1表示IP地址的网络位
以数字0表示IP地址的主机位    

11000000.10101000.00000001.00000001
11111111.11111111.11111111.00000000


子网掩码表示：192.168.1.1/24      # 24个网络位


IP地址的配置方式： 
1.手工配置
2.自动获取IP地址，网络中前提有一个DHCP服务器


网关地址：解决不同网络通信（路由器）

DNS服务器地址：将域名解析为IP地址

www.qq.com---->IP地址

=================================================================================
			01.Admin-day02
=================================================================================

pwd    查看当前目录
cat    打开文本文件
ls     可接路径目录参数而且可接多个参数

存放当前系统版本信息配置的文件是/etc/redhat-release 
所以查看当前系统版本cat /etc/redhat-release 

linux 严格区分大小写

*完整的命令一般格式

     命令字 选项... 参数1 参数2...
例如   cat -n /etc/redhat-release
其中：-n选项代表给文本加上行序号
       选项可以有多个


常用选项
-l 以长格式显示
（可以理解为windows下文件-->右击-->属性,即目录内容的详细属性如权限，大小，日期...）
例如   ls -l /root


查看内核版本
uname -r 
3.10.0-693.el7.x86_64   #主版本号.次版本号.修订号

查看cpu信息
lscpu
CPU(s):                1     #1个核心
型号名称：        Intel Core Processor (Skylake)


查看内存信息
cat /proc/meminfo
MemTotal:        1016260 kB    #总内存容量

#############################
第一步：查看系统版本cat /etc/redhat-release
第二步：查看系统的主机名hostname
第三步：查看系统的IP地址（远程管理）ifconfig
#############################

查看系统主机名
hostname
修改主机名为xxxx(修改后新打开一个终端即修改成功)
hostname xxxx

查看网卡连接信息（查看ip地址）
ifconfig  
127.0.0.1 永远代表本机
ping 127.0.0.1(ping本机)
ping -c 2 127.0.0.1   #ping通后发送两个包后结束
ping -W1 ip地址	      #ping不通时的超时时间1秒(默认为5秒)
ping -i0.1 ip地址     #ping通后延迟0.1秒结束(默认为1秒)
为网卡eth0 配置IP地址
ifconfig eth0 192.168.1.1


poweroff 关机
reboot   重启

创建目录（创建文件夹）
mkdir 路径
mkdir /student   #在根目录下创建student目录

mkdir /opt/student #在/opt目录创建student目录

如果不加路径，则为在当前目录创建
如mkdir haha     #在当前目录创建haha目录

创建文本文件（与创建目录类似）
touch 文件名

#########################################
绝对路径：以根（/）开始的路径
相对路径：不以根（/）开始的路径，以当前路径为参照
#########################################

cd ..表示返回上一层

.当前目录
..父目录（上一层目录）
#####################################################
  格式化：赋予空间文件系统的过程，赋予空间的规则

  文件系统：存储数据的规则

• 典型的文件系统类型
– EXT4,第四代扩展文件系统,RHEL6系列默认
– XFS,高级日志文件系统,RHEL7系列默认
– SWAP,交换空间(虚拟内存)：利用硬盘空间，缓解物理真实内存不足
####################################################

=================================================================================
			01.Admin-day03
=================================================================================

cat适合查看文本内容比较少的文件

less适合查看文本内容较多的文件 
按键盘上下键滚动；
/代表全文搜索，如/a是全文搜索a，按n,N切换跳转匹配
按q退出less模式

head -2 /路径    如head -2 /etc/passwd
查看路径下文本头2行

tail -2 /路径    如tali -2 /etc/passwd
查看路径下文本后2行

tailf /路径 实时动态看文件的最后十行

head /路径   tail /路径
不写数字默认显示10行

grep输出包含制定字符串的行
grep 选项 查找条件 /路径  如grep root /etc/passwd
选项
-v 取反   #反向关键词,即列出除查找条件关键词以外的所有行
-i 忽略大小写
-n 输出结果显示行号
-q quiet的意思,只做检索而并不输出
-c 统计匹配行数
查找条件
 word:包含字符串word
^word:以字符串word开头
word$:以字符串word结尾
    ^$:匹配空行(与-v连用代表排除空行)
*常考例题:
把#开头的注释和空行过滤掉(显示配置文件有效配置信息)
grep -v ^# /etc/login.defs | grep -v ^$
再写入文本/opt/1.txt中
grep -v ^# /etc/login.defs | grep -v ^$ > /opt/1.txt


命令的执行依赖于解释器[例如:/bin/bash(linux内核默认解释器)]
用户---->解释器---->内核（只认识0，1）---->硬件
解释器在/etc/shells下（命令cat /etc/shells可查看）

内部命令：属于解释器的一部分（如：poweroff）
外部命令：解释器之外的其他程序(如：firefox)

短选项：多个短选项可写在一起（如：-lh）

##############################################
快捷键
ctrl+c 废弃当前编辑的命令行(结束正在运行的命令）
Esc+.或Alt+. 粘贴上一个命令的参数
ctrl+l 清空整个屏幕

ctrl+u 清空至行首
ctrl+w 往回删除一部分（以空格界定）

ctrl+shift+t 新开一个终端
#############################################

mount挂载操作（作用：让一个目录成为访问点）
格式：mount 设备路径 挂载点目录
如mount /dev/cdrom /dvd

***********************************************
操作示例：
[root@localhost ~]# mkdir /dvd
[root@localhost ~]# ls /
[root@localhost ~]# ls /dvd
[root@localhost ~]# mount /dev/cdrom /dvd
mount: /dev/sr0 写保护，将以只读方式挂载
[root@localhost ~]# ls /dvd/
[root@localhost ~]# ls /dvd/Packages/
***********************************************

linux系统：
光盘--------------->光驱设备------------------>访问点（目录）
	/dev/hdc   IDE接口设备 
		   或  
	/dev/sr0   SCSI接口设备
		   =
	/dev/cdrom 
查看光驱设备
[root@localhost ~]# ls -l /dev/cdrom 
lrwxrwxrwx. 1 root root 3 8月   2 11:04 /dev/cdrom -> sr0

卸载umount 访问点
如umount /dvd

***********************************************
注意：
1.当前正在访问点路径下
[root@localhost dvd]# umount /dvd
umount: /dvd：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以
         找到有关使用该设备的进程的有用信息)

2.建议挂载点的选择，不要是根目录下已存在的目录，尽量自己创建目录
（否则会导致目录内容被隐藏且变为只读）
！特别是根目录，会导致由于正在访问根目录无法卸载！

~user：表示用户user的家目录
   ~  ：当前用户的家目录
/root 管理员的家目录
/home 存放所有普通用户的家目录的地方

查看命令的帮助信息
命令 --help

权威帮助手册
man 命令
*按q退出*
*搜索模式:/关键词,n下一个,N上一个*
*放大字体:Ctrl Shift +*
*缩小字体:Ctrl  -*


ls常用选项
-l以长格式显示，显示详细属性
-h（k,m等）————————与-l一起用
-d显示目录本身（而不是内容的）详细属性————与-l一起用
-A显示目录的所有的内容，包括以.开头的隐藏文件
-Z查看文档SELinux安全上下文值

通配符:针对不确定的文档名称，以特殊字符表示
*代表任意多个任意字符
如ls /boot/vm*(代表列出/boot目录下以vm开头的文件)
如ls /etc/*tab(代表列出/boot目录下以tab结尾的文件)
如ls /etc/re*.conf(代表列出/etc/下以re开头并且以.conf结尾的文件)
?单个字符
如ls /dev/tty? (代表列出tty后面只能有一个字符的文件)
如ls /dev/tty??(代表列出tty后面只能有两个字符的文件)

[a-z]多个字符或连续范围中的一个，若无则忽略(a,z只能识别到0-9，两位数及以上无法识别)
如ls /dev/tty[3-8]
/dev/tty3  /dev/tty4  /dev/tty5  /dev/tty6  /dev/tty7  /dev/tty8
{a,min,xy}多组不同的字符串，全匹配
如ls /dev/tty{1,3,7,9,38}
/dev/tty1  /dev/tty3  /dev/tty38  /dev/tty7  /dev/tty9

附加题：
列出/dev/tty20至/dev/tty30之间所有设备文件？
ls /dev/tty{2[0-9],30}

(命令)别名的定义：为了简化复杂的命令
注意：不要与系统原有命令重复

查看已设置的别名
alias 别名名称

定义新的别名
alias 别名名称='实际执行的命令行'

取消已设置的别名
unalias 别名名称

创建一个多级目录(直接mkdir /opt/aa/bb/cc不行)
mkdir -p /opt/aa/bb/cc


！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！
删除命令rm(实际上为系统默认别名，代表rm -i)
格式：rm 选项 文件或目录（出现提示y回车为是，n回车为否，直接回车默认否）
常用命令选项
-r递归删除(含目录)  递归：目录本身以及目录下所有
注意：删除多级目录时会出现多次提示，可用rm -rf强制删除
-f强制删除（不出现提示，直接删除）

通配符可用
如rm -rf /opt/*为删除/opt下所有目录和文件
！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！慎用！！

移动(windows-剪切)
mv
格式：mv 原文件路径 目标路径
如：mv /opt/1.txt /opt/nsd01

重命名：路径不变的移动
如：mv /opt/nsd01  /opt/student

cp复制
格式:cp 选项 原文件   目标路径
如：cp /etc/passwd   /opt/

常用命令选项
-r:递归,复制目录时必须要有这个选项
如：cp -r /boot/  /opt/
################################################################################
1.解决复制时出现重复
在本次操作，临时取消别名的定义（命令前加\）
\cp  -r  /boot/  /opt/
2.复制可以支持两个以上的参数
永远把最后一个参数作为目标，其他的所有参数都做为源文档
cp /etc/fstab /etc/shadow  /opt/(把/etc/fstab和/etc/shadow复制到/opt/)
3.复制与.连用
[root@localhost opt]# cp -r /root .    #将/root复制到当前路径下
4.复制时可以重新命名，目标路径文件名
cp /etc/redhat-release  /opt/abc     #将/etc/redhat-release复制到/opt并重命名为abc
招聘笔试常考题目
[root@localhost /]# rm -rf /opt/*           #清空/opt目录内容
[root@localhost /]# cp -r /mnt/  /opt/test  #将/mnt复制到/opt并重命名为test
[root@localhost /]# cp -r /mnt/  /opt/test  #将/mnt复制到/opt/test目录下
#################################################################################                                                                  

使用vim创建/修改文件
vim文本编辑器
格式:vim /目录/文件名

若目标文件不存在,则新建空文件并编辑
若目标文件已存在,则打开此文件并编辑

vim模式：命令模式,输入模式(插入模式或编辑模式),末行模式

[root@localhost /]# vim  /opt/haha.txt

      i键
命--------------------->输入模式(按Esc键回到命令模式)
令
模
式--------------------->末行模式(按Esc键回到命令模式)
        :键

末行模式  ：wq   保存并退出
末行模式  ：q!   强制不保存并退出
[root@localhost /]# cat  /opt/haha.txt

=================================================================================
			01.Admin-day04
=================================================================================

###########################################################
server     -练习用服务器
desktop    -练习用客户机
classroom  -提供网关/DNS/软件素材等资源

1.优先classroom开启系统
2.还原操作
rht-vmctl reset classroom
rht-vmctl reset server
rht-vmctl reset desktop
3.虚拟机server与虚拟机desktop用户密码
root
redhat
有一台新的服务器需要做什么：
第一步：查看操作系统版本cat /etc/redhat-release
第二步：查看系统的主机名hostname
第三步：查看系统的IP地址（远程管理）ifconfig

虚拟机server
操作系统版本RHEL7.0
系统的主机名server0.example.com
网卡eth0的IP地址172.25.0.11/24

虚拟机desktop
操作系统版本RHEL7.0
系统的主机名desktop0.example.com
网卡eth0的IP地址172.25.0.10/24

默认两台虚拟机可进行ping通信

4.利用真机进行远程管理
a)进行ping测试
真机终端ping172.25.0.11,ping172.25.0.10
b)在真机上可以利用ssh进行远程管理
ssh 用户名@对方的IP地址(ssh root@172.25.0.11)
exit #退出到真机

常用选项
-X：远程管理时，在本机运行对方的图形程序（建议都用）
ssh -X root@172.25.0.11

辅助操作：方便远程管理
真机：设置永久别名的配置文件
vim /root/.bashrc              #系统级的配置文件

# .bashrc
alias gos='ssh -X root@172.25.0.11'
alias god='ssh -X root@172.25.0.10'

:wq保存并退出，新开一个终端生效
###########################################################

软件包管理

1.具备软件包
mkdir /dvd
mount /dev/cdrom /dvd

2.零散软件安装
rpm -q 软件名                     #查询系统中是否存在该软件包
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 
[root@server0 ~]# rpm -q firefox
firefox-24.5.0-1.el7.x86_64

rpm -ql 软件名			#查询软件包的安装清单

rpm -i 软件名-版本信息.rpm	#安装软件包
[root@server0 ~]# rpm -i /dvd/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm 
警告：/dvd/Packages/vsftpd-3.0.2-22.el7.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID fd431d51: NOKEY

Linux安装软件包：默认情况下不允许选择安装位置，不允许选择安装功能
rpm -ivh 软件名-版本信息.rpm   #安装软件包时会有安装的进度条，比较专业好看

*补充
导入红帽签名信息
rpm -- import /dvd/RPM-GPG-KEY-redhat-release

rpm -e 软件名   		    #卸载软件包
[root@server0 ~]# rpm -e vsftpd
[root@server0 ~]# rpm -q vsftpd
未安装软件包 vsftpd 


常见报错：依赖关系
[root@server0 ~]# rpm -ivh /dvd/Packages/bind-chroot-9.9.4-50.el7.x86_64.rpm 
警告：/dvd/Packages/bind-chroot-9.9.4-50.el7.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID fd431d51: NOKEY
错误：依赖检测失败：
	bind = 32:9.9.4-50.el7 被 bind-chroot-32:9.9.4-50.el7.x86_64 需要

Yum软件包仓库:yum-config-manager --add-repo 软件仓库地址
服务：为客户端自动解决依赖关系安装软件

虚拟机classroom默认搭建Web服务，将光盘利用Web共享给所有客户端
http://classroom.example.com/content/rhel7.0/x86_64/dvd/
服务端: 虚拟机classroom
        1.具备众多rpm包    Packages
        2.具备仓库清单文件 repodata

客户端: 虚拟机server,制定服务端位置
Yum的搭建
书写Yum客户端配置文件:/etc/yum.repos.d/*.repo
(*代表可随意起名，但后缀必须为.repo,不过最好统一命名为rhel7.repo)
错误的配置文件与正确的配置文件会相互影响，导致正确的配置文件均不能用
所以rm -rf /etc/yum.repos.d/*先清空该目录下内容

vim /etc/yum.repos.d/rhel7.repo
vim命令模式下i(插入)
  [rhel7]                       #仓库标识(仓库的名字)必须放在所有字段第一行
  name=rhel7.0                  #仓库的描述信息
  baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/
                                #制定服务端位置，最好浏览器进行复制粘贴
  enabled=1                     #启用该文件
  gpgcheck=0                    #不检测红帽的签名信息
vim命令模式下：wq(保存并退出)
yum repolist                    #显示仓库信息

Yum的使用
安装
yum install httpd
yum -y install httpd(直接安装,不再询问是否安装)

卸载
yum remove httpd(默认保留政策-把依赖关系的安装包保留只卸载目标软件包)
yum -y remove httpd(建议不要用！容易误卸载有用的软件包)
[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/rhel7.repo
  [rhel7]
  name=rhel7.0
  basurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd
  enabled=1
  gpgcheck=0
[root@server0 ~]# yum repolist 
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# yum -y install vsftpd

清空Yum缓存
清空yum repolist的缓存文件，防止由于直接读取缓存导致不检测yum配置文件是否有错
yum clean all

搜寻关键字
yum search 关键字
如yum search ftp


升级内核(安装一个新的内核)
使用wget下载工具(相当于迅雷)，默认下载到当前目录下
wget 软件包的下载地址url


wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

rpm -ivh kernel-3.10.0-123.1.2.el7.x86_64.rpm 

装完reboot重启后uname -r查看内核版本

可用选项(不建议用)
wget 软件包的下载地址url -O /路径/文件名   另存为到/路径


网络配置
为了服务器稳定性，服务器一般采用静态ip，不用DHCP自动获取

1.永久的主机名配置
vim /etc/hostname
  server00

2.配置IP地址、子网掩码、网关地址
a)直接配置文件配置(不推荐)
网卡配置：vim /etc/sysconfig/network-scripts/ifcfg-eth0 
TYPE=Ethernet        #网络接口类型
BOOTPROTO=static     #动态为dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=yes          #是否支持IPV6       
IPV6_AUTOCONF=yes    
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
NAME=eno16777736    #网卡名称
UUID=72cf53fd-534c-4765-912b-3df575a10a7d
ONBOOT=yes          #开启自动启用网络连接
IPADDRO=192.168.1.20  #设置IP地址
GATEWAY0=192.168.1.1  #设置网关
PREFIX0=24           #设置子网掩码
DNS1=192.168.1.1     #设置DNS
HWADDR=00:0C:29:B8:2B:07
PEERDNS=yes 
PEERROUTES=yes
IPV6_PEERDNS=yes
IPV6_PEERROUTES=yes

b)命令配置
[root@server0 ~]# nmcli connection show 
   名称               UUID               类型        设备 
System eth0  5fb06bd0...edd65f3e03  802-3-ethernet  eth0 
#查看网卡的名称，System eth0为网卡名称

nmcli connection modify '网卡的名称'  #修改'网卡的名称'
ipv4.method manual         #方法手工配置,manual替换成auto则自动配置
ipv4.addresses '172.25.0.110/24 172.25.0.254' #只能用172.25.0网段(教学环境限制)
connection.autoconnect yes #每次开机自动启用配置
示例：
[root@server0 ~]# nmcli connection modify 'System eth0' 
ipv4.method manual 
ipv4.addresses '172.25.0.110/24 172.25.0.254' 
connection.autoconnect yes 

激活网卡配置
[root@server0 ~]# nmcli connection up 'System eth0' 
#激活后远程管理会崩溃(由于IP地址发生变化)
[root@room1pc43 ~]# ssh root@172.25.0.110
#再开一个新的终端，重新连接远程管理

ifconfig                        #查看IP地址
route(输出结果的Gateway下即为网关) #查看网关
###################################################
字符界面图形方式修改网络IP地址、子网掩码、网关地址
nmtui
进入特殊界面---->Edit a connection---->修改---->OK

激活网卡配置
[root@server0 ~]# nmcli connection up 'System eth0' 
#激活后远程管理会崩溃(由于IP地址发生变化)
[root@room1pc43 ~]# ssh root@172.25.0.110
#再开一个新的终端，重新连接远程管理
###################################################

=================================================================================
			01.Admin-day05
=================================================================================

设置永久的DNS服务器，域名解析：将域名解析为IP地址(*各大考试面试必考题)
[root@server0 ~]# vim /etc/resolv.conf 
  nameserver 172.25.254.254
验证是否成功
[root@server0 ~]# nslookup 域名  (host 域名)刘之盈加的

在教学环境下的三台虚拟机只能解析三个域名
classroom.example.com
server0.example.com
desktop0.example.com


重定向输出：将前面命令的输出结果写入到文本文件中

覆盖重定向：(文本文件若不存在会自动创建，若存在原文本内容会被覆盖)
命令 > /路径/文本文件 
ls --help > /opt/ls.txt

追加重定向：(不会覆盖原文本)
命令 >> /路径/文本文件
ls --help >> /opt/ls.txt

echo 写什么输出什么(与重定向连用，可以把想要写的内容写到文本里)
[root@server0 ~]# echo haha
haha

管道操作(将前面命令输出结果，交由后面命令再处理一次)
查看文本/etc/passwd头12行head -12 /etc/passwd
查看文本/etc.passwd后10行tali -10 /etc.passwd

查看文本/etc.passwd的8-12行
head -12 /etc/passwd | tail -5
(先取出/etc/passwd前12行取出，通过管道再取出后5行，即为/etc/passwd的8-12行)

cat -n /etc/passwd |head -12|tail -5
带行号的/etc.passwd的8-12行


管理用户和组

用户帐号:1.能够登陆操作系统
         2.不同的用户不同的身份，可以进行很好控制

组：方便管理用户，权限分配方面
    将想要具备相同权限的用户，加入一个组，再给组设置权限

组的分类：基本组 附加组(从属组)
Linux中一个用户必须至少属于一个组

基本组：创建新用户时由linux创建而成并加入，与用户名同名

添加用户
所有用户基本信息存放在/etc/passwd文件

useradd 选项 用户名

常用选项
-u自定义用户uid
useradd -u uid 用户名

管理员root的uid：永远为0
普通用户uid：默认从1000起始
系统程序用户UID范围：1-999

-d指定家目录路径(不指定则默认放到/home)
useradd -d 家目录 用户名
[root@server0 ~]# useradd -d /home/tom1 nsd03

-s登录Shell(登录解释器程序,不指定则默认/bin/bash)(解释器配置文件存放在/etc/shells)
*/sbin/nologin:禁止用户登录系统
useradd -s /解释器路径 用户名
useradd -s /sbin/nologin nsd02


-G指定附加组(新建用户默认是没有附加组的)
groupadd 附加组               #新建附加组
useradd -G 附加组 用户名     #新建用户并加入指定附加组
[root@server0 ~]# groupadd nsd
[root@server0 ~]# useradd -G nsd nsd02


查看用户信息
id 用户名

交互式密码设置

root设置密码
passwd 用户名

普通用户设置密码
passwd

临时切换用户
su - 用户名

非交互式密码设置
echo 密码 | passwd --stdin 用户名
[root@server0 ~]# echo 123456 | passwd --stdin nsd01
更改用户 nsd01 的密码 。
passwd：所有的身份验证令牌已经成功更新。


所有用户基本信息存放在/etc/passwd文件
每一个用户占用，一行信息
[root@server0 ~]# head -1 /etc/passwd
root:x:0:0:root:/root:/bin/bash
用户名：密码占位符：UID：基本组的GID：用户的描述信息(可以为空)：用户的家目录：解释器

所有用户密码存放在/etc/shadow
[root@server0 ~]# head -1 /etc/shadow
root:$6$UiGI4Tc2$htsXYn5cJnOqv3P1VLcUSgfjDu2pL5yiJBuua6foZAHdwqeuLHfYUfS/vBn27Wjvoel8EJgtdsMjyquqvKAmf1:16261:0:99999:7:::
用户名：密码加密字符串：上一次修改密码的时间(自1970-1-1到上一次修改密码的时间经过的天数)

修改用户属性
usermod 选项 用户名

常用选项
-u用户uid
-d用户家目录(只会修改/etc/passwd文件中的家目录对应字段，不会创建相应文件夹作为家目录)
-G附加组
-s登录Shell 

[root@server0 ~]# usermod -u 10086 -d /home/tom1 -G nsd -s /sbin/nologin nsd02
[root@server0 ~]# grep nsd02 /etc/passwd
nsd02:x:10086:4446::/home/tom1:/sbin/nologin
[root@server0 ~]# id nsd02
uid=10086(nsd02) gid=4446(nsd02) 组=4446(nsd02),4445(nsd)

还可以通过vim修改用户属性
vim /etc/passwd
利用vim工具直接修改配置文件内容

删除用户
userdel
userdel 用户名

选项
-r连同家目录一并删除(一般不要用，普通用户权限低，家目录数据比较宝贵)

*红帽考试及招聘笔试常见创建用户
useradd harry
useradd natasha
useradd kenji
useradd jack
useradd chihiro

组帐号管理
/etc/group文件存放组信息
[root@server0 ~]# grep stugrp /etc/group
stugrp:x:4448:
组名：组的密码占位符：组的gid标识：组的成员列表(可以为空)

新建组帐号
groupadd 选项 组名
groupadd stugrp

选项
-g组id

组管理
gpasswd -a 用户名 组名  #添加用户到组
gpasswd -d 用户名 组名  #从组删除用户
*组管理操作不是立即生效，须重新登录才生效

删除组
groupdel 组名
[root@server0 ~]# groupdel stugrp


tar备份与恢复(归档及压缩)

常见的压缩格式及命令工具
.gz-->gzip，gunzip(速度最快，压缩比例最小)
.bz2-->bzip2,bunzip2
.xz-->xz,unxz(速度最慢，压缩比例最大)

tar集成备份工具(归档并压缩)
1.制作tar包(源文档路径为绝对路径时会把路径也压缩到tar包中)
tar 选项 /路径/归档及压缩包的名字(若无路径则包放在当前路径) /路径/源文档
tar -zcf /opt/test01.tar.gz /home/ /etc/passwd

2.释放tar包
tar 选项 /路径/归档及压缩包的名字 -C /路径(若无-C /路径则释放到当前路径)
tar -xf /root/backup.tar.gz -C /mnt

选项
(1)释放
-C：指定释放的位置
-x释放归档--------------------------------------------------释放tar包必须要有的选项
-f(必须放到所有选项的最后)指定归档文件名称-----释放tar包必须要有的选项

(2)制作
-c创建归档--------------------------------------------------制作tar包必须要有的选项
-f(必须放到所有选项的最后)指定归档文件名称-----制作tar包必须要有的选项

-z调用.gz格式的工具进行处理--------选择压缩格式
-j调用.bz2格式的工具进行处理--------选择压缩格式
-J调用.xz格式的工具进行处理--------选择压缩格式

(3)查看tar包内容
-t显示归档中的文件清单(！也要与f连用！)
tar -tf /opt/test01.tar.gz



NTP时间同步：搭建集群需要时间同步
Network Time Protocol(网络时间协议)
NTP服务器为客户机提供标准时间
NTP客户机需要与NTP服务器保持沟通

NTP服务器：虚拟机classroom.example.com
NTP客户机：虚拟机Server0.example.com
1.安装一个和NTP服务器沟通的软件
rpm -q chrony(查询是否安装好chrony)
2.指定NTP服务器,修改配置文件/etc/chrony.conf
*在Linux系统中大多数配置文件中。以#开头的为注释内容
[root@server0 ~]# vim /etc/chrony.conf 
  server classroom.example.com iburst
3.重启刷新
[root@server0 ~]# systemctl restart chronyd
[root@server0 ~]# systemctl enable chronyd      #设置开机自启动

    daemon:超级守护程序；守护神(希腊神话中)半人半神的精灵
4.验证
利用date修改成错误时间，然后用systemctl restart chronyd重启刷新，再date查看时间
*补充命令：
查看时间date     
查看日期date +%F
修改时间date -s '年-月-日 时：分：秒'(秒如果不写则默认从0秒开始)

=================================================================================
			01.Admin-day06
=================================================================================

权限和归属

基本权限的类别
访问方式(权限)
读取r------read：允许查看内容
写入w------write：允许修改内容
可执行x----execute：允许运行和切换

对于文本文件：
r：cat less head tail
w：vim > >>
x：Shell脚本 可以运行

权限使用对象(归属)
所有者u-----user：拥有此文件/目录的用户
所属组g-----group：拥有此文件/目录的组(一般为所有者的基本组)
其他用户o----other：除所有者，所有组以外的用户

查看权限
ls -l
ls -ld 文件或目录


[root@room1pc43 ~]# ls -ld /etc/
drwxr-xr-x. 138 root root 12288 8月   7 08:48 /etc/
                138代表子目录的个数
[root@room1pc43 ~]# ls -l /etc/passwd
-rw-r--r-- 1 root root 2180 8月   6 10:45 /etc/passwd
               1代表硬连接的个数
开头d为目录
开头-为文本文件
开头l为快捷方式

设置基本权限
使用chmod 命令
chmod 归属关系 +或-或= 权限类别 路径/文档
chmod o+w /nsd01     #为其他用户o添加写入权限w
chmod u-w /nsd01     #为所有者u删除写入权限w
chmod g=--- /nsd01   #把所属组g权限设置为无---
chmod u=r /nsd01     #把所有者u权限设置为只读r
chmod ugo=rws /nsd01 #把所有者u所属组g其他用户o权限都设置为可读可写可执行rws
chmod u-x,g-x,o-x /nsd01 或 chmod ugo-x /nsd01
#为所有者u所属组g其他用户o删除可执行权限
chmod u=wrx,g=rx,o=--- /nsd01 #设置文档权限为wrxr-x---

选项
-R：递归设置(包含目录本身及目录下所有文档一起设置权限)
如chmod -R u=wrx,g=rx,o=--- /nsd01 
#为目录/nsd01及其下所有文档设置权限wrxr-x---

Linux中如何判断用户权限：
1.判断用户的角色
判断优先级：所有者>所属组>其他用户
遵循'匹配及停止'原则(一旦匹配到了即停止,不会再判断低优先级的角色关系)
[root@server0 ~]# ls -ld /nsddir/
d---r--rwx. 2 student root 23 8月   7 11:11 /nsddir/
#student为所有者，权限为---，反而其他用户权限更高为rwx

2.查看相应权限位置的权限设置

*所有普通用户无法运行chmod命令，只有管理员root才能运行

对于目录：
r：ls浏览目录内容
w：rm,mv,cp,mkdir,touch 等更改目录内容(不包括更改目录本身属性)
x：cd切换到此目录

*若对父目录无权限，对子目录及子文件有权限也无意义

设置文档归属
chown 所有者 /路径/文档          #更改文档所有者
chown :所属组 /路径/文档        #更改文档所属组
chown 所有者:所属组 /路径/文档  #同时更改文档所有者及所属组

选项
-R：递归设置(包含目录本身及目录下所有文档一起设置文档归属)

*管理员root的拷贝cp会把拷贝的复制品文件所有者及所属组变为root

附加权限(特殊权限)
1.Set GID
chmod g+s或g-s /路径/目录
附加在所属组的执行权限x位上，所属组的权限标识会变成s或S
                      (s代表所属组的执行权限为x,S代表所属组的执行权限为-)
适用范围：适用于目录
功能：Set GID可以使目录下新增的文档新建时自动设置与父目录相同的所属组
#让新增的子文档，自动继承父目录的所属组
*默认情况下，子文档不会继承父目录的从属关系

2.Set UID
chmod u+s或u-s /路径/可执行文件
附加在所有者的执行权限位x上,所有者的权限标识会变成s或S
                      (s代表所有者的执行权限为x,S代表所有者的执行权限为-)
适用范围:适用于可执行文件
功能:可以让使用者具有文件所有者的身份及部分权限
#传递所有者身份,用户可以拥有所有者的权限,新建的文档所有者是可执行文件所有者

3.Sticky Bit
chmod o+t或o-t /路径/文档
附加在其他用户的执行权限x位上,其他人的权限标识会变成t或T
                    (t代表其他用户的执行权限为x,T代表其他用户的执行权限为-)
适用范围:适用于开放w权限的目录
功能:可以防止用户滥用w权限(禁止用户操作别人的文档)
#文档所有者才能操作自己的文档,其他人无法操作


acl策略：访问控制列表
修改访问权限
setfacl -m u:用户名:权限类别 /路径/文档       #修改或添加指定用户acl
setfacl [-R] -m g:组名:权限类别 /路径/文档  #修改或添加指定组acl
setfacl [-R] -x:用户名 /路径/文档    #删除指定用户acl
setfacl [-R] -b /路径/文档           #删除所有acl
存在意义：文档基本权限及归属的局限性，无法实现更精细的控制
功能：能够针对个别用户，个别组设置独立的权限
*适用范围：EXT3/4，XFS文件系统默认支持(即支持Linux平台)

查看文档权限
getfacl /路径/文档


使用LDAP(Lightweight Directoty Access Protocol轻量级目录访问协议)认证
实现网络用户集中管理，用户由LDAP服务器创建

网络用户:用户名,密码信息存储再LDAP服务端
LDAO服务器：虚拟机Classroom.example.com

客户端：虚拟机server0.example.com
1.安装软件包sssd,专用于与LDAP服务端沟通的软件
[root@server0 ~]# yum -y install sssd 
[root@server0 ~]# rpm -q sssd
sssd-1.11.2-65.el7.x86_64

2.利用图形工具authconfig-gtk设置sssd配置文件,指定LDAP服务端位置
(a)安装工具
[root@server0 ~]# yum -y install authconfig-gtk
[root@server0 ~]# rpm -q authconfig-gtk
authconfig-gtk-6.2.8-8.el7.x86_64
(b)运行工具
[root@server0 ~]# authconfig-gtk 
进入图形界面
操作步骤：
身份&验证-->用户帐号数据库：LDAP-->LDAP 搜索基础DN：dc=example,dc=com
-->LDAP服务器：classroom.example.com-->认证方法：LDAP密码-->
用TLS加密连接选项：选上打勾-->下载CA证书-->
证书URL：http://classroom.example.com/pub/example-ca.crt-->
确定-->应用-->卡死后等待图形界面框消失或出现‘杀死程序’提示即为成功

3.重启sssd程序并设置开机自启动
[root@server0 ~]# systemctl restart  sssd
[root@server0 ~]# systemctl enable sssd

4.验证：教学环境下LDAP服务器事先创建好21个用户ldapuser0-ldapuser20用于验证
[root@server0 ~]# grep ldapuser0 /etc/passwd  #无输出即说明非本地用户
[root@server0 ~]# 
[root@server0 ~]# id ldapuser0                #检测ldap服务器用户
uid=1700(ldapuser0) gid=1700(ldapuser0) 组=1700(ldapuser0)

*了解知识点
网址：www.qq.com=主机名www+域名qq.com


家目录漫游

为了解决：无法更改到dapuser0家目录
[root@server0 ~]# su - ldapuser0
su: 警告：无法更改到 /home/guests/ldapuser0 目录: 没有那个文件或目录
mkdir: cannot create directory '/home/guests': Permission denied
-bash-4.2$ 

构建NFS(Network File System网络文件系统)共享
NFS共享服务器：虚拟机classroom.example.com
客户端：虚拟机server0.example.com访问共享
1.查看服务端有哪些共享
showmount -e classroom.example.com
[root@server0 ~]# showmount -e classroom.example.com 
Export list for classroom.example.com:
/home/guests 172.25.0.0/255.255.0.0

2.访问共享
#####################################################################
[root@server0 ~]# mkdir /share
[root@server0 ~]# mount classroom.example.com:/home/guests /share
#将classroom上的共享目录挂载到本地的/share目录
[root@server0 ~]# ls /share/
ldapuser0   ldapuser12  ldapuser16  ldapuser2   ldapuser5  ldapuser9
ldapuser1   ldapuser13  ldapuser17  ldapuser20  ldapuser6
ldapuser10  ldapuser14  ldapuser18  ldapuser3   ldapuser7
ldapuser11  ldapuser15  ldapuser19  ldapuser4   ldapuser8
#挂载成功，可以浏览到服务器共享的文档
[root@server0 ~]# su - ldapuser0
上一次登录：二 8月  7 17:39:15 CST 2018pts/1 上
su: 警告：无法更改到 /home/guests/ldapuser0 目录: 没有那个文件或目录
mkdir: cannot create directory '/home/guests': Permission denied
-bash-4.2$ 
#还是登录失败，需要创建/home/guests，再挂载到/home/guests
####################################################################
-bash-4.2$ exit
logout
[root@server0 ~]# umount /share/
[root@server0 ~]# mkdir /home/guests
[root@server0 ~]# mount classroom.example.com:/home/guests/ /home/guests/
[root@server0 ~]# su - ldapuser0
上一次登录：二 8月  7 17:40:49 CST 2018pts/1 上
[ldapuser0@server0 ~]$ 
#挂载成功后，可成功登录


修改用户家目录
[root@server0 /]# useradd harry

[root@server0 /]# usermod -d /abc  harry
[root@server0 /]# grep harry /etc/passwd
[root@server0 /]# su - harry

[root@server0 /]# cp -r /home/harry/  /abc
[root@server0 /]# ls -ld /abc/
[root@server0 /]# ls -lA /abc/

[root@server0 /]# chown -R harry:harry /abc
[root@server0 /]# ls -ld /abc
[root@server0 /]# ls -lA /abc
[root@server0 /]# su - harry

=================================================================================
			01.Admin-day07
=================================================================================

cron计划任务(周期性计划任务)
用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务
软件包:cronie,crontabs
系统服务:crond
日志文件:var/log/crond
任务文件存放位置: /var/spool/cron/

时间+任务(命令,脚本)
crontab 选项 用户名(用户名若省略不写则默认是root)

选项
-e 编辑计划任务
-u 定义用户
-l 查看计划任务
crontab -e -u 用户名             #编辑计划任务
crontab -l                   #查看计划任务

时间规则
分 时 日 月 周 任务命令行(绝对路径)
*  *  *  *  *  执行命令
有*则代表每分/时/日/月/周都执行一次
30 23 * * * poweroff   #每周每月每日的23:30执行关机命令

30 23 3 * 5 poweroff   #每月3日或每周五23:30执行关机命令

*匹配范围内任意时间
,分割多个不连续的时间点
-指定连续时间范围
/n 代表频率


例题:每2分钟记录当前的系统时间,写入到/opt/time.txt
[root@server0 ~]# crontab -e -u root          #书写计划任务
no crontab for root - using an empty one
crontab: installing new crontab
[root@server0 ~]# crontab -l                  #查看计划任务
*/2 * * * * date >> /opt/time.txt
[root@server0 ~]# cat /var/spool/cron/root    #查看任务文件
*/2 * * * * date >> /opt/time.txt
[root@server0 ~]# cat /opt/time.txt           #由计划任务记录下来的时间
Wed Aug  8 10:21:01 CST 2018



查找文件
根据预设的条件递归查找对应的文件
find /路径/目录 条件1 选项 条件2

选项
-a:查找条件为条件1和条件2(多个条件情况下省略默认为-a)
-o:查找条件为条件1或条件2(多个条件情况下省略默认为-a)

-type 按类型查找(f文本文件,d目录,l快捷方式)
格式:find /路径/目录 -type f或d或l

-name或-iname(-iname忽略大小写) 按名字查找:支持通配符
格式:find /路径/目录 -name或-iname "文档名"

-size 按大小查找(+大于,-小于 单位 k M G)
格式:find /路径/目录 -szie +或-Nk或M或G   #N代表数量

-user 按文档的所有者查找
格式:find /路径/目录 -user 用户名

-group 按文档的所属组查找
格式:find /路径/目录 -group 所属组

-maxdepth 限制find的查找深度(最大层数)
格式:find ...... -maxdepth 层数

-exec 对查找结果进行处理
格式:find ...... -exec 处理命令 {} \   #{}代表find的每一个查询结果,遇到\;结束
如:[root@server0 ~]#  find / -user student -type f -exec cp {} /mnt \;

-mtime 按文件修改时间查找
-mtime +N  #查找N天之前
-mtime -N  #查找最近N天之内
格式:find /路径/目录 -mtime +或-或无N 
                 4
              |<---->|          -4
      +4  	     |--------------------------->          
<-------------|                               
<------|------|------|------|------|------|------|
       6      5      4      3      2      1    现在
  PICTURL1.1.7-1find -mtimeTIMEROLL

=================================================================================
			02.Engineer-day01
=================================================================================

——————————————————————————————————————————————
#常识必记知识点#
扇区大小512字节
——————————————————————————————————————————————
硬盘的分区
识别硬盘---->分区规划---->格式化---->挂载使用
1.识别硬盘
(a)由系统自动完成
(b)查看识别的硬盘
[root@server0 ~]# lsblk 
NAME     SIZE TYPE MOUNTPOINT
vda      10G  disk
└─vda1   10G  part  /
vdb      10G  disk
[root@server0 ~]# ls /dev/vdb
/dev/vdb

2.分区规划
MBR(msdos)分区模式
1-4个主分区或0-3个主分区+1个扩展分区(n个逻辑分区)

[vdb1]|[vdb2]|[vdb3]|[vdb4]=vdb5,vdb6,vdb7...

最大支持容量2.2TB硬盘
扩展分区不能格式化不能存储数据(会显示容量大小为1k),只是用来基于它创建逻辑分区
(a)查看分区表
fdisk -l /dev/硬盘设备
(b)修改硬盘分区表
fdisk /dev/硬盘设备
如:fdisk /dev/vdb
常用交互指令:
 m列出指令帮助
 p查看现有分区表
 n新建分区
 d删除分区
 q放弃更改并退出
 w保存更改并退出

3.格式化,赋予空间文件系统(存放数据的规则)
mkfs.文件系统 /dev/硬盘设备分区
[root@server0 ~]# mkfs.ext4 /dev/vdb1
[root@server0 ~]# mkfs.xfs /dev/vdb2

查看文件系统
blkid /dev/硬盘设备分区
[root@server0 ~]# blkid /dev/vdb1
/dev/vdb1: UUID="5e18a26b-d474-4c75-becb-f23f76ec271b" TYPE="ext4" 
#UUID为内核识别设备的唯一标识
[root@server0 ~]# blkid /dev/vdb2
/dev/vdb2: UUID="218ee1b7-80a1-4524-9cc4-df039b54d68e" TYPE="xfs" 

4.挂载使用
(a)创建挂载点
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mkdir /mypart2
(b)挂载访问
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# mount /dev/vdb2 /mypart2
(c)查看正在挂载的设备使用情况
[root@server0 ~]# df -h  #常用选项-h:提供易读的容量单位

5.设置开机自动挂载(修改配置文件/etc/fstab)
配置文件/etc/fstab的记录格式
 设备路径      挂载点    文件系统类型     参数      备份标记   检测顺序
/dev/vdb1    /mypart1     ext4       defaults      0         0
/dev/vdb2    /mypart2     xfs        defaults      0         0

先卸载挂载
[root@server0 ~]# umount /mypart1
[root@server0 ~]# umount /mypart2
[root@server0 ~]# df -h        #查看是否卸载成功
再检测设置是否成功
[root@server0 ~]# mount -a   #没有报错,则格式正确
#mount -a工作原理:先检测配置文件/etc/fstab格式,把当前没有挂载的设备进行挂载
[root@server0 ~]# df -h    #查看是否挂载成功,挂载成功即设置完成
 
*vim补充
vim命令模式下可以按o另起一行并进入插入模式

6.综合分区
fdisk /dev/硬盘设备
前三个分区创建"主分区",第四个分区创建"扩展分区",再基于"扩展分区'创建"逻辑分区"

保存后如果警告
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 16: 设备或资源忙.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
正在同步磁盘。
[root@server0 ~]# lsblk
[root@server0 ~]# partprobe 
[root@server0 ~]# lsblk



/dev/sda5 该设备的含义:SCSI设备第1块硬盘的第五个分区
                        或SCSI设备第1块硬盘的第1个逻辑分区

7.总结
a.查看硬盘:lsblk
b.划分分区:fdisk
c.刷新分区表:partprobe
d.格式化:mkfs.ext4或mkfs.xfs
e.查看文件系统:blkid /dev/硬盘设备分区
f.修改配置文件设置开机自动挂载:/etc/fstab
g.检测配置文件格式并挂载当前没有挂载的设备:mount -a
h.查看正在挂载设备使用情况,查看分区的使用情况:df -h

8.图形添加一块新的60G的硬盘并综合分区
a.关机虚拟机server0
  poweroff

b.为虚拟机server0添加一块60G的硬盘
  [root@room1pc43 ~]# gos
  [root@server0 ~]# lsblk
  vdc    253:32   0  60G  0 disk 

c.综合分区:划分5个10G的可用分区
  3主分区,1个扩展分区和2个逻辑分区




逻辑卷的管理LVM
作用:a.空间可以变大 b.整合分散的空间
 零散空间存储--------------整合的虚拟磁盘-------虚拟的分区
  物理卷PV                    卷组VG         逻辑卷LV
/dev/vdb1      10G     整合          划分
/dev/vdc1      10G    -----   40G   -----    15G
/dev/vdc2      10G    -----         -----
/dev/vdd1      10G     
将众多的物理卷PV组成卷组VG,再从卷组中划分逻辑卷LV

LVM管理工具集
功能
scan
create
display
remove
extend
change

1.创建卷组
命令格式:vgcreate 卷组名称 闲置分区路径

*查看物理卷信息
[root@server0 ~]# pvs
*查看卷组信息
[root@server0 ~]# vgs

2.划分逻辑卷
命令格式:lvcreate -L 逻辑卷容量大小 -n 逻辑卷名称 卷组名称
*查看逻辑卷信息
[root@server0 ~]# lvs
*逻辑卷的快捷方式路径
/dev/卷组名称/逻辑卷名称

3.格式化
mkfs.文件系统 /dev/卷组名称/逻辑卷名称

4.创建挂载点文件夹
mkdir /lv

5.修改配置文件
vim /etc/fstab

6.逻辑卷空间的扩大
第一种情况:卷组有足够的剩余空间
lvextend -L +nG或mG /dev/systemvg/mylv  #扩大nG或者扩大到mG
    刷新文件系统的命令:
   ext4文件系统:resize2fs /dev/systemvg/mylv
   xfs文件系统:xfs_growfs /dev/systemvg/mylv
第二种情况:卷组没足够的剩余空间
a.扩大卷组空间
vgextend systemvg /dev/vdc3 /dev/vdc5
b.按照第一种情况操作

7.卷组划分空间的最小单位PE:默认大小4M
vgcreate -s PE大小 卷组名称  空闲分区     #创建卷组的时候设置PE大小
vgchange -s PE大小 卷组名称              #卷组已存在修改PE大小
vgdisplay 卷组名称          #查看卷组详细信息

lvcreate -l PE大小 -n 逻辑卷名称 卷组名称

8.删除逻辑卷(首先删除逻辑卷,再删除卷组,最后删除物理卷)
注意:删除卷组时,确认没有任何一个逻辑卷基于其创建
a.umount /lv #卸载挂载点
b.lvremove /dev/systemvg/mylv #删除逻辑卷
c.vgremove systemvg           #删除卷组
d.pvremove /dev/vdc[1-3] /dev/vdc5

*了解内容:逻辑卷可以变小,但是由于要同时缩小文件系统造成数据出错,无意义
        ext4文件系统支持缩小
        xfs文件系统不支持缩小
###########################################################################
[vim编辑技巧]

<命令模式>
1.移动光标：键盘上下左右键、Home键、End键
2.行间跳转：到全文的第一行(1G或gg)、到全文的最后一行(G)、到全文的第10行(10G)
3.复制、粘贴：
复制1行（yy）、复制3行（3yy）
粘贴到光标之后（小写p）
粘贴到光标之后 (大写P)
4.删除(实际为剪切)：
删除单个字符(x)
删除到行首(d^)、删除到行尾(d$)
删除1行（dd）、删除3行（3dd）
5.查找关键词： 
搜索（/word）切换结果（n、N）
6.大写的C可以删除光标之后，并且进入插入模式
7.撤销操作:
撤销最近的一次操作(u)
取消前一次撤销操作Ctrl+r
8.保存并退出:ZZ(大写)

<末行模式>
1.保存/退出文件操作:
保存当前文件(:w),放弃编辑并退出(:q!),保存并退出(:wq或:x)
读入其他文件的内容(:r /文件路径)
2.字符串替换:
替换当前行第一个'old'(:s/old/new)
替换当前行所有的'old'(:s/old/new/g)
替换第n-m行所有的'old'(:n,m s/old/new/g)
替换全文所有的'old'(:% s/old/new/g)
3.开关参数的控制:
显示/不显示行号(:set nu/nonu)
启用/关闭自动缩进(:set ai/noai)
###########################################################################

=================================================================================
			02.Engineer-day02
=================================================================================
Shell脚本基础(.sh)

脚本:一个可执行的可以实现某种功能的文本文件

规范Shell脚本的一般组成
#!环境声明 如:Shell脚本:#!/bin/bash  (以下程序是什么语言)
# 注释文本
可执行代码

Shell脚本编码常用工具
1.管道传递 |
2.重定向输出(>覆盖重定向,>>追加重定向)
 >:只收集正确输出
2>:只收集错误输出
&>:正确输出与错误输出都收集
3.运算:$[+ - * / %]       #/默认向下取整;%取余,余数一定小于除数
4.取消所有字符特殊意义:' '
5.将命令的输出作为参数参与其它命令执行:$()

黑洞设备:/dev/null  #输出粉碎垃圾场
一般用法:Shell脚本中将不想要的输出结果通过 >& /dev/null 导向黑洞设备

变量:以不变的名称存放可以变化的值
Shell脚本中
定义并赋值:变量名=变量值
引用变量值:$变量名
查看变量值:
echo  $变量名
echo ${变量名} 

*变量名只能由字母,数字,下划线组成,区分大小写,不能以数字开头

四大类变量
1.环境变量:由系统定义并赋值完成,用户直接使用即可
  常见环境变量:
  USER=永远储存当前登录的用户名
2.位置变量:由系统定义并赋值完成,用户直接使用即可
  作用:执行脚本可执行程序时,用来当作参数
  表示为$n(n为序号)
  $1,$2,...${10},${11}...  #$1代表命令行的第一个参数
3.预定义变量:由系统定义并赋值完成,用户直接使用即可
  $# 已加载的位置变量的个数,求和
  $* 所有位置变量的值
  $? 程序退出后的状态值,0表示正常,其它值表示异常
4.自定义变量:用户自主设置,修改及使用

########################################################################
增加用户对脚本的体验程度,降低用户的使用难度:
read:产生交互,捕捉用户在键盘上的输入,并且赋值给一个变量
用法:read -p '屏幕提示信息' a     #-p是屏幕提示选项,a是储存来自键盘输入的变量
########################################################################

条件测试及选择判断
1.[条件测试表达式]:每一部分都要有空格

检查文件状态
  -e:文档存在为真
  -d:存在且为目录为真
  -f:存在且为文件为真
  -r:存在且对其有读取权限为真
  -w:存在且对其有写入权限为真
  -x:存在且对其有执行权限为真

比较整数大小,不可比较小数否则报错
  -gt:大于
  -ge:大于或等于
  -eq:等于
  -ne:不等于
  -lt:小于
  -le:小于或等于

字符串比对
  ==:字符串相等为真
  !=:字符串不相等为真

2.if选择结构

if双分支处理

if [条件测试表达式];then
     命令序列xx
else
     命令序列yy
fi


系统环境变量:RANDOM=储存随机数字的变量
随机产生一个0-9的数:$[$RANDOM%10]

3.if多分枝处理
if   [条件测试表达式1];then
    命令序列xx
elif [条件测试表达式2];then
    命令序列yy
......

else
     命令zz
fi

=================================================================================
			02.Engineer-day03
=================================================================================

for 循环体系:反复执行类似的操作

格式:for 变量名 in 值列表
    do
     命令序列
    done

循环的列表值可以不参与循环体
造数工具:{起始值..结束值}

>&2                                  #将输出变成错误输出 
exit 返回值N(非0)              #改变错误输出返回值,退出并返回状态值N


系统安全保护
SELinux安全机制:一套增强Linux系统安全的强制访问控制体系

SELinux的运行模式
enforcing       强制
permissive      宽松
disabled        禁用

切换运行模式
临时切换模式:setenforce 1|0  #本次开机临时切换状态,1:enforcing,0:permissive
查看当前模式getenforce 
查看selinux状态：sestatus

固定配置/etc/selinux/config     #设置开机默认模式


配置用户环境

永久别名:
1.影响指定用户的bash解释环境
~/.bashrc
#指定用户家目录下的.bashrc

2.影响所有用户的bash解释环境
/etc/bashrc


防火墙策略管理
(严格过滤入站,允许出站)

搭建基本Web服务
服务端:虚拟机Server0
1.安装软件包(其它常用Web服务器软件:Nginx,Tomcat)
安装httpd(Apache的软件)
[root@server0 ~]# yum -y install httpd

2.重启httpd服务,并设置开机自启
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd

3.本机访问测试
[root@server0 ~]# firefox 127.0.0.1   #本机访问本机

4.书写一个自己的页面文件
 httpd默认网页文件存放路径:/var/www/html
        默认主页文件名称要求:index.html
[root@server0 ~]# vim /var/www/html/index.html
<marquee><font color=red><h1>NSD1807
   滚动           红色        字体变大
[root@server0 ~]# firefox 172.25.0.11


搭建基本FTP服务
1.安装软件包vsftpd
[root@server0 ~]# yum -y install vsftpd

2.重启vsftpd服务,并设置开机自启
[root@server0 ~]# systemctl restart vsftpd
[root@server0 ~]# systemctl enable vsftpd

3.本机测试验证
[root@server0 ~]# firefox ftp://172.25.0.11

4.默认vsftpd共享路径:/var/ftp

*客户端也可以访问
[root@desktop0 ~]# firefox ftp://172.25.0.11

防火墙策略管理

硬件防火墙

软件防火墙
RHEL7防火墙体系
系统服务:firewalld
管理工具:firewall-cmd(命令)
       firewall-config(图形)
预设安全区域:根据所在的网络场所区分,预设保护规则集
  public:仅允许访问本机的ssh,dhcp,ping等少数几个服务
  trusted:允许任何访问
  block:阻塞任何来访请求,明确拒绝
  drop:丢弃任何来访的数据包,直接丢弃
#防火墙默认区域:public

防火墙进入区域的判定规则:(遵循匹配即停止原则)
  1.查看访问请求中源IP地址,查询所有的区域中,哪个区域有该源IP的策略,则进入该区域
  2.进入默认区域即可

防火墙默认区域修改
查看默认区域firewall-cmd --get-default-zone
修改默认区域firewall-cmd --set-default-zone=区域
[root@server0 ~]# firewall-cmd --get-default-zone 
public
[root@server0 ~]# firewall-cmd --set-default-zone=block
success
[root@server0 ~]# firewall-cmd --set-default-zone=public
success


默认区域的服务添加
查看服务:[root@server0 ~]# firewall-cmd --zone=区域 --list-all 
添加服务:[root@server0 ~]# firewall-cmd --zone=区域 --add-service=服务
[root@server0 ~]# firewall-cmd --zone=public --list-all 
public (default, active)
  interfaces: eth0
  sources: 
  services: dhcpv6-client ftp http ssh
  ports: 
  masquerade: no
  forward-ports: 
  icmp-blocks: 
  rich rules: 
[root@server0 ~]# firewall-cmd --zone=public --add-service=ftp
success
[root@server0 ~]# firewall-cmd --zone=public --add-service=http
success
[root@desktop0 ~]# firefox 172.25.0.11
[root@desktop0 ~]# firefox ftp://172.25.0.11

########################################################
互联网中常见协议:默认端口号
1.http:超文本传输协议:80
2.https:安全的超文本传输协议:443  
3.ftp:文件传输协议:21
4.tftp:简单的文件传输协议:69
5.dns:域名解析协议:53
6.smtp:发邮件协议:25
7.pop3:收邮件协议:110
8.telnet:远程管理协议:161
9.snmp:网络管理协议:23  
########################################################

互联网怎样找到另一台主机:通过IP地址
如何找到主机上相应的程序:端口
端口:标识服务或程序,编号
     允许改变端口号,也允许一个服务或程序具备多个端口
数据包(四要素):源IP地址,目标IP地址,数据,端口


=================================================================================
			02.Engineer-day04
=================================================================================
############################################################
环境准备:设置防火墙默认区域为trusted(允许所有访问)
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
############################################################

Samba服务基础,配置SMB共享:Windows&Linux跨平台的共享
用途:为客户机提供共享使用的文件夹
协议:SMB(TCP 139)验证.CIFS(TCP 445)传输数据

搭建基本的samba共享服务
服务端:虚拟机Server0
1.安装软件包samba(服务名:smb)
[root@server0 ~]# yum -y install samba
2.建立samba共享帐号:专用于验证samba共享服务的用户名
#######################################################
注意:
a.先创建同名的系统用户     
#为了安全,创建系统用户时采用/sbin/nologin及不设置用户密码
b.samba共享帐号采用独立设置的密码
#######################################################
pdbedit -a 用户名    #添加用户为samba共享帐号
pdbedit -L         #列出所有的samba共享帐号
pdbedit -x 用户名   #删除samba共享帐号
3.修改配置文件vim /etc/samba/smb.conf
命令模式:G到最后一行,o跳到下一行开始编辑
格式:
[自定义共享名]             #不可用特殊字符
path = 文件夹绝对路径
public = yes|no              #默认no
browseable = yes|no          #默认yes
read only = yes|no           #默认yes
write list = 用户1...            #默认无
valid users = 用户1...          #默认任何用户
host allow = 客户机地址         #默认为空
host deny = 客户机地址          #默认为空
4.重启smb服务
[root@server0 ~]# systemctl restart smb
[root@server0 ~]# systemctl enable smb
5.SElinux的布尔值设置(功能的开关on/off)
getsebool -a | grep samba  #查看samba的波尔值
setsebool  samba_export_all_ro on  #设置samba_export_all_ro波尔值为on
*需要加-P选项才能实现永久设置
[root@server0 ~]# getsebool -a | grep samba
*SElinux三大策略:布尔值,上下文值,非默认端口开放

客户端:虚拟机desktop0
1.安装软件包samba-client(用于访问服务端共享)
[root@desktop0 ~]# yum -y install samba-client
2.显示服务端共享内容
命令格式:smbclient -L //服务器IP地址
Enter root's password: (直接敲回车)
示例:
[root@desktop0 ~]# smbclient -L //172.25.0.11
Enter root's password: (直接敲回车)
Anonymous login successful
Domain=[MYGROUP] OS=[Unix] Server=[Samba 4.1.1]
Sharename       Type      Comment
---------               ----          -------
common          Disk      
IPC$            IPC       IPC Service (Samba Server Version 4.1.1)
#共享名sharename为common
#######################################################################
3.访问共享
[root@desktop0 ~]# smbclient -U 共享帐号用户名 //服务器IP地址/共享名
示例:
[root@desktop0 ~]# smbclient -U harry //172.25.0.11/common
Enter harry's password: (输入harry的密码)
Domain=[MYGROUP] OS=[Unix] Server=[Samba 4.1.1]
smb: \> ls
NT_STATUS_ACCESS_DENIED listing \*   #权限不足---->服务端操作第5步
#######################################################################


!!更加科学方便的方式访问samba共享服务:挂载!!
1.安装软件cifs-utils(支持cifs传输协议)
[root@desktop0 ~]# yum -y install cifs-utils 
2.创建挂载点文件夹
mkdir /路径/文件夹
3.挂载
mount -o user=用户名,pass=用户密码 //服务器IP地址/共享名 /挂载点路径
示例:
[root@desktop0 ~]# yum -y install cifs-utils 
[root@desktop0 ~]# mkdir /mnt/nsd01
[root@desktop0 ~]# mount -o user=harry,pass=123 //172.25.0.11/common /mnt/nsd01/
4.设置开机自动挂载vim /etc/fstab
格式:
//服务器IP地址/共享名 /挂载点路径 cifs defaults,user=用户名,pass=用户密码,_netdev 0 0
#_netdev:在开机启动时,挂载带有_netdev参数的设备,会先将网络服务部署完成,配置好所有网络参数,再挂载本设备
5.验证并挂载
umount /原挂载路径
mount -a 
df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h


读写的samba共享

服务端:虚拟机server0:
1.发布共享目录/devops,共享名为devops
[root@server0 ~]# mkdir /devops
[root@server0 ~]# echo 123 > /devops/a.txt
[root@server0 ~]# ls /devops/
[root@server0 ~]# vim /etc/samba/smb.conf 
  [devops]
  path = /devops
  write list = chihiro   #服务配置允许chihiro可以写
2.重启smb服务
[root@server0 ~]# systemctl restart smb
3.SElinux的布尔值设置(功能的开关on/off)
[root@server0 ~]# getsebool -a |grep samba
[root@server0 ~]# setsebool samba_export_all_rw on
客户端:虚拟机desktop0
4.软件安装检测rpm -q cifs-utils
4.设置开机自动挂载
[root@desktop0 ~]# mkdir /mnt/nsd02
[root@desktop0 ~]# vim /etc/fstab 
5.验证并挂载
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
6.设置acl权限
[root@server0 ~]# setfacl -m chihiro:rwx /devops/

总结:客户端访问服务端影响的方面
1.防火墙
2.SELinux
3.服务本身的策略
4.服务端本地目录的权限

例题:
1.在虚拟机server0利用samba共享目录/nsd1807,发布共享名为test
2.实现harry用户对该共享拥有可读写的权限
3.在虚拟机desktop0,实现该共享开机自动挂载到/mnt/pub

*了解内容
multiuser机制
在客户端实现samba挂载时,采用权限较小的用户验证,必要时可以切换成权限较大的用户身份


配置NFS共享(Linux&Linux之间的共享)
Network File System网络文件系统
用途:为客户机提供共享使用的文件夹
协议:NFS(TCP/UDP 2049),RPC(TCP/UDP 111)

服务端:server0
1.安装软件包nfs-utils
2.创建贡献文件夹
mkdir /共享文件夹路径
3.修改配置文件vim /etc/exports
格式:
   文件夹路径         客户机1地址(权限) 客户机2地址(权限) ... ...
/共享文件夹路径           *(ro)
4.重启nfs-server服务
[root@server0 ~]# systemctl restart nfs-server
[root@server0 ~]# systemctl enable nfs-server

客户端:desktop0
1.创建挂载点文件夹
mkdir /挂载点文件夹路径
2.设置开机自动挂载:vim /etc/fstab
格式:
服务器IP地址:/共享文件夹路径 /挂载点文件夹路径 nfs defaults,_netdev 0 0
3.验证并挂载
mount -a 
df -h

示例:
发布共享文件夹/abc
[root@server0 ~]# mkdir /abc
[root@server0 ~]# echo 123 > /abc/123.txt
[root@server0 ~]# ls /abc/
[root@server0 ~]# vim /etc/exports
    /abc *(ro)
[root@server0 ~]# systemctl restart nfs-server
[root@server0 ~]# systemctl enable nfs-server
[root@desktop0 ~]# mkdir /mnt/nfs 
[root@desktop0 ~]# vim /etc/fstab 
172.25.0.11:/abc /mnt/nfs nfs defaults,_netdev 0 0
[root@desktop0 ~]# mount -a 
[root@desktop0 ~]# df -h


配置IPv6地址
IPV6地址:128个二进制组成,以:分隔8部分,4个16进制表示
每段内连续的前置0可省略,连续的多个:可简化为::
例如:2008:ac18:0000:0000:0000:0000:0000:0305/64
    2008:ac18::305/64
例题:
为虚拟机server0的接口eth0配置IPv6地址:2008:ac18::305/64
[root@server0 ~]# nmcli connection modify 'System eth0' ipv6.method manual ipv6.addresses 2008:ac18::305/64 connection.autoconnect yes
[root@server0 ~]# nmcli connection up 'System eth0' 
[root@server0 ~]# ifconfig |head -4
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
       inet 172.25.0.10  netmask 255.255.255.0  broadcast 172.25.0.255
       inet6 2008:ac18::305  prefixlen 64  scopeid 0x0<global>
       inet6 fe80::5054:ff:fe00:a  prefixlen 64  scopeid 0x20<link>
[root@server0 ~]# ping6 -c 2 2008:ac18::305
PING 2008:ac18::305(2008:ac18::305) 56 data bytes
64 bytes from 2008:ac18::305: icmp_seq=1 ttl=64 time=0.102 ms
64 bytes from 2008:ac18::305: icmp_seq=2 ttl=64 time=0.070 ms
--- 2008:ac18::305 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.070/0.086/0.102/0.016 ms


环境变量
PATH=为执行命令时,提供搜寻命令对应程序文件的路径
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
用法示例
[root@server0 ~]# vim /etc/hello.sh
 #!/bin/bash
 echo hello
[root@server0 ~]# chmod +x /etc/hello.sh 
[root@server0 ~]# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
[root@server0 ~]# cp /etc/hello.sh  /usr/bin/
[root@server0 ~]# hello.sh 
[root@server0 ~]# cd /
[root@server0 /]# hello.sh 


=================================================================================
			02.Engineer-day05
=================================================================================
iSCSI网络磁盘
Internet SCSI
一种基于C/S架构的虚拟磁盘技术
服务器分享提供磁盘空间,客户机连接并当成本地磁盘使用

backstore 后端存储(共享的设备)
对应到服务端提供实际存储空间的设备,需要起一个管理名称
target 磁盘组
是客户端的访问目标,作为一个框架,由多个lun组成
lun 逻辑单元
每一个lun需要关联到某一个后端存储设备,在客户端会视为一块虚拟磁盘
#将后端存储放入磁盘组

ISCSI Qualified Name 名称规范
iqn.yyyy-mm.倒序域名:自定义标识
作用:用来识别target磁盘组,也用来识别客户机身份


I.进行分区
利用fdisk对/dev/vdb进行分区,将所有空间全部分配给第一个主分区10G
fdisk /dev/磁盘路径
[root@server0 ~]# fdisk /dev/vdb
[root@server0 ~]# lsblk 
vdb    253:16   0  10G  0 disk 
└─vdb1 253:17   0  10G  0 part 
[root@server0 ~]# ls /dev/vdb1
/dev/vdb1

II.搭建网络共享磁盘
服务端:虚拟机server0
1.安装软件targetcli
[root@server0 ~]# yum -y install targetcli
2.运行targetcli进行配置
[root@server0 ~]# targetcli 
/> ls
o- / ........................................................... [...]
  o- backstores ................................................ [...]
  | o- block .................................... [Storage Objects: 0]
  | o- fileio ................................... [Storage Objects: 0]
  | o- pscsi .................................... [Storage Objects: 0]
  | o- ramdisk .................................. [Storage Objects: 0]
  o- iscsi .............................................. [Targets: 0]
  o- loopback ........................................... [Targets: 0]

a.建立backstore后端存储
命令格式:/> backstores/block create name=后端存储名称 dev=/dev/磁盘路径
/> backstores/block create name=nsd dev=/dev/vdb1
Created block storage object nsd using /dev/vdb1.
/> ls
o- / ........................................................... [...]
  o- backstores ................................................ [...]
  | o- block .................................... [Storage Objects: 1]
  | | o- nsd ............ [/dev/vdb1 (10.0GiB) write-thru deactivated]
  | o- fileio ................................... [Storage Objects: 0]
  | o- pscsi .................................... [Storage Objects: 0]
  | o- ramdisk .................................. [Storage Objects: 0]
  o- iscsi .............................................. [Targets: 0]
  o- loopback ........................................... [Targets: 0]

b.建立target磁盘组
命令格式:iscsi/ create 磁盘组名(格式:iqn.yyyy-mm.倒序域名:自定义标识)
/> iscsi/ create iqn.2018-08.com.exampl:server0
Created target iqn.2018-08.com.example:server0.
Created TPG 1.
/> ls
o- / ........................................................... [...]
  o- backstores ................................................ [...]
  | o- block .................................... [Storage Objects: 1]
  | | o- nsd ............ [/dev/vdb1 (10.0GiB) write-thru deactivated]
  | o- fileio ................................... [Storage Objects: 0]
  | o- pscsi .................................... [Storage Objects: 0]
  | o- ramdisk .................................. [Storage Objects: 0]
  o- iscsi .............................................. [Targets: 1]
  | o- iqn.2018-08.com.example:server0 ...................... [TPGs: 1]
  |   o- tpg1 ................................. [no-gen-acls, no-auth]
  |     o- acls ............................................ [ACLs: 0]
  |     o- luns ............................................ [LUNs: 0]
  |     o- portals ...................................... [Portals: 0]
  o- loopback ........................................... [Targets: 0]

c.进行lun关联
命令格式:iscsi/磁盘组名/tpg1/luns create /backstores/block/后端存储名 
/> iscsi/iqn.2018-08.com.example:server0/tpg1/luns create /backstores/block/nsd 
/> ls
o- / ........................................................... [...]
  o- backstores ................................................ [...]
  | o- block .................................... [Storage Objects: 1]
  | | o- nsd .............. [/dev/vdb1 (10.0GiB) write-thru activated]
  | o- fileio ................................... [Storage Objects: 0]
  | o- pscsi .................................... [Storage Objects: 0]
  | o- ramdisk .................................. [Storage Objects: 0]
  o- iscsi .............................................. [Targets: 1]
  | o- iqn.2018-08.com.example:server0 ...................... [TPGs: 1]
  |   o- tpg1 ................................. [no-gen-acls, no-auth]
  |     o- acls ............................................ [ACLs: 0]
  |     o- luns ............................................ [LUNs: 1]
  |     | o- lun0 ............................ [block/nsd (/dev/vdb1)]
  |     o- portals ...................................... [Portals: 0]
  o- loopback ........................................... [Targets: 0]

d.设置ACL访问控制:iqn进行标识客户端    #设置客户端声称的iqn标识名
命令格式:iscsi/磁盘组名/tpg1/acls create 客户端声称的iqn标识名
/> iscsi/iqn.2018-08.com.example:server0/tpg1/acls create iqn.2018-08.com.example:desktop0
Created Node ACL for iqn.2018-08.com.example:desktop0
Created mapped LUN 0.
/> ls
o- / ........................................................... [...]
  o- backstores ................................................ [...]
  | o- block .................................... [Storage Objects: 1]
  | | o- nsd .............. [/dev/vdb1 (10.0GiB) write-thru activated]
  | o- fileio ................................... [Storage Objects: 0]
  | o- pscsi .................................... [Storage Objects: 0]
  | o- ramdisk .................................. [Storage Objects: 0]
  o- iscsi .............................................. [Targets: 1]
  | o- iqn.2018-08.com.example:server0 ...................... [TPGs: 1]
  |   o- tpg1 ................................. [no-gen-acls, no-auth]
  |     o- acls ............................................ [ACLs: 1]
  |     | o- iqn.2018-08.com.example:desktop0 ....... [Mapped LUNs: 1]
  |     |   o- mapped_lun0 ..................... [lun0 block/nsd (rw)]
  |     o- luns ............................................ [LUNs: 1]
  |     | o- lun0 ............................ [block/nsd (/dev/vdb1)]
  |     o- portals ...................................... [Portals: 0]
  o- loopback ........................................... [Targets: 0]

e.设置本机允许客户端访问的IP地址,端口号(自动设置成默认端口)
命令格式:iscsi/磁盘组名/tpg1/portals create 服务器IP地址
/> iscsi/iqn.2018-08.com.example:server0/tpg1/portals create 172.25.0.11
Using default IP port 3260     #默认端口号
Created network portal 172.25.0.11:3260.
/> ls
o- / ........................................................... [...]
  o- backstores ................................................ [...]
  | o- block .................................... [Storage Objects: 1]
  | | o- nsd .............. [/dev/vdb1 (10.0GiB) write-thru activated]
  | o- fileio ................................... [Storage Objects: 0]
  | o- pscsi .................................... [Storage Objects: 0]
  | o- ramdisk .................................. [Storage Objects: 0]
  o- iscsi .............................................. [Targets: 1]
  | o- iqn.2018-08.com.example:server0 ...................... [TPGs: 1]
  |   o- tpg1 ................................. [no-gen-acls, no-auth]
  |     o- acls ............................................ [ACLs: 1]
  |     | o- iqn.2018-08.com.example:desktop0 ....... [Mapped LUNs: 1]
  |     |   o- mapped_lun0 ..................... [lun0 block/nsd (rw)]
  |     o- luns ............................................ [LUNs: 1]
  |     | o- lun0 ............................ [block/nsd (/dev/vdb1)]
  |     o- portals ...................................... [Portals: 1]
  |       o- 172.25.0.11:3260 ................................... [OK]
  o- loopback ........................................... [Targets: 0]

f.退出,设置重启target服务,开机自启
命令格式:exit
	 systemctl restart target
	 systemctl enable target
/> exit
Global pref auto_save_on_exit=true
Last 10 configs saved in /etc/target/backup.
Configuration saved to /etc/target/saveconfig.json
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable target


客户端:虚拟机desktop0
1.安装软件包iscsi-initiator-utils
#默认已安装好,直接rpm -q检测
rpm -q iscsi-initiator-utils
iscsi-initiator-utils-6.2.0.873-21.el7.x86_64

2.修改配置文件/etc/iscsi/initiatorname.iscsi ,指定客户端声称的iqn标识名
格式:InitiatorName=客户端iqn标识名
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi 
InitiatorName=iqn.2018-08.com.example:desktop0

3.重启iscsid服务,刷新客户端声称iqn标识名
命令格式:systemctl restart iscsid
[root@desktop0 ~]# systemctl restart iscsid
#如果提示:
Warning: Unit file of iscsid.service changed on disk,
'systemctl daemon-reload'recommended.
则按照提示输入命令systemctl daemon-reload进行操作

4.寻找服务端共享存储:借鉴man帮助手册
step1.新开一个终端
step2.man iscsiadm
step3./examples
step4.复制:iscsiadm --mode discoverydb --type sendtargets --portal 192.168.1.10 --discover
step5.将192.168.1.10改成服务端IP地址
iscsiadm --mode discoverydb --type sendtargets --portal 服务端IP地址 --discover
[root@desktop0 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover
172.25.0.11:3260,1 iqn.2018-08.com.exampl:server0

5.重启iscsi服务,加载识别共享存储 
命令格式:systemctl restart iscsi
	 systemctl enable iscsi
[root@desktop0 ~]# lsblk
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
vda    253:0    0  10G  0 disk 
└─vda1 253:1    0  10G  0 part /
vdb    253:16   0  10G  0 disk 
[root@desktop0 ~]# systemctl restart iscsi
[root@desktop0 ~]# systemctl enable iscsi
[root@desktop0 ~]# lsblk
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda      8:0    0  10G  0 disk 
vda    253:0    0  10G  0 disk 
└─vda1 253:1    0  10G  0 part /
vdb    253:16   0  10G  0 disk 
#可以对sda在客户端进行分区规划,格式化,挂载使用

6.登入/登出设备
man iscsiadm
/EXAMPLES
iscsiadm --mode node --targetname 后端存储iqn名称 --portal iscsi服务器ip:3260 --login或-l
iscsiadm --mode node --targetname 后端存储iqn名称 --portal iscsi服务器ip:3260 --logout或-u


构建数据库系统

数据库管理
MariaDB:RHEL7系统默认数据库软件

部署MariaDB数据库服务器<默认端口:3306>
I.安装软件包,重启服务
mariadb-server:提供服务端有关的系统程序
mariadb:提供客户端及管理工具	#由于依赖关系安装mariadb-server时自动安装
[root@server0 ~]# yum -y install mariadb-server
重启服务
[root@server0 ~]# systemctl restart mariadb
[root@server0 ~]# systemctl enable mariadb


II.数据库基本操作
[root@server0 ~]# mysql                  #未设置密码进入数据库

MariaDB [(none)]> show databases;        #查看所有库
MariaDB [(none)]> create database 库名称;  #新建库
MariaDB [(none)]> drop database 库名称;    #删除库

MariaDB [(none)]> exit                  #退出数据库模式
Bye

III.为数据库管理员设置密码

数据库管理员:用户名root,对整个数据库最高权限,mysql库中user表
系统管理员:用户名root,对整个Linux系统最高权限,/etc/passwd

在Linux命令行:
[root@server0 ~]#mysqladmin -u 用户名 password '新密码'       #第一次设置密码

[root@server0 ~]# mysql -u root -p                          #交互式进入数据库
Enter password: 

[root@server0 ~]# mysql -u root -p密码                      #非交互式进入数据库

[root@server0 ~]#mysqladmin -u 用户名 -p旧密码 password '新密码'    #修改密码

##############################################
*了解内容
数据库的主配置文件
禁止监听,仅服务于本机
vim /etc/my.cnf
  [mysald]
  skip-networking           #跳过网络监听
systemctl restart mariadb   #重启mariadb服务
#############################################

IV.数据库的数据恢复
导入/恢复到数据库
Linux命令行:
cd /       #要在根目录下操作
wget http://classroom.example.com/pub/materials/users.sql
mysql -u 用户名 -p密码 数据库名 < 备份文件.sql
[root@server0 /]# wget http://classroom.example.com/pub/materials/users.sql
[root@server0 /]# mysql -u root -p123 nsd < users.sql
#将数据users.sql以root身份,恢复到nsd库中

V.对于表格操作
表字段:表头 
表记录:数据内容
四大操作:增:insert,删:delete,改:update,查:select

use 库名称;  			 	   
#进入库
show tables; 	     		  
#列出所有表格
select * from 表名称;              	  
#查看表中所有内容
select 表字段1,表字段2 from 表名称;   
#查看表字段1,表字段2内容,输出结果会根据表字段1,2顺序发生变化
select 表字段 from 表名称;             
#查看表字段内容

[root@server0 ~]# mysql -u root -p123 
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 12
Server version: 5.5.35-MariaDB MariaDB Server

Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> show databases;
+-----------------------------------+
| Database                          |
+-----------------------------------+
| information_schema                |
| mysql                             |
| nsd                               |
| performance_schema                |
| test                              |
+-----------------------------------+
5 rows in set (0.00 sec)

MariaDB [(none)]> use nsd;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MariaDB [nsd]> show tables;
+--------------------------+
| Tables_in_nsd            |
+--------------------------+
| base                     |
| location                 |
+--------------------------+
2 rows in set (0.00 sec)

MariaDB [nsd]> select * from base;
+----------+----------------+---------------------+
| id       | name           | password            |
+----------+----------------+---------------------+
|    1     | Tom            | 123                 |
|    2     | Barbara        | 456                 |
|    3     | James          | solicitous          |
|    4     | Smith          | tarena              |
|    5     | Barbara        | pwd123              |
+----------+----------------+---------------------+
5 rows in set (0.00 sec)

MariaDB [nsd]> select * from location;
+------+-----------+
| id   | city      |
+------+-----------+
|    1 | Beijing   |
|    2 | Paris     |
|    3 | Sunnyvale |
|    4 | Berlin    |
|    5 | Sunnyvale |
+------+-----------+
5 rows in set (0.00 sec)

MariaDB [nsd]> select password,name from base;
+------------+---------+
| password   | name    |
+------------+---------+
| 123        | Tom     |
| 456        | Barbara |
| solicitous | James   |
| tarena     | Smith   |
| pwd123     | Barbara |
+------------+---------+
5 rows in set (0.00 sec)

MariaDB [nsd]> select name,password from base;
+---------+------------+
| name    | password   |
+---------+------------+
| Tom     | 123        |
| Barbara | 456        |
| James   | solicitous |
| Smith   | tarena     |
| Barbara | pwd123     |
+---------+------------+
5 rows in set (0.00 sec)

VI.有条件的查询
1.对当前所在库进行查询操作
select  表字段(*) from 表名 where 表字段='值';   
#第一个表字段若是*则扩展查询结果表字段行
MariaDB [nsd]> show tables;
+---------------+
| Tables_in_nsd |
+---------------+
| base          |
| location      |
+---------------+
2 rows in set (0.00 sec)

MariaDB [nsd]> select password from base where password='456';
+----------+
| password |
+----------+
| 456      |
+----------+
1 row in set (0.00 sec)

MariaDB [nsd]> select * from base where password='456';
+------+---------+----------+
| id   | name    | password |
+------+---------+----------+
|    2 | Barbara | 456      |
+------+---------+----------+
1 row in set (0.00 sec)


2.对非当前库进行查询操作
select 表字段(*) from 库名称.表名称 where 表字段='值';  
MariaDB [nsd]> use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
MariaDB [mysql]> select password from nsd.base where password='456';
+----------+
| password |
+----------+
| 456      |
+----------+
1 row in set (0.00 sec)

MariaDB [mysql]> select * from nsd.base where password='456';
+------+---------+----------+
| id   | name    | password |
+------+---------+----------+
|    2 | Barbara | 456      |
+------+---------+----------+
1 row in set (0.00 sec)


3.查看表结构
desc 表名称;  

MariaDB [nsd]> use mysql
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A
Database changed
MariaDB [mysql]> desc user;
MariaDB [mysql]> select user,host,password from user;

4.联合表查询
select * from 表名1,表名2 where 表名1.表字段1='值1' and 表名2.表字段2='值2' 表1.id=表2.id;

select count(*) from 表名1,表名2 where 表名1.表字段1='值1' and 表名2.表字段2='值2' 表1.id=表2.id;
#符合以上条件的数量有多少

VII.数据库的授权
grant 权限列表 on 数据库名.表名 to 用户名@客户机地址 identified by '密码';

权限列表:insert,delete,update,select,all

例题
除了root用户,此nsd数据库只能被用户lisi查询,此用户的密码为123
grant select on nsd.* to lisi@localhost identified by '123'
#当用户lisi从本地localhost进行登录输入密码123,将会获得nsd库中所有表的查询权限
[root@server0 ~]# mysql -u root -p123
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 13
Server version: 5.5.35-MariaDB MariaDB Server

Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> grant select on nsd.* to lisi@localhost identified by '123';
Query OK, 0 rows affected (0.01 sec)

MariaDB [(none)]> select user,password from mysql.user;
+------+-------------------------------------------+
| user | password                                  |
+------+-------------------------------------------+
| root | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
| root |                                           |
| root |                                           |
| root |                                           |
|      |                                           |
|      |                                           |
| lisi | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
+------+-------------------------------------------+
7 rows in set (0.00 sec)


VIII.插入表数据
insert 表名 values ('表记录1','表记录2','表记录3')

MariaDB [nsd]> select * from base;
+------+---------+------------+
| id   | name    | password   |
+------+---------+------------+
|    1 | Tom     | 123        |
|    2 | Barbara | 456        |
|    3 | James   | solicitous |
|    4 | Smith   | tarena     |
|    5 | Barbara | pwd123     |
+------+---------+------------+

MariaDB [nsd]> insert base values ('6','Barbara','789');

MariaDB [nsd]> select * from base;
+------+---------+------------+
| id   | name    | password   |
+------+---------+------------+
|    1 | Tom     | 123        |
|    2 | Barbara | 456        |
|    3 | James   | solicitous |
|    4 | Smith   | tarena     |
|    5 | Barbara | pwd123     |
|    6 | Barbara | 789        |
+------+---------+------------+
6 rows in set (0.00 sec)

IX.删除表数据
delete from 库名.表名 where 表字段='值'

禁止空密码root用户访问mariadb 数据库
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> select user,host,password from mysql.user;
MariaDB [(none)]> select user,host,password from mysql.user where password='';
MariaDB [(none)]> delete from mysql.user where password=''; #删除记录
MariaDB [(none)]> flush privileges;  #刷新user记录
MariaDB [(none)]> exit
测试登录不成功
[root@server0 ~]# mysql -u root -h server0.example.com
ERROR 1130 (HY000): Host 'server0.example.com' is not allowed to  connect to this MariaDB server


=================================================================================
			02.Engineer-day06
=================================================================================

Web通信基本概念
基于B/S(Browser/Server)架构的网页服务
服务端提供网页
浏览器下载并显示网页

超文本标记语言Hyper Text  Markup  Language(html)
超文本传输协议Hyper Text Transfer Protocol(http)-->默认端口80

Tengine:Nginx基础上,针对大访问量的一个高效,安全的web服务器,适合高并发

RHEL7中的Web服务
提供默认配置: 
Listen:监听地址:端口(默认:80)
ServerName:本站点注册的DNS名称
DocumentRoot:网页文件根目录(默认:/var/www/html)
DirectoryIndex:起始页/首页文件名(默认:index.html)

搭建Web服务器
服务端:虚拟机Server0
1.安装软件httpd
[root@server0 ~]# yum -y install httpd
2.重启httpd服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
3.测试:访问测试页面
[root@server0 ~]# firefox 172.25.0.11
4.书写一个自己的页面
[root@server0 ~]# echo '<h1>NSD1807 Web01' > /var/www/html/index.html
[root@server0 ~]# cat /var/www/html/index.html 



ServerName:本站点注册的DNS名称
DNS服务器:Classroom.example.com
#可解析的域名:
server0.example.com
www0.example.com
webapp0.example.com
服务端:虚拟机server0
1.修改主配置文件
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
#################################################
Vim:显示行号,末行模式下:set nu
#################################################
/ServerName        #搜索ServerName
#ServerName www.example.com:80---->ServerName server0.example.com:80
2.重启httpd服务
[root@server0 ~]# systemctl restart httpd
客户端:虚拟机desktop0
测试访问:[root@desktop0 ~]# firefox server0.example.com

DocumentRoot:网页文件根目录(默认:/var/www/html)
服务端:虚拟机server0
1.修改主配置文件
[root@server0 ~]# mkdir /var/www/myweb
[root@server0 ~]# echo '<h1>wo shi myweb' > /var/www/myweb/index.html
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
DocumentRoot "/var/www/html"---->DocumentRoot "/var/www/myweb"
2.重启httpd服务
[root@server0 ~]# systemctl restart httpd
客户端:虚拟机desktop0
测试访问:[root@desktop0 ~]# firefox server0.example.com
#######################################################################
网络路径与实际路径区别
客户端:firefox server0.example.com-->firefox 172.25.0.11
服务端:httpd-->/etc/httpd/conf/httpd.conf-->DocumentRoot-->网页文件根目录

客户端:firefox server0.example.com/abc-->服务端:/网页文件根目录/abc
#######################################################################


虚拟Web主机
由一台服务器提供多个不同的Web站点

构建/区分方式
基于域名的虚拟主机
基于端口的虚拟主机
基于IP地址的虚拟主机(已被淘汰)

1.基于域名的虚拟主机
配置文件路径
/etc/httpd/conf/httpd.conf
/etc/httpd/conf.d/*.conf(调用配置文件)
为每个虚拟站点添加配置
<VirtualHost IP地址:端口>
  ServerName 此站点的DNS名称
  DocumentRoot 此站点的网页文件根目录
</VirtualHost>
[root@server0 ~]# mkdir /var/www/qq /var/www/bing
[root@server0 ~]# echo '<h1>马化腾' >/var/www/qq/index.html
[root@server0 ~]# echo '<h1>比尔盖茨' >/var/www/bing/index.html
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
  <VirtualHost *:80>
  servername www0.example.com
  DocumentRoot /var/www/qq
  </VirtualHost>
  <VirtualHost *:80>
  servername webapp0.example.com
  DocumentRoot /var/www/bing
  </VirtualHost>
[root@server0 ~]# systemctl restart httpd
#若重启httpd不生效不生效,则killall httpd 杀死所有httpd程序再重启httpd服务

一旦使用虚拟Web主机功能,所有的Web站点都必须用虚拟Web主机来实现
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
  <VirtualHost *:80>
  servername server0.example.com
  DocumentRoot /var/www/myweb
  </VirtualHost>

################################################################
httpd的访问控制
使用<Directory>配置区段
每个文件夹自动继承其父目录的ACL访问权限
除非针对子目录有明确设置

<Directory 目录的绝对路径>
  Require all denied|granted
  Require ip IP或网段地址
</Directory>
################################################################

SELinux安全上下文值(标签,标识文件或目录)
httpd服务下修改SELinux安全上下文值
chcon -R --reference=/var/www/ /要修改的路径
#以/var/www/为模板,修改/要求改的路径的上下文值

###############################################################
案例:使用自定义Web网页文件根目录
调整 Web 站点 http://server0.example.com 的网页目录,
要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
4)确保站点 http://server0.example.com 仍然可访问

虚拟机Server0
1.新建目录 /webroot,修改配置文件
# mkdir /webroot
# echo '<h1>wo shi webroot' > /webroot/index.html

# vim /etc/httpd/conf.d/nsd01.conf   #修改内容
 <VirtualHost *:80>
   ServerName  server0.example.com
   DocumentRoot  /webroot           #修改网页文件根目录
 </VirtualHost>

2.修改配置文件，实现访问控制 
# vim /etc/httpd/conf.d/nsd02.conf   #追加写入
 <Directory /webroot>
    Require  all  granted            #允许所有人访问
 </Directory>

[root@server0 ~]# systemctl restart httpd

3.SELinux安全上下文值（标签，标识文件或目录）
[root@server0 ~]# ls -Zd /var/www/      #查看目录的上下文值
[root@server0 ~]# ls -Zd /webroot/      #查看目录的上下文值

 ——以/var/www/为模版，修改/webroot的上下文值   -R：递归修改
[root@server0 ~]# chcon -R --reference=/var/www/  /webroot/

[root@server0 ~]# ls -Zd /webroot/      #查看目录的上下文值

虚拟机desktop：
[root@desktop0 ~]# firefox server0.example.com
###############################################################




部署动态页面

静态网站的运行
服务端的原始网页=浏览器访问到的网页
由Web服务软件处理所有请求
文本(txt/html),图片(jpg/png)等静态资源
动态网站的运行
服务端的原始网页!=浏览器访问到的网页
由Web服务软件接受请求,动态程序转后端模块处理
PHP网页,Python网页,JSP网页

1.部署Python页面,放到webapp0.example.com的Documentroot目录
[root@server0 ~]# cd /var/www/bing/
[root@server0 bing]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

2.方便客户端访问,网页跳转(网页访问路径别名)
Alias 客户端网络路径 实际原始路径
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
servername webapp0.example.com
DocumentRoot /var/www/bing
Alias / /var/www/bing/webinfo.wsgi
</VirtualHost>
#客户端访问到网页文件根目录时,将webinfo.wsgi页面呈现
[root@server0 bing]# systemctl restart httpd
客户端:访问测试看到Python代码页面
[root@desktop0 ~]# firefox webapp0.example.com

3.翻译Python的Web页面内容
[root@desktop0 ~]# yum -y install mod_wsgi
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
servername webapp0.example.com
DocumentRoot /var/www/bing
WsgiScriptAlias / /var/www/bing/webinfo.wsgi
</VirtualHost>
[root@server0 bing]# systemctl restart httpd
[root@desktop0 ~]# firefox webapp0.example.com

*4.额外要求:此虚拟主机侦听在端口8909
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
Listen 8909
<VirtualHost *:8909>
servername webapp0.example.com
DocumentRoot /var/www/bing
WsgiScriptAlias / /var/www/bing/webinfo.wsgi
</VirtualHost>
[root@server0 ~]# systemctl restart httpd
Job for httpd.service failed. See 'systemctl status httpd.service' and 'journalctl -xn' for details.

5.SELinux非默认端口的开放
[root@server0 ~]# semanage port -l | grep http
http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010
http_cache_port_t              udp      3130
http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000
pegasus_http_port_t            tcp      5988
pegasus_https_port_t           tcp      5989
[root@server0 ~]# semanage port -a -t http_port_t -p tcp 8909
#-a:add添加,-t:type类型,-p:protocol协议
[root@server0 ~]# semanage port -l | grep http
[root@server0 ~]# systemctl restart httpd
[root@desktop0 ~]# firefox webapp0.example.com:8909
##############################
端口优先级会高于域名
webapp0.example.com:8909
#优先识别端口,访问8909端口的页面
##############################


=================================================================================
			02.Engineer-day07
=================================================================================

安全的Web服务:使用https协议,默认端口443
Secure Sockets Layer:安全套接字层
Transport Layer Security:安全传输层协议

###############################################################
公钥基础设施PKI(Public Key Infrastructure):加密传输非,对称加密
公钥:主要用来加密数据
私钥:主要用来解密数据(与相应的公钥匹配)

数字证书:证明拥有者的合法性/权威性(单位名称,有效期,公钥,颁发机构及签名,...)
数字证书授权中心Certificate Authority:
负责证书的申请/审核/颁发/鉴定/撤销等管理工作
###############################################################

I.利用基于域名的虚拟Web主机,搭建网站
server0.example.com--->web1
www0.exammple.com----->web2

1.环境准备,设置防火墙默认区域为trusted
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 

2.安装httpd软件,建立调用配置文件
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# vim /etc/httpd/conf.d/httpd.conf
[root@server0 ~]# mkdir /var/www/web1 /var/www/web2
[root@server0 ~]# echo  '<h1>web1' > /var/www/web1/index.html
[root@server0 ~]# echo '<h1>web2' > /var/www/web2/index.html
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
[root@desktop0 ~]# firefox server0.example.com
[root@desktop0 ~]# firefox www0.example.com

II.搭建安全Web服务器
1.安装支持安全功能的软件
[root@server0 ~]# yum -y install mod_ssl
[root@server0 ~]# ls /etc/httpd/conf.d/ssl.conf 
2.部署网站证书
[root@server0 tls]# cd /etc/pki/tls/certs/
[root@server0 certs]# wget http://classroom.example.com/pub/tls/certs/server0.crt
3.部署根证书
[root@server0 certs]# wget http://classroom.example.com/pub/example-ca.crt
4.部署私钥
[root@server0 certs]# cd /etc/pki/tls/private/
[root@server0 private]# wget http://classroom.example.com/pub/tls/private/server0.key
5.修改配置文件指定证书
[root@server0 ~]# vim /etc/httpd/conf.d/ssl.conf 
vim末行模式:set nu  #显示行号
59 #DocumentRoot "/var/www/html"---->DocumentRoot "/var/www/web2"
60 #ServerName www.example.com:443---->ServerName www0.example.com:443
指定网站证书位置
100 SSLCertificateFile /etc/pki/tls/certs/localhost.crt ---->
    SSLCertificateFile /etc/pki/tls/certs/server0.crt
指定私钥位置
107 SSLCertificateKeyFile /etc/pki/tls/private/localhost.key---->
    SSLCertificateKeyFile /etc/pki/tls/private/server0.key
指定根证书位置
122 #SSLCACertificateFile /etc/pki/tls/certs/ca-bundle.crt---->
    SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt
6.重启httpd服务
[root@server0 ~]# systemctl restart httpd
7.客户端desktop0验证:
[root@desktop0 ~]# firefox https://www0.example.com
我已充分了解可能的风险---->添加例外---->确认安全例外

################################################################
基础邮件服务
SMTP:用户发邮件协议 默认端口:25
pop3:用户收邮件协议 默认端口:110

DNS服务器:classroom.example.com
域名:server0.example.com

构建邮件服务器
服务端:虚拟机server0
1.安装软件postfix
[root@server0 ~]# yum -y install postfix
#默认已安装,默认随机自启
2.修改配置文件
[root@server0 ~]# vim /etc/postfix/main.cf 
末行模式:set nu
99 #myorigin = $mydomain----> myorigin = server0.example.com
#默认补全的域名后缀
116 inet_interfaces = localhost---->inet_interfaces = all
#本机所有网络接口都开放邮件功能
164 mydestination = $myhostname, localhost.$mydomain, localhost---->
mydestination = server0.example.com
#将server0.example.com判断为本域邮件
3.重启postfix服务
[root@server0 ~]# systemctl restart postfix
4.本机验证：
[root@server0 ~]# useradd yg
[root@server0 ~]# useradd xln
mail发信操作
mail -s '邮件标题' -r 发件人 收件人    #敲回车后开始输入正文内容
邮件正文内容
.                                         #单独一行.敲回车结束编辑发送
EOT
mail收信操作
mail -u 用户名
示例：
[root@server0 ~]# mail -s 'abc' -r yg xln
abcdefg
hijklmn
.
EOT
[root@server0 ~]# mail -u xln
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/mail/xln": 1 message 1 new
>N  1 yg@server0.example.c  Mon Aug 20 14:24  19/581   "abc"
&    1      #输入邮件编号，敲回车进入邮件阅读界面
Message  1:
From yg@server0.example.com  Mon Aug 20 14:24:30 2018
Return-Path: <yg@server0.example.com>
X-Original-To: xln
Delivered-To: xln@server0.example.com
Date: Mon, 20 Aug 2018 14:24:30 +0800
From: yg@server0.example.com
To: xln@server0.example.com
Subject: abc
User-Agent: Heirloom mailx 12.5 7/5/10
Content-Type: text/plain; charset=us-ascii
Status: R
abcdefg
hijklmn
& exit  #exit退出

非交互式发邮件
echo 邮件正文内容 | mail -s '邮件标题' -r 发件人 收件人
################################################################

交换空间：相当于虚拟内存
当物理内存不够用时，使用磁盘空间来模拟内存
在一定程度上缓解物理内存不足的问题
交换分区：以空闲分区充当的交换空间
交换文件：以文件模拟的设备充当的交换空间

I.parted分区工具：GPT分区模式
*使用fdisk操作>2.2TB的磁盘时
 超出容量的磁盘将会无法识别，导致分区失效
MBR 分区模式：4个主分区 容量2T
GPT 分区模式：128主分区 容量18EB
*1EB=1000PB 1PB=1000TB

[root@server0 ~]# lsblk
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
vdb    253:16   0  10G  0 disk 
[root@server0 ~]# parted /dev/vdb
(parted) mktable gpt			#指定分区模式
(parted) print				#输出所有分区信息
(parted) mkpart				#创建新的分区
分区名称？[ ]? 分区名称			#设置分区名称
文件系统类型？  [ext2]? 文件系统类型	#文件系统，不起实际作用
起始点？ 0				#分区起始点设置为0
结束点？ nG				#设置分区大小为nG
忽略/Ignore/放弃/Cancel? Ignore  	#忽略
(parted) unit GB			#使用GB作为显示单位
(parted) mkpart				#继续进行第二个分区
分区名称？[ ]? 分区名称
文件系统类型？  [ext2]? 文件系统类型
起始点？ nG				#第二个分区起始点为第一个分区结束点nG
结束点？ mG				#第二个分区结束点mG
(parted) print  
(parted) quit				#完成分区退出
*parted分区工具的GPT分区模式默认自动保存分区信息并写入硬盘
[root@server0 ~]# lsblk                                                   
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
vdb    253:16   0   10G  0 disk 
├─vdb1 253:17   0  1.9G  0 part 
└─vdb2 253:18   0  1.9G  0 part 


II.建立交换分区


1.格式化交换文件系统
[root@server0 ~]# mkswap /dev/vdb1		#格式化交换文件系统
[root@server0 ~]# mkswap /dev/vdb2		
[root@server0 ~]# blkid /dev/vdb[1-2]		#查看文件系统类型
2.启用交换分区
[root@server0 ~]# swapon /dev/vdb1		#启用交换分区
[root@server0 ~]# swapon /dev/vdb2
[root@server0 ~]# swapon -s 			
  文件        类型       大小	已用	权限
/dev/vdb1  partition  1953104	 0	 -1
/dev/vdb2  partition  1952764	 0	 -2
#权限值越大，物理内存不足时被调用存储临时数据优先级越高
3.停用交换分区
[root@server0 ~]# swapoff /dev/vdb1		#停用交换分区
[root@server0 ~]# swapoff /dev/vdb2
[root@server0 ~]# swapon -s 			#查看交换空间信息
4.设置开机自动启用交换分区
[root@server0 ~]# vim /etc/fstab 
 /dev/vdb1 swap swap defaults 0 0
 /dev/vdb2 swap swap defaults 0 0
[root@server0 ~]# swapon -a  
#专用于检测swap分区开机自动启动，mount -a不检测文件系统类型为swap的分区


配置聚合连接(也称为：链路聚合/网卡绑定)
由多张网卡(team-slave)一起组建而成的虚拟网卡
备份网卡设备：热备份(activebackup)连接冗余
	    [或轮询式(roundrobin)流量负载均衡]
客户端-->虚拟网卡:team0 192.168.1.1-->team0:etho0 eth1 ...

制作链路聚合（热备份）
1.建立虚拟网卡team0 #参考man teamd.conf /examples
step01:[root@server0 ~]# nmcli connection add type team 
                         con-name team0 ifname team0 autoconnect yes
                         config '{}'
step02:[root@server0 ~]# man teamd.conf /examples
       复制"runner": {"name": "activebackup"}
step03:[root@server0 ~]# nmcli connection add type team 
                         con-name team0 ifname team0 autoconnect yes 
                         config '{粘贴}'
------------------------------------------------------------------>
[root@server0 ~]# nmcli connection add type team 
                  con-name team0 ifname team0 autoconnect yes 
                  config '{"runner": {"name": "activebackup"}}'
#解释:nmcli connection 添加 类型 team
      配置文件名为team0 虚拟网卡名(ifconfigname)为team0 设置开机自启
      链路聚合的工作模式为 热备份
#注意：如果有错误，一定要删除重新操作
nmcli connection delete team0
2.将网卡添加为组成员(team-slave)
[root@server0 ~]# nmcli connection add type team-slave 
                  con-name team0-1 ifname eth1 master team0
[root@server0 ~]# nmcli connection add type team-slave 
                  con-name team0-2 ifname eth2 master team0
#解释:nmcli 添加 类型 组成员
     配置文件名为 team0-1或team0-2 网卡名为eth1或eth2 虚拟网卡组为team0
#注意：如果有错误，一定要删除重新操作
nmcli connection delete team0-1或team0-2
3.配置IP地址
[root@server0 ~]# nmcli connection modify team0 ipv4.method manual ipv4.addresses 192.168.1.1/24 connection.autoconnect yes
4.激活所有的配置
[root@server0 ~]# nmcli connection up team0
[root@server0 ~]# nmcli connection up team0-1
[root@server0 ~]# nmcli connection up team0-2
#先激活team0再激活组成员team0-1和team0-2
5.检测team0命令
[root@server0 ~]# teamdctl team0 state  #查看team0的信息
runner:active port: eth1
[root@server0 ~]# ifconfig eth1 down    #禁用网卡eth1
[root@server0 ~]# teamdctl team0 state  #活跃网卡切换成eth2
runner:active port: eth2


防火墙-永久配置(permanent)
临时设置：
服务端server0
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# firewall-cmd --set-default-zone=public 
[root@server0 ~]# firewall-cmd --zone=public --list-all 
[root@server0 ~]# firewall-cmd --zone=public --add-service=http
[root@server0 ~]# firewall-cmd --zone=public --list-all 
客户端desktop0
验证：[root@desktop0 ~]# firefox 172.25.0.11

设置永久：
服务端server0
[root@server0 ~]# reboot 或[root@server0 ~]# firewall-cmd --reload
[root@server0 ~]# firewall-cmd --zone=public --list-all 
#重启虚拟机或重新加载防火墙所有策略，临时设置失效
[root@server0 ~]# firewall-cmd --permanent --zone=public --add-service=http
[root@server0 ~]# firewall-cmd --zone=public --list-all 
[root@server0 ~]# firewall-cmd --reload
[root@server0 ~]# firewall-cmd --zone=public --list-all 


端口转发：
客户端虚拟机desktop0访问172.25.0.11：5423
防火墙进行端口转发成172.25.0.11:80
服务端server0
[root@server0 ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=5423:proto=tcp:toport=80
[root@server0 ~]# firewall-cmd --zone=public --list-all 
[root@server0 ~]# firewall-cmd --reload 
[root@server0 ~]# firewall-cmd --zone=public --list-all 
客户端desktop0 
#由于防火墙只对除本机外其它客户端生效，所以必须用客户端desktop测试
[root@desktop0 ~]# firefox 172.25.0.11:5423


=================================================================================
			03.Services-day01
=================================================================================

—————————————————————————————————————————————
#课外学习笔记#
远程登录ssh免密码
实现PCA免密码远程访问PCB
PCA上操作:
1.ssh-keygen -t rsa     #将生成公钥和私钥文件id_rsa.pub和id_rsa
(一直回车即可,这两个文件会在/home/$USER/.ssh下)
2.ssh-copy-id -i /home/$USER/.ssh/id_rsa.pub username@IP地址
#将id_rsa.pub文件复制到PCB
—————————————————————————————————————————————


建立新的教学环境

1.利用脚本克隆出虚拟机  
克隆rhel7系统虚拟机:
clone-vm7
Enter VM number:    #输入虚拟机编号
克隆rhel6系统虚拟机:
clone-vm6
Enter VM number:    #输入虚拟机编号
批量克隆rhel6/7系统虚拟机:
clone-auto6/7
number of vms:      #输入虚拟机数量

2.利用root登录,密码:123456
搭建虚拟机A:服务端
配置主机名:svr7.tedu.cn
配置eth0网卡的ip地址:192.168.4.7/24
搭建虚拟机B:客户端
配置主机名:pc207.tedu.cn
配置eth0网卡的ip地址:192.168.4.207/24

3.真机上操作：进行远程管理
[root@room1pc43 ~]# ifconfig private1 | head -2
private1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 192.168.4.254  netmask 255.255.255.0  broadcast 192.168.4.255

[root@room1pc43 ~]# ping -c 2 192.168.4.7
[root@room1pc43 ~]# ping -c 2 192.168.4.207

  在/root/.bashrc中设置永久别名


4.搭建Yum仓库
服务端:真机:搭建FTP共享光盘所有内容
(1)安装软件包vsftpd,默认装好
[root@room1pc43 ~]# rpm -q vsftpd 
vsftpd-3.0.2-22.el7.x86_64
(2)重启vsftpd服务,设置开机自启
[root@room1pc43 ~]# systemctl restart vsftpd
[root@room1pc43 ~]# systemctl enable vsftpd
(3)把光盘内容挂载到FTP默认共享路径
[root@room1pc43 ~]# mkdir /var/ftp/rhel7/	#默认已经建立好
[root@room1pc43 ~]# ls -ld /iso	 		#查看/iso快捷方式源路径
lrwxrwxrwx 1 rootroot 27 3月19 18:39 /iso->/var/lib/libvirt/images/iso
[root@room1pc43 ~]# vim /etc/fstab      	#默认设置好开机自动挂载
/var/lib/libvirt/images/iso/rhel-server-7.4-x86_64-dvd.iso  
/var/ftp/rhel7 iso9660 defaults 0 0
[root@room1pc43 ~]# firefox ftp://192.168.4.254/rhel7   #验证

客户端:svr7,pc207
搭建yum仓库
[root@pc207 ~]# rm -rf /etc/yum.repos.d/*
[root@pc207 ~]# vim /etc/yum.repos.d/rhel7.repo
  [rhel7]
  name=rhel7.4
  baseurl=ftp://192.168.4.254/rhel7
  enabled=1
  gpgcheck=0
[root@pc207 ~]# yum clean all 
[root@pc207 ~]# yum repolist 
[root@pc207 ~]# yum -y install xeyes   #测试安装软件


扩展应用

1.目录结构
查看Linux目录层次手册:man hier

常见目录:
/boot		存放系统引导必须的文件,包括内核,启动配置
/bin,/sbin	存放各种命令程序
/dev		存放硬盘,键盘,鼠标,光驱等各种设备文件
/etc		存放Linux系统及各种程序的配置文件
/root,/home	管理员root,普通用户的默认加目录
/var		存放日志文件,邮箱目录等经常变化的文件
/proc		存放内存中的映射数据,不占用磁盘
/tmp		存放系统运行过程中使用的一些临时文件

2.权限的数值表示
基本权限:
r=4,w=2,x=1
chmod ugo /路径/文档  
u或g或o=rwx=7
u或g或o=rw-=6
u或g或o=r-x=5
u或g或o=r--=4
u或g或o=-wx=3
u或g或o=-w-=2
u或g或o=--x=1
附加权限:
SUID=4,SGID=2,StickyBit=1
chmod _ugo /路径/文档    #先算出基本权限ugo分别是多少,再在_填写附加权限

3.历史命令
管理/调用曾经执行过的命令
查看历史命令列表:history
清空历史命令:history -c
执行最近一条以str开头的命令:!str
修改记录的历史命令数量:
vim /etc/profile
HISTSIZE=10  //默认记录1000条

4.统计文档占用磁盘空间大小:du 选项 /文档目录
常用选项:
-s只统计每个参数所占用的总空间大小
-h提供易读容量单位
#黄金组合:du -sh /文档目录

5.date查看/调整系统日期时间
date 查看日期及时间
date +%F 查看日期
date +%R 查看时间
date +'%Y-%m-%d %H:%M:%S'查看年月日时分秒
date -s 'yyyy-mm-dd HH:MM:SS'修改时间

6.制作快捷方式
创建软连接    
ln -s /路径/源文档 /路径/快捷方式名
软连接:快捷方式-->数据区域-->i节点-->源文档-->i节点-->数据区域:文档数据
#若源文档被删除,连接失效,软连接可存放在不同分区/文件系统
创建硬连接    
ln 源文件 /路径/快捷方式名
硬连接:快捷方式-->i节点-->数据区域:文档数据
#若源文件被删除,连接仍可用,硬连接与源文件必须在同一分区/文件系统
查看i节点
ls -i /路径/文档

7.man帮助手册
#man 5 passwd #5代表帮助类型,配置文件的帮助信息

8.zip归档工具:归档及压缩(跨平台:windows&Linux)
制作.zip压缩包
zip 选项 备份文件.zip 被归档的文档 
常用选项
-r归档目录时必须要用
释放.zip压缩包
unzip 备份文件.zip -d /释放路径


自定义Yum仓库
1.从互联网下载的软件包,将tools.tar.gz包传递到虚拟机A
scp /源文档 root@目标机器IP地址:/目标路径  #ssh+cp简单传输工具
[root@room1pc43 ~]# scp /root/桌面/tools.tar.gz root@192.168.4.7:/root/
root@192.168.4.7's password: 
tools.tar.gz                    100%  766KB  52.0MB/s   00:00    

2.虚拟机A将tools.tar.gz解压释放到系统根目录下
[root@svr7 ~]# tar -xf /root/tools.tar.gz -C /
[root@svr7 ~]# ls /
[root@svr7 ~]# ls /tools/
[root@svr7 ~]# ls /tools/other/
boxes-1.1.1-4.el7.x86_64.rpm        
cmatrix-1.2a-1.i386.rpm             
ntfs-3g-2014.2.15-6.el6.x86_64.rpm
oneko-1.2-19.fc24.x86_64.rpm
sl-5.02-1.el7.x86_64.rpm

3.产生仓库数据文件(仓库清单)
createrepo /软件包目录
[root@svr7 ~]# createrepo /tools/other/
[root@svr7 ~]# ls /tools/other/
[root@svr7 ~]# ls /tools/other/repodata/

4.为本机指定新的Yum仓库
vim /etc/yum.repos.d/xxxx.repo  
 [唯一标识id]
 name=描述信息
 baseurl=file:///软件包及仓库数据文件目录
 enabled=1
 gpgcheck=0
yum clean all
yum repolist
*补充命令:
rpm -ql 软件包名称  #查询软件包的安装清单
示例:
[root@svr7 ~]# vim /etc/yum.repos.d/rhel7.repo 
[rhel7]
name=rhel7.4
baseurl=ftp://192.168.4.254/rhel7
enabled=1
gpgcheck=0
[myrpm]
name=myrpm
baseurl=file:///tools/other
enabled=1
gpgcheck=0
[root@svr7 ~]# yum clean all 
[root@svr7 ~]# yum repolist 
[root@svr7 ~]# yum -y install cmatrix
[root@svr7 ~]# cmatrix
[root@svr7 ~]# rpm -ql cmatrix
[root@svr7 ~]# yum -y install sl
[root@svr7 ~]# sl
[root@svr7 ~]# yum -y install oneko
[root@svr7 ~]# oneko
[root@svr7 ~]# oneko &         #程序运行命令 &:程序后台运行
[root@svr7 ~]# killal oneko    #杀死所有oneko程序


源码编译安装

源码包优点:
获得软件的最新版,及时修复bug
软件功能可按需选择/定制,有更多软件可供选择
源码包适用于不同平台

        gcc,make
源码包-------------->可执行文件-------------->运行安装

step01:安装gcc,make工具软件包
       [root@svr7 ~]# yum -y install gcc make
       [root@svr7 ~]# rpm -q gcc
       [root@svr7 ~]# rpm -q make
step02:tar解包,释放源代码至指定目录
       [root@svr7 ~]# tar -xf /tools/inotify-tools-3.13.tar.gz -C /
       [root@svr7 ~]# cd /inotify-tools-3.13/
       [root@svr7 inotify-tools-3.13]# ls
step03:./configure配置
        作用1:检测系统是否安装gcc
        作用2:指定安装目录/功能模块等选项
        指定安装位置的选项:--prefix=/路径/目录  #只是记录安装路径,还未安装
        [root@svr7 inotify-tools-3.13]# 
        ./configure --prefix=/mnt/myrpm
step04:make编译,生成可执行的二进制程序文件
       [root@svr7 inotify-tools-3.13]# make
step05:make install安装,将编译好的文件复制到安装目录
       [root@svr7 inotify-tools-3.13]# make install
       [root@svr7 inotify-tools-3.13]# ls /mnt/


=================================================================================
			03.Services-day02
=================================================================================

DNS服务器

DNS服务器的功能
正向解析:根据注册的域名查找其对应的IP地址
反向解析:根据IP地址查找对应的注册域名(不常用)

DNS的分布式结构
大型,分布式的互联网DNS解析库
.                               ---->DNS根域服务器
.com .net .edu .cn .org		---->一级DNS服务器
.net.cn .edu.cn .com.cn		---->二级DNS服务器
.sina.com.cn .pku.edu.cn	---->三级DNS服务器                  
mail.qq.com  www.sina.com	---->完整合格的主机名FQDN
				(Full Qualified Domain Name)

所有的域名必须以.作为结尾
.:根域---->根域服务器


常见一级域名
国家/地区域:.cn .us .jp .kr .hk .tw
组织域:.com .net .edu .org .gov .mil
###############################################
DNS域名管理
互联网数字分配机构IANA
(Internet Assigned Numbers Authority)
整个域名系统最高权威机构
主管DNS根域,.int及.arpa等国际化域名资源
中国互联网络信息中心CNNIC
(China Internet Network Information Center)
主管国家顶级域.cn

域名代理/注册/购买服务商
新网:http://www.xinnet.com
万网:http://www.net.com
中国互联:http://www.hulian.com
###############################################


搭建基本的DNS服务器
I.单区域DNS服务
服务端:虚拟机A
1.安装软件包
[root@svr7 ~]# yum -y install bind            	#提供域名服务包
[root@svr7 ~]# yum -y install bind-chroot     	#提供安全

2.修改主配置文件:/etc/named.conf 		#设置本机负责解析的域名 
[root@svr7 ~]# cp /etc/named.conf  /root/
[root@svr7 ~]# vim /etc/named.conf 
删除其它所有留下:
   options {
           directory       "/var/named";
   };
   zone "." IN {
           type hint;
           file "named.ca";
   };    
再修改成:
   options {
           directory       "/var/named";	#指定地址库文件存放位置
   };
   zone "tedu.cn" IN {				#指定本机负责解析的域名
           type master;				#指定本机为权威服务器
           file "tedu.cn.zone";			#指定地址库文件名
   };

3.建立地址库文件:/var/named      		#记录域名与IP地址对应关系
[root@svr7 ~]# cd /var/named/
[root@svr7 named]# ls
named.localhost 
[root@svr7 named]# cp -p named.localhost tedu.cn.zone

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#cp -p:保留源文件权限及归属关系的拷贝
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

[root@svr7 named]# ls -l tedu.cn.zone 
[root@svr7 named]# vim tedu.cn.zone 
        NS      @
        A       127.0.0.1
        AAAA    ::1
-------------------------------------------------------->
tedu.cn. NS svr7	#svr7会自动识别为:svr7.tedu.cn
svr7     A  192.168.4.7 #指定DNS服务器IP地址,必要!
ftp      A  1.1.1.1	#其它域名解析
www      A  2.2.2.2	#其它域名解析

4.重启named服务
[root@svr7 named]# cd /
[root@svr7 /]# systemctl restart named

5.虚拟机B验证
[root@pc207 ~]# echo nameserver 192.168.4.7 > /etc/resolv.conf 
[root@pc207 ~]# nslookup svr7.tedu.cn
Server:		192.168.4.7
Address:	192.168.4.7#53
Name:	svr7.tedu.cn
Address: 192.168.4.7
[root@pc207 ~]# nslookup www.tedu.cn
Server:		192.168.4.7
Address:	192.168.4.7#53
Name:	www.tedu.cn
Address: 2.2.2.2
[root@pc207 ~]# nslookup ftp.tedu.cn
Server:		192.168.4.7
Address:	192.168.4.7#53
Name:	ftp.tedu.cn
Address: 1.1.1.1

II.多区域DNS服务
[root@svr7 ~]# vim /etc/named.conf 追加写入
  zone "qq.com" IN {
        type master;
        file "qq.com.zone";
  };
[root@svr7 /]# cd /var/named/
[root@svr7 named]# cp -p tedu.cn.zone qq.com.zone
[root@svr7 named]# vim qq.com.zone 
  qq.com.  NS svr7
  svr7     A  192.168.4.7
  www      A  3.3.3.3
  ftp      A  4.4.4.4
[root@svr7 named]# cd /
[root@svr7 /]# systemctl restart named
[root@pc207 ~]# nslookup www.qq.com
Server:		192.168.4.7
Address:	192.168.4.7#53
Name:	www.qq.com
Address: 3.3.3.3
[root@pc207 ~]# nslookup ftp.qq.com
Server:		192.168.4.7
Address:	192.168.4.7#53
Name:	ftp.qq.com
Address: 4.4.4.4


特殊的解析记录
1.*了解:DNS解析记录的轮询:基于DNS站点的负载均衡
www A 1.1.1.1
www A 2.2.2.2
www A 3.3.3.3
#同一域名,对应多个不同IP地址,nslookup解析域名会轮询式输出解析结果

2.泛域名解析
第一种:匹配本域内未定义的任何主机地址
[root@svr7 /]# vim /var/named/tedu.cn.zone 
*  A   1.2.3.4
第二种:
pc1.tedu.cn A 192.168.10.1
pc2.tedu.cn A 192.168.10.2
pc3.tedu.cn A 192.168.10.3    
...
pc50.tedu.cn A 192.168.10.50

------
------

$GENERATE 1-50 pc$.tedu.cn A 192.168.10.$
#############################
内置函数
$GENERATE 造出连续范围的数值
#############################

3.解析记录的别名
[root@svr7 /]# vim /var/named/tedu.cn.zone 追加写入
tts      CNAME    ftp     #格式:a域名 CNAME b域名,代表a域名匹配b域名的IP
[root@svr7 /]# systemctl restart named
[root@pc207 ~]# nslookup tts.tedu.cn
Server:		192.168.4.7
Address:	192.168.4.7#53
tts.tedu.cn	canonical name = ftp.tedu.cn.
Name:	ftp.tedu.cn
Address: 1.1.1.1


DNS子域授权

父域:www.qq.com
子域:www.bj.qq.com

虚拟机A负责解析:www.qq.com
虚拟机B负责解析:www.bj.qq.com

虚拟机B搭建DNS服务器
1.安装软件bind-chroot bind
2.修改配置文件
3.建立地址库文件
4.验证nslookup www.bj.qq.com 192.168.4.207

子域授权:在父域的DNS服务器上,指定子域服务器位置
虚拟机A:
[root@svr7 /]# vim /var/named/qq.com.zone 
qq.com.         NS      svr7
bj.qq.com.      NS      pc207
svr7            A       192.168.4.7
pc207           A       192.168.4.207
www             A       3.3.3.3
ftp             A       4.4.4.4
[root@svr7 /]# systemctl restart named
[root@pc207 ~]# nslookup www.bj.qq.com 192.168.4.7
Server:		192.168.4.7
Address:	192.168.4.7#53
Non-authoritative answer:        #非权威解答
Name:	www.bj.qq.com
Address: 10.11.12.13


递归解析:(主配置文件不设置则默认生效)
由客户端发起请求解析,首选DNS服务器与其它DNS服务交互,最终将答案带回来的过程

*是否允许递归解析
   options {
           directory       "/var/named";
	   recursion no;    #禁用递归解析
   };

迭代解析:首选DNS服务器与其它DNS服务器交互过程


DNS主机名映射文件/etc/hosts
作用:只为本机直接提供解析结果
[root@svr7 /]# vim /etc/hosts   追加写入
192.168.4.120 www.sina.com

用户解析域名优先级:
1./etc/hosts
2./etc/resolv.conf
3.寻找DNS服务器


缓存DNS服务器:缓存解析记录,加速解析过程

搭建方式
1.全局转发式缓存DNS服务器
2.根域迭代缓存DNS服务器(*不常用)

搭建缓存DNS服务器:真机上操作:
1.真机上搭建yum
[root@room1pc43 ~]# ls /iso/
CentOS-7-x86_64-DVD-1708.iso 
[root@room1pc43 ~]# mkdir /dvd
[root@room1pc43 ~]# mount /iso/CentOS-7-x86_64-DVD-1708.iso  /dvd
[root@room1pc43 ~]# mkdir /etc/yum.repos.d/repo
[root@room1pc43 ~]# mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/repo
[root@room1pc43 ~]# vim /etc/yum.repos.d/dvd.repo
[dvd]
name=CentOS7.4
baseurl=file:///dvd
enabled=1
gpgcheck=0
[root@room1pc43 ~]# yum repolist 
[root@room1pc43 ~]# yum -y install bind-chroot bind

2.构建缓存服务器
[root@room1pc43 ~]# cat /etc/resolv.conf 
# Generated by NetworkManager
search tedu.cn
nameserver 176.121.0.100

[root@room1pc43 ~]# cp /etc/named.conf /root/
  options {
        directory       "/var/named";
        forwarders {176.121.0.100;};   # 指定DNS服务器
  };
[root@svr7 /]# nslookup www.tedu.com 192.168.4.254
Server:		192.168.4.254
Address:	192.168.4.254#53
Non-authoritative answer:
Name:	www.tedu.com
Address: 103.232.215.131


=================================================================================
			03.Services-day03
=================================================================================

Split分离解析
客户机请求查询DNS时:根据客户机来源地址,不同类别客户机获得不同解析结果(IP地址)


配置分离解析
1.修改配置文件
[root@svr7 /]# vim /etc/named.conf
view "类别名1"{
  match-clients{来源IP地址1;来源IP地址2...;};
  zone"域名" IN{
      type master;
      file"地址库文件名1.zone";
 };
};
view "类别名2"{
  match-clients{来源IP地址3;来源IP地址4...;};
  zone"域名" IN{
      type master;
      file"地址库文件名2.zone";
 };
};

......

view "other"{
  match-clients{any;};
  zone"域名" IN{
      type master;
      file"地址库文件.other";
 };
};

2.修改地址库文件
[root@svr7 /]# cp -p /var/named/地址库文件名1.zone 
/var/named/地址库文件名2.other
[root@svr7 /]# vim /var/named/地址库文件名1.zone 
  域名     NS svr7
  svr7     A  192.168.4.7
  www      A  解析结果IP地址1
[root@svr7 /]# vim /var/named/地址库文件名2.other 
  tedu.cn. NS svr7
  svr7     A  192.168.4.7
  www      A  解析结果IP地址2

3.重启named服务
[root@svr7 /]# systemctl restart named
4.验证:
[root@pc207 ~]# nslookup www.tedu.cn 192.168.4.7
[root@room1pc43 ~]# nslookup www.tedu.cn 192.168.4.7

注意事项:
1.所有客户端都能找到自己的类别,分类要合理
2.优先级由上到下匹配,匹配即停止
3.定义view视图后,不允许在view以外出现zone配置

案例:
权威DNS:svr7.tedu.cn 192.168.4.7
负责区域:tedu.cn
A记录分离解析---->www.tedu.cn
客户机:                解析结果
192.168.4.207       192.168.4.100
其它地址	    1.2.3.4

[root@svr7 /]# vim /etc/named.conf 
   options {
        directory       "/var/named";
  };
  view "Chinese" {
     match-clients{192.168.4.207;};
     zone"tedu.cn"IN {
          type master;
          file"tedu.cn.zone";
    };
  };

  view "other" {
     match-clients{any;};
     zone"tedu.cn"IN {
          type master;
          file"tedu.cn.other";
    };
  };
[root@svr7 /]# cp -p /var/named/tedu.cn.zone /var/named/tedu.cn.other
[root@svr7 /]# vim /var/named/tedu.cn.zone 
  tedu.cn. NS svr7
  svr7     A  192.168.4.7
  www      A  192.168.4.100
[root@svr7 /]# vim /var/named/tedu.cn.other 
  tedu.cn. NS svr7
  svr7     A  192.168.4.7
  www      A  1.2.3.4
[root@svr7 /]# systemctl restart named
[root@pc207 ~]# nslookup www.tedu.cn
Server:		192.168.4.7
Address:	192.168.4.7#53
Name:	www.tedu.cn
Address: 192.168.4.100
[root@room1pc43 ~]# nslookup www.tedu.cn 192.168.4.7
Server:		192.168.4.7
Address:	192.168.4.7#53
Name:	www.tedu.cn
Address: 1.2.3.4

acl地址列表
在来源IP地址中直接指定列表名即可调用acl地址列表,当列表为any时可匹配任意地址
acl"地址列表名称1"{
IP地址1;IP地址2;...;
 网段1 ; 网段2 ;...;
};
acl"地址列表名称2"{
IP地址3;IP地址4;...;
 网段3 ; 网段4 ;...;
};

多区域分离解析
注意事项:
1.每一个view中,zone的个数要一致
2.每一个view中,zone的区域要一致


RAID(Redundant Arrays of Inexpensive Disks)磁盘阵列:廉价冗余磁盘阵列
通过硬件(阵列卡)/软件技术,将多个较小/低速的磁盘整合成一个大的磁盘
硬RAID:由RAID控制卡管理阵列:主板-->阵列卡-->磁盘-->操作系统-->数据
软RAID;由操作系统来管理阵列:主板-->磁盘-->操作系统-->RAID软件-->数据
作用:提升I/O效率,硬件级别的数据冗余


不同RAID级别的功能,特性各不相同
RAID0:条带模式
同一文档分散存放在不同磁盘
并行写入以提高效率

RAID1:镜像模式
一个文档复制成多份,分别写入不同的磁盘
多份拷贝提高可靠性,效率无提升

RAID5:高性价比模式
相当于结合RAID0和RAID1
需要至少一块磁盘的容量来存放校验数据,进行奇偶校验

RAID6:高性价比/可靠模式
相当于扩展的RAID5阵列,提供2份独立校验方案
需要至少两块磁盘的容量来存放校验数据

RAID1+0(RAID0+1)
整合RAID0,RAID1的优势
并行存取提高效率,镜像写入提高可靠性


进程管理

程序:静态的代码,仅占用磁盘存储
进程:动态的代码,占用CPU与内存

进程唯一标识:PID
树型结构:父进程--子进程

查看进程数(Processes Tree)
查看所有进程:pstree
格式:pstree 选项 (PID或用户名)
常用命令选项:
-a:显示完整的进程信息
-p:列出对应PID编号

查看进程快照(Processes Snapshot)
格式:ps 选项
常用命令选项:
aux:显示当前终端所有进程(a),当前用户在所有终端下的进程(x),以用户格式输出(u)
-elf: 显示系统内所有进程(-e),以长格式输出信息(-l),包括最完整的进程信息(-f)

*补充命令:统计命令:wc /路径/文档
常用选项
-l:统计有多少行

进程动态排名
top交互式工具
格式:top -d(刷新秒数) -u(用户名)
交互命令:
按P(按CPU进行排序)
按M(按内存进行排序)
按q(退出)

检索进程(Process Grep)
pgrep 选项 查询条件
常用选项:
-l:输出进程名,而不仅仅是PID
-U:检索指定用户的进程
-t:检索指定终端的进程(who查看正在运行的终端)
-x:精确匹配完整的进程名(精确匹配查询条件)

控制进程:进程的前后台调度
前台启动:输入正常命令行,运行期间占用当前终端
后台启动:在命令行末尾添加"&"符号,不占用当前终端

*sleep n    #n为数值,睡眠n秒,常用于脚本

[root@svr7 /]# sleep 1000 &			#运行进程并放入后台
[root@svr7 /]# jobs				#查看后台进程信息
[1]+  运行中               sleep 1000 &
[root@svr7 /]# sleep 800			
^Z						#按Ctrl+Z暂停放入后台
[2]+  已停止               sleep 800		
[root@svr7 /]# jobs
[1]-  运行中               sleep 1000 &
[2]+  已停止               sleep 800
[root@svr7 /]# bg 2				#将后台编号为2的继续运行
[2]+ sleep 800 &
[root@svr7 /]# fg 2				#将后台编号为2的放入前台
sleep 800
^C						#中断当前命令程序

杀死进程
干掉进程的不同办法
Ctrl+c 组合键,中断当前命令程序
kill -9 PID			#-9代表强制杀
kall -9 进程名...		#不加-9为非强制杀
pkill 查找条件

杀死一个用户所有的进程(强制踢出一个用户)
killall -9 -u 用户名


日志管理
记录系统,程序运行中发生的各种事件
通过查看日志,了解及排除故障
信息安全控制的依据

内核及系统日志
由系统服务rsyslog统一记录管理
日志消息采用文本格式
主要记录事件发生的时间,主机,进程,内容

常见的日志文件
日志文件			主要用途
/var/log/messages		记录内核消息,各种服务的公共消息
/var/log/demesg			记录系统启动过程的各种消息
/var/log/cron			记录与cron计划任务相关的信息
/var/log/maillog		记录邮件收发相关的消息
/var/log/secure			记录与访问限制相关的安全消息

日志分析
查看文本日志消息
通用分析工具:
文本浏览/检索命令tail,tailf(实时跟踪日志消息),less,grep
格式化过滤工具awk,sed
专用分析工具:
系统管理套件Webmin
日志统计套件Webalizer,AWStats

用户登录分析
命令:users,who,w 查看已登录的用户信息(w最详细,user最简略,who最常用)
命令:last/lastb 查看最近登录成功/失败的用户信息

日志消息的优先级
Linux内核定义的事件经济成都
分为0-7共8种优先级-->数值越小,表示对应事件越紧急重要
0 EMERG   (紧急) 会导致主机系统不可用的情况
1 ALERT   (警告) 必须马上采取措施处理
2 CRIT    (严重) 遇到以外
3 ERR     (错误) 
4 WARNING (提醒)
5 NOTICE  (注意)
6 INFO    (信息)
7 DEBUG   (调试)

使用journalctl工具
提取由systemd-journal服务搜集的日志
主要包括内核/系统日志,服务日志
常见用法:
journalctl | grep 关键词
journalctl -u 服务名 [-p 优先级]
journalctl -n 消息条数
journalctl --since="yyyy-mm-dd HH:MM:SS" --until="yyyy-mm-dd HH:MM:SS"


systemd:内核引导之后加载的第一个初始化进程(PID=1)
	负责掌控整个Linux的运行/服务资源整合
配置目录:/etc/systemd/system
服务目录:/lib/systemd/system
管理工具:systemctl

管理服务
开启服务: 	  	systemctl start   服务名
关闭服务:    		systemctl stop    服务名
重启服务:    		systemctl restart 服务名
查看服务状态:		systemctl status  服务名
设置服务开机自启: 	systemctl enable  服务名
设置服务禁止开机自启动: 	systemctl disable 服务名


运行级别
RHEL6:运行级别
0:关机
1:单用户模式(修复模式/破解密码模式)
2:字符界面(不支持网络)
3:字符界面(支持网络)
4:未定义
5:图形界面
6:重启
切换运行级别的命令:init 运行级别

RHEL7:运行模式
graphical.target:图形模式
multi-user.target:字符模式
切换运行模式:
systemctl isolate 运行模式	#临时切换运行模式
systemctl get-default		#查看默认运行模式
systemctl set-default 运行模式	#修改永久的默认运行模式


=================================================================================
			03.Services-day04
=================================================================================

部署DHCP服务器

DHCP(Dyamic Host Configuration Protocol)服务器:动态主机配置协议
用来简化主机地址分配管理

DHCP地址分配的四次会话(广播进行,先到先得)
DISCOVERY-->OFFER-->REQUEST-->ACK

注意:在一个网络中,只能有一个DHCP服务器

搭建DHCP服务器
1.安装软件包dhcp
[root@svr7 ~]# yum -y install dhcp

2.修改主配置文件/etc/dhcp/dhcpd.conf
光标移动到最后一行
末行模式:r /usr/share/doc/dhcp*/dhcpd.conf.example
删除其它,保留:
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
#
subnet 10.5.5.0 netmask 255.255.255.224 {
  range 10.5.5.26 10.5.5.30;
  option domain-name-servers ns1.internal.example.org;
  option domain-name "internal.example.org";
  option routers 10.5.5.1;
  option broadcast-address 10.5.5.31;
  default-lease-time 600;
  max-lease-time 7200;
}
再修改成:
---------------------------------------------->
#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
#
subnet 192.168.4.0 netmask 255.255.255.0 {		#分配网段
  range 192.168.4.100 192.168.4.200;			#分配IP地址范围
  option domain-name-servers 192.168.4.7;		#分配DNS服务器
  option routers 192.168.4.254;				#分配网关地址
  default-lease-time 600;
  max-lease-time 7200;
}

3.重启dhcpd服务
[root@svr7 ~]# systemctl restart dhcpd


PXE网络装机

优点:
规模化:同时装配多台主机
自动化:装系统,配置各种服务
远程实现:不需要光盘,U盘等物理安装介质

PXE(Pre-boot eXecution Environment)预启动执行环境:在操作系统之前运行
作用:可用于远程安装
工作模式:
PXE client集成在网卡的启动芯片中
当计算机引导时,从网卡芯片中把PXEclient调入内存执行,
获取PXEserver配置,显示菜单,
根据用户选择将远程引导程序下载到本机运行

服务组件:
DHCP服务:分配IP地址,定位引导程序
TFTP服务:提供引导程序下载
HTTP服务(或FTP/NFS):提供yum安装源

客户机具备条件:
网卡芯片必须支持PXE协议
主板支持从网卡启动

1.DHCP服务器,指定PXE网络装机配置
[root@svr7 ~]# vim /etc/dhcp/dhcpd.conf 
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100 192.168.4.200;
  option domain-name-servers 192.168.4.7;
  option routers 192.168.4.254;
  default-lease-time 600;
  max-lease-time 7200;
  next-server 192.168.4.7;		#指定下一个服务器IP地址
  filename "pxelinux.0";		#指定网卡引导文件名称
}
[root@svr7 ~]# systemctl restart dhcpd	#重启dhcpd服务
#pxelinux.0:网卡引导文件(网络装机说明书),二进制文件,安装一个软件可以自动生成

2.搭建tftp服务:默认共享路径:/var/lib/tftpboot

(1)安装软件tftp-server
[root@svr7 ~]# yum -y install tftp-server

(2)重启服务tftp
[root@svr7 ~]# systemctl restart tftp

(3)部署pxelinux.0文件
#####################################################
查询仓库中哪个包产生该文件
yum provides /路径/文件名   

yum provides */文件名     #当未知文件路径时可用通佩服
#####################################################
[root@svr7 ~]# yum provides */pxelinux.0
  syslinux-4.05-13.el7.x86_64
  /usr/share/syslinux/pxelinux.0
[root@svr7 ~]# yum -y install syslinux
[root@svr7 ~]# rpm -ql syslinux | grep pxelinux.0
/usr/share/syslinux/pxelinux.0
[root@svr7 ~]# cp /usr/share/syslinux//pxelinux.0  /var/lib/tftpboot/

(4)部署菜单文件
pxelinux.0规定菜单文件目录及文件名:/var/lib/tftpboot/pxelinux.cfg/default

先把光盘放到光驱设备中

[root@svr7 ~]# mount /dev/cdrom /mnt/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /mnt/

[root@svr7 ~]# mkdir /var/lib/tftpboot/pxelinux.cfg

[root@svr7 ~]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

[root@svr7 ~]# ls -l /var/lib/tftpboot/pxelinux.cfg/default 
-r--r--r--. 1 root root 3166 /var/lib/tftpboot/pxelinux.cfg/default

[root@svr7 ~]# chmod u+w /var/lib/tftpboot/pxelinux.cfg/default 

[root@svr7 ~]# ls -l /var/lib/tftpboot/pxelinux.cfg/default
-rw-r--r--. 1 root root 3166 /var/lib/tftpboot/pxelinux.cfg/default

(5)部署菜单图形模块和背景图片
[root@svr7 ~]# cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png  /var/lib/tftpboot/
[root@svr7 ~]# ls /var/lib/tftpboot/
pxelinux.0  pxelinux.cfg  splash.png  vesamenu.c32

(6)部署启动内核与驱动程序
[root@svr7 ~]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img /var/lib/tftpboot/
[root@svr7 ~]# ls /var/lib/tftpboot/
initrd.img  pxelinux.0  pxelinux.cfg  
splash.png  vesamenu.c32  vmlinuz

(7)修改菜单文件
[root@svr7 ~]# vim /var/lib/tftpboot/pxelinux.cfg/default 
 11 menu title NSD1807 PXE Server!
 删除一部分:
 65 ESC命令模式100dd
 再修改:
 61 label linux
 62   menu label Install RHEL7  
 63   menu default
 64   kernel vmlinuz
 65   append initrd=initrd.img 

小结:
1.DHCP-->IP地址,next-server,filename"pxelinux.0"
2.tftp-->pxelinux.0    
3.pxelinux.0-->/var/lib/tftpboot/pxelinux.cfg/default
4.default-->vesamenu.c32,slash.png,vmlinuz,initrd.img


初步验证:
新建一个虚拟机,系统安装方式选择pxe网络引导安装
网络类型选择:private1

3.搭建web服务,共享光盘内容
(1)安装软件包httpd, 重启httpd服务
[root@svr7 ~]# systemctl restart httpd
(2)挂载光盘内容到web默认网页文件根目录下新建目录rhel7
[root@svr7 ~]# mkdir /var/www/html/rhel7
[root@svr7 ~]# mount /dev/cdrom /var/www/html/rhel7/
[root@svr7 ~]# firefox  192.168.4.7/rhel7

4.无人值守安装:生成应答文件
(1).安装辅助图形工具
[root@svr7 ~]# yum -y install system-config-kickstart

(2)运行图形工具
########################################################
应对bug:软件包选择:由于下载软件包信息失败,软件包选择被选择

修改Yum客户端配置文件标识:[development]
########################################################
[root@svr7 ~]# system-config-kickstart 
基本配置
-语言键盘时区自行设置(中文->U.S.English->Asia/Shanghai)
-[*]使用UTC时钟
-设置密码
-确认密码
-[*]安装后重启
-[*]/[ ]在文本模式执行安装(默认为图形化模式)
安装方法
-执行全新安装
-HTTP
-HTTP服务器:192.168.4.7
-HTTP目录:rhel7
引导装载程序选项
-[*]安装新引导装载程序
分区信息
-[*]清除主引导记录
-[*]删除所有现存分区
-[*]初始化磁盘标签
-添加
-挂载点:/
-[*]使用磁盘上全部未用空间
-确定
网络配置
-添加网络设备
-网络设备:eth0
-确定
验证
-(默认,不作修改)
防火墙配置
-SElinux:禁用
显示配置
-(默认,不作修改)
软家包选择
-系统-[*]基本
预安装脚本
-(默认,不作修改)
安装后脚本
-[*]使用解释程序:/bin/bash
-在下面键入您的%post脚本:
 useradd student
 echo 123456 | passwd --stdin student
(左上角)文件
-保存
-位置:root
-保存
[root@svr7 ~]# ls /root/ks.cfg 
[root@svr7 ~]# vim /root/ks.cfg 

(3)利用Web服务,共享应答文件
[root@svr7 ~]# cp /root/ks.cfg /var/www/html/
[root@svr7 ~]# ls /var/www/html/

(4)修改菜单文件,指定ks.cfg应答文件
[root@svr7 ~]# vim /var/lib/tftpboot/pxelinux.cfg/default 
label linux
  menu label Install RHEL7
  menu default
  kernel vmlinuz
  append initrd=initrd.img ks=http://192.168.4.7/ks.cfg

总结:
1.DHCP-->IP地址,next-server,filename"pxelinux.0"
2.tftp-->pxelinux.0    
3.pxelinux.0-->/var/lib/tftpboot/pxelinux.cfg/default
4.default-->vesamenu.c32,slash.png,vmlinuz,initrd.img-->ks.cfg
5.ks.cfg-->时区,键盘,分区...-->url="http://192.168.4.7/rhel7"


=================================================================================
			03.Services-day05
=================================================================================

rsync同步操作
格式:
rsync 选项 /源目录   /目标目录	#同步整个目录
rsync 选项 /源目录/  /目标目录	#仅同步目录下所有内容,不同步目录本身


同步与复制的差异
复制:完全拷贝源到目标
同步:增量拷贝,只传输变化过的数据

rsync选项:
-n:测试同步过程,不做实际修改
--delete:删除目标文件夹内多余的文档
-a:归档模式
-v:显示详细操作信息
-z:传输过程中启用压缩/解压

[root@svr7 ~]# ls /test01/
10.txt  1.txt  a.txt  fstab  passwd
[root@svr7 ~]# ls /stu01/
1.txt  fstab  passwd
[root@svr7 ~]# rsync --delete -avz /stu01/ /test01/
sending incremental file list
./
deleting a.txt
deleting 10.txt
sent 72 bytes  received 15 bytes  174.00 bytes/sec
total size is 2666  speedup is 30.64

rsync+SSH同步(远程同步)
与远程的SSH目录保持同步
下行:rsync 选项 user@host:远程目录 本地目录
上行:rsync 选项 本地目录 user@host:远程目录
[root@svr7 ~]# rsync --delete -avz /opt/ root@192.168.4.207:/opt/

实时同步
I.采用公钥与私钥,实现无密码认证
虚拟机A:
1.生成公钥和私钥
[root@svr7 ~]# ssh-keygen 
Generating public/private rsa key pair.		#rsa是一种加密算法
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase):	#一直敲回车
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:5b4K0QF7mOVrdK3NypU76l8gYtOX28xSpqo544+yiwM root@svr7.tedu.cn
The key's randomart image is:
+---[RSA 2048]----+
|      . .        |
|       B   .     |
|      + = o .    |
|       + B + o   |
|      . S = O o  |
|  E    + = = @   |
|   .  .   + * =  |
|    ....oo + +   |
|    ..o=*B*..    |
+----[SHA256]-----+
2.查看生成的公钥和私钥
[root@svr7 ~]# ls /root/.ssh/
id_rsa			#私钥  
id_rsa.pub		#公钥   
known_hosts		#记录远程管理过的机器
3.复制公钥到远程主机
[root@svr7 ~]# ssh-copy-id root@192.168.4.207

虚拟机B:
[root@pc207 ~]# ls /root/.ssh/
authorized_keys		#传递过来的公钥

II.监控目录内容的变化
1.安装源码包inotify-tools工具
[root@svr7 ~]# ls /tools/	#确认源码包
inotify-tools-3.13.tar.gz other
2.安装gcc与make工具
[root@svr7 ~]# yum -y install gcc make
3.解包
[root@svr7 ~]# tar -xf /tools/inotify-tools-3.13.tar.gz -C /
[root@svr7 ~]# ls /
4编译安装inotifywait
[root@svr7 ~]# cd /inotify-tools-3.13/  
[root@svr7 ~]# ./configure 			#进行配置
[root@svr7 ~]# make				#编译
[root@svr7 ~]# make install			#编译安装
[root@svr7 ~]# ls /usr/local/bin/inotifywait	#确认程序文件

inotifywait 选项 /被监控目录
常用选项
-m:持续监控(捕获一个事件后不退出)
-r:递归监控,包括子目录及文件
-q:减少屏幕输出信息
-qq:零输出
-e [modify,create,delete,attirb]:		#可选则要监控的事件类别
指定监控odify,create,delete,attirb(权限)事件类别


[root@svr7 /]# 
                          新开终端
                       touch /opt/1.txt
inotifywait -mrq /opt/------------------>inotifywait -mrq /opt/
					  /opt/ CREATE aaa.txt
                                          /opt/ OPEN aaa.txt
                                          /opt/ ATTRIB aaa.txt
                                       /opt/ CLOSE_WRITE,CLOSE aaa.txt
##################################################
当程序无法运行时,清空编译重新安装
# cd /inotify-tools-3.13/
# make clean all    #清空编译
# make
# make install
##################################################

III.书写同步的脚本:
结合rsync与inotifywait
inotifywait -rq /opt
rsync --delete -avz /opt/ root@192.168.4.207:/opt/
while循环体系,适合死循环
     while [条件判断]/命令	#判断命令成功运行并退出则执行循环
     do 
	循环执行的语句
     done

[root@svr7 /]# vim /root/rsync.sh
  while inotifywait -rqq /opt 
  do
    rsync --delete -az /opt/ root@192.168.4.207:/opt/ 
  done &				#&代表后台运行
[root@svr7 /]# chmod +x /root/rsync.sh 
[root@svr7 /]# /root/rsync.sh 
[root@svr7 /]# pgrep -l rsync.sh	#查询脚本进程信息
[root@svr7 /]# killall rsync.sh		#杀死进程


Cobbler装机平台,不同版本的多系统的安装
I.安装一个CentOS虚拟机

真机上操作
[root@room1pc43 /]# ls /iso/
CentOS-7-x86_64-DVD-1708.iso

虚拟机要求:
1.硬盘大小50G
2.网络类型private1
3.软件包选择"带GUI的服务器"
4.分区选择"自动分区"
5.配置IP地址:192.168.4.168
6.将CentOS放入光驱设备,搭建本地Yum仓库
7.配置主机名:Cobbler.tedu.cn

II.虚拟机设置
1.设置防火墙为trusted
[root@Cobbler ~]# firewall-cmd --set-default-zone=trusted 

2.当前及永久设置SELinux状态未permissive
[root@Cobbler ~]# setenforce 0
[root@Cobbler ~]# getenforce 
Permissive
[root@Cobbler ~]# vim /etc/selinux/config 
SELINUX=permissive

III.利用scp真机传递Cobbler.zip包到虚拟机192.168.4.168
[root@pc43 ~]# scp /root/Desktop/Cobbler.zip root@192.168.4.168:/root/

IV.搭建Cobbler装机平台
Cobbler概述软件,管理dhcp,tftp,Web服务
自由的导入镜像与ks应答文件

解压Cobbler.zip包
[root@Cobbler ~]# unzip /root/Cobbler.zip -d /
[root@Cobbler ~]# unzip /Cobbler/cobbler.zip -d /opt/

V.安装cobbler主程序,工具包等
[root@Cobbler ~]# yum -y install /opt/cobbler/*.rpm


Cobbler网络装机部署

1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  tftp-server 

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务

2.配置cobbler:/etc/cobbler/settings
[root@Cobbler ~]# vim /etc/cobbler/settings #!!注意字段:后的空格不要删除

next_server: 192.168.4.168	#设置下一个服务器还为本机
server: 192.168.4.168		#设置本机未cobbler
manage_dhcp: 1			#设置cobbler管理dhcp服务
pxe_just_once: 1		#防止客户端重复安装操作系统

开机启动优先级:匹配即停止
(1).硬盘启动
(2).光驱设备
(3).U盘
(4).网络引导

3.配置cobbler的dhcp
[root@Cobbler ~]# vim /etc/cobbler/dhcp.template 
末行模式下:%s /192.168.1/192.168.4/g	#全文替换

4.绝对路径解压cobbler_boot.tar.gz
[root@Cobbler ~]# tar -xPf /Cobbler/cobbler_boot.tar.gz #-P:绝对路径释放

5.启动相关服务
[root@Cobbler ~]# systemctl restart cobblerd httpd tftp rsyncd
[root@Cobbler ~]# systemctl enable cobblerd httpd tftp rsyncd

6.同步刷新cobbler配置
[root@Cobbler ~]# cobbler sync
...
*** TASK COMPLETE ***

*了解内容:网页图形界面cobbler配置工具
[root@Cobbler ~]# firefox https://192.168.4.168/cobbler_web
高级-->添加例外-->确认安全例外-->用户名:cobbler密码:cobbler


cobbler应用

导入安装镜像数据
cobbler import --path=挂载点 --name=
[root@Cobbler ~]# cobbler import --path=/dvd --name=CentOS7
[root@Cobbler ~]# mount /dev/cdrom  /dvd
[root@Cobbler ~]# ls /dvd/

*cobbler导入的镜像放在：/var/www/cobbler/ks_mirror
*CentOS系统要求内存至少2G
 RedHat系统要求内存至少1G

查看
[root@cobbler ~]# cobbler list	#查看有哪些系统
distros:
   CentOS7-x86_64		#安装客户端至少2G内存
profiles:
   CentOS7-x86_64

删除
# cobbler list 
# cobbler profile remove --name=CentOS7-x86_64	#删除菜单信息
# cobbler distro remove --name=CentOS7-x86_64	#删除镜像信息

切换
# umount /dvd/
# mount /dev/cdrom  /dvd   			#将光盘换成RHEL7
# ls /dvd/

安装完成机器 默认root  密码:cobbler

自定义应答文件：开头注释行删除

[root@cobbler ~]# system-config-kickstart  #生成ks文件

必须默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7.4-A  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置


=================================================================================
		         04.Network-day01
=================================================================================


#计算机网络概述
计算机网络
硬件:通过线缆将网络设备和计算机连接起来
软件:操作系统,应用软件,应用程序通过通信线路互连实现资源共享、信息传递

计算机网络的功能
数据通信
资源共享
增加可靠性
提高系统处理能力

计算机网络发展阶段
分组交换-->TCP/IP-->Web技术

网络标准
标准化组织
ISO:国际标准化组织

其它标准化组织
 IEEE:电气和电子工程师学会
*ANSI:美国国家标准化局
*ITU-T:国际电信联盟-电信标准部

WAN与LAN
广域网WAN:Wide-Area  Network
局域网LAN:Local-Area Nstwork


#网络设备及拓扑

网络设备生产厂商:Cisco,Huawei
路由交换设备:路由器,交换机

网络拓扑结构:线缆连接计算机和网络设备的布局:
1.点对点拓扑结构
两台设备之间有一条单独的连接
专用的广域网WAN中电路连接的两台路由器
2.星型拓扑(星型扩展)	#普通主流拓扑结构
优点:				缺点:
易于实现			中心节点压力大
易于网络扩展			组网成本较高	
易于故障排查
3.网状拓扑结构		#核心网络拓扑结构
优点:				缺点:
一个节点与其它多个节点相连	组网成本高
提供冗余性和容错性
可靠性高


#OSI参考模型(由ISO制定的标准):开放系统互连参考模型OSI

OSI协议分层:为了降低网络设计的复杂性，将协议进行了分层设计

OSI协议模型七层框架

 应用层：网络服务与最终用户的一个接口
*表示层：数据的表现形式,如加密,压缩
*会话层：建立,管理,中止会话,例如断点续传
!传输层：定义传输数据的协议端口号,以及流控和差错校验
!网络层：进行逻辑地址寻址,实现不同网络之间的通信
!数据链路层：建立逻辑连接,进行硬件地址寻址,差错校验等功能
 物理层：建立,维护,断开物理连接


#TCP/IP模型
*协议:描述网络通信中"语言"规范的一组规则就是协议

TCP/IP五层模型
物理层-->数据链路层-->网络层-->传输层-->应用层

··································
应用层				HTTP HTTPS FTP DNS	    
				TFTP SMTP SNMP(网络管理协议)  
··································
传输层				TCP UDP
··································
网络层				ICMP,IGMP,IP,ARP 	
				#ping工具基于ICMP协议
··································
数据链路层			由底层网络
物理层				定义的协议
··································

PDU:协议数据单元	
网络层次:	传输数据结构:			数据单位:
应用层		上层数据			
传输层		TCP头部+上层数据			数据段segment
网络层		IP头部+TCP头部+上层数据		数据包packet
数据链路层	MAC头部+IP头部+TCP头部+上层数据 	数据帧frame
物理层		01010101010101010101		比特流bit

相应层次的设备
应用层		计算机
传输层		防火墙
网络层		路由器
数据链路层	交换机
物理层		网卡


#物理层
以太网接口:
1.RJ:描述公用电信网络的接口:RJ-45:网线水晶头/RJ-11:电话线水晶头
2.光纤接口:FC,ST,SC/LC:窄体方形光纤接头(目前主流)/MT-RJ 

双绞线:
1.屏蔽双绞线STP:线外包裹一层金属网膜，用于电磁环境非常复杂的工业环境中
2.非屏蔽双绞线UTP

双绞线标准与分类:
Cat5 :五类双绞线,适用于100Mbps的网络
Cat5e:超五类双绞线,衰减更小,适用于100Mbps的网络.串扰更少,性能优于5类线
Cat6 :适用于1000Mbps的网络
Cat7 :适用于10000Mbps的网络
*Mb=Mbit兆比特  MB=MByte兆字节  1Byte=8bit

双绞线的连接规范
1.线序:
T568A：白绿、绿、白橙、蓝、白蓝、橙、白棕、棕
T568B：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕 
2.线缆的连接:
(1)标准网线(直连线或直通线)：用于连接不同设备（A-A，B-B）
(2)交叉网线：用于连接相同设备(A-B)
*遵循与交换机相连的线缆用直通线,其它均用交叉线即可满足要求
*版本较新设备可以随意使用标准与交叉网线而不受限制，设备本身具备自动识别功能
(3)全反线:不用于以太网的连接,用于计算机串口和路由器或交换机的console
(控制台接口)相连进行初次设置


#物理层设备
1.网络接口卡:
连接计算机和网络硬件
有一个唯一的网络节点地址
按照速率可分为10/100M,100M/1000M自适应网卡
按照扩展类型可分为USB网卡,PCI网卡
按照提供的线缆接口类型可分为RJ-45接口网卡,光纤网卡
2.中继器:
放大信号
延长网络传输距离


#Packet Tracer软件
是由Cisco公司发布的一个辅助学习工具,为学习思科网络课程的初学者去设计、配置、
排除网络故障提供了网络模拟环境


#交换机命令行模式

交换机的工作模式：
用户模式
Switch>

特权模式:一般用于查看配置信息
Switch>enable 
Switch#

全局配置模式:所做的配置对整个设备生效
Switch#configure  terminal 
Switch(config)#全局配置模式

接口模式:
Switch(config)#interface fastEthernet 0/1
Switch(config-if)#
–interface:关键字
–fastethernet:接口类型
–0/1:0表示模块号,1表示端口号

exit返回上一模式
end/CTRL+Z直接退到特权模式
命令输入错误被卡住时同时按键盘ctrl+shift+6这三个按键


#交换机命令配置
常用命令：
Switch(config)#hostname SW01	#修改主机名为SW01
Switch#show  running-config	#查看配置信息

配置enable特权模式明文口令
全局配置模式：enable  password  123

保存交换机的配置
特权： write 或 copy  running-config  startup-config

恢复设备出厂默认值
特权：erase  startup-config
重启：reload

设备配置的准备工作

1.禁用DNS查询
switch(config)#no ip domain-lookup

2.配置输出日志同步:防止被日志信息打断命令输入
Switch(config)#line console 0
Switch(config-line)#logging synchronous

3.设置空闲一段时间后，重回初始界面的问题(自动锁屏)
switch(config)#line con 0
switch(config-line)#exec-timeout a b  #a分b秒锁屏,0 0代表不锁屏

=================================================================================
		      04.Network-day02
=================================================================================

#数据链路层
MAC地址:用来识别一个以太网上的某个单独的设备或一组设备

长度48位(6个字节),前24位代表厂商,后24位代表网卡编号
第8位为0时表示该MAC地址为单播地址,为1时表示组播地址,48位都为1表示广播地址
*一块物理网卡的地址一定是一个单播地址，也就是第8位一定为0

单播地址:一对一
组播地址:一对多
广播地址:一对所有

数据链路层的帧格式

 目的地址DA   +  源地址SA  + 类型/长度Type  + 数据DATA  +  帧校验序列CRC
|<-6字节->|   |<-6字节->|   |<-2字节->| |<-46-1500字节->| |<-4字节->|


#以太网交换机
1.交换机:交换机是用来连接局域网的主要设备，可以实现数据帧的转发

2.交换机的工作原理:
学习(源MAC地址)
广播
转发
更新(MAC地址表记录300秒老化,端口设备更换或重新连接更新MAC地址表)

3.广播域:指接收同样广播消息的节点的集合，交换机的所有端口默认属于同一个广播域

4.交换机的基本配置

5.常用命令
查看MAC地址表
特权：show mac-address-table

6.广播域
广播域指接收同样广播消息的节点的集合，交换机的所有端口默认属于同一个广播域


#VLAN(Virtual LAN):虚拟局域网:通过软件技术,在一台交换机中,实现多个局域网

1.VLAN的优势
广播控制，增强安全性，提高带宽利用率，降低延迟

2.创建VLAN的方法
在全局配置模式中：vlan  2		#创建vlan2,交换机默认存在vlan1
		Name  名字	#给vlan2命名
删除已创建的VLAN no vlan 2


3.端口加入vlan
进入接口模式(将要加入vlan的接口)
Switch(config)#interface fastEthernet 0/1
然后输入
switchport  access  vlan   3

4.同时将多个接口加入vlan 2
全局： interface  range  f0/1 – 10
switchport  access  vlan  2

5.查看vlan的摘要信息
特权：show  vlan  brief
特权：show　vlan　id　20		#只查看vlan20的信息


#Trunk原理

access 接入链路 承接一个vlan
trunk  中继链路 承接多个vlan    #只能用于连接两台交换机的接口

VLAN标识的种类(接口封装类型)
以太网上实现中级可用两种封装类型
IEEE802.1Q：共有协议	    #主流：IEEE802.1Q
ISL	  ：Cisco私有协议 

IEEE802.1Q:
DA+SA+Type+Data+CRC --> DA+SA+Tag+Type+Data+CRC

trunk的配置
接口模式：switchport  mode  trunk(配置为中继链路)

查看接口模式（默认为：dynamic auto动态自动模式）
特权模式：show  interface  f0/5  switchport

dynamic auto动态自动模式
A交换机		B交换机		结果
dynamic auto	dynamic auto	access
trunk		dynamic auto	trunk
dynamic	auto	trunk		trunk
access		dynamic auto	access
dynamic auto	access		access

恢复接口默认模式
Switch(config-if)#no switchport mode trunk


#EthernetChannel：以太通道
功能：多条线路负载均衡，带宽提高
     容错，当一条线路失效时，其他线路通信，不会丢包

以太网通道的配置：
全局配置模式：
interface range f0/7-8 
switchport mode trunk 
channel-group 1 mode on

查看以太网通道的配置：
show etherchannel summary

以太通道配置原则：
1.参与捆绑的端口必须属于同一个vlan
2.如果端口配置的是中继模式，那么链路的两端通道中的所有端口都配置成中继模式

*
断开接口的命令
进入接口模式：shutdown

打开接口的命令
进入接口模式：no shutdown


=================================================================================
		     04.Network-day03
=================================================================================

#网络层

网络层功能:
定义了基于IP协议的逻辑地址
连接不同的媒介类型
连接数据通过网络的最佳路径

IP地址最后一位不可用0/255:
xxx.xxx.xx.0	网络ID
xxx.xxx.xx.255	广播地址

路由器:将数据包从一个网络发送到另一个网络

路由表:路由器根据路由表做路径选择

静态路由

特点
1.由管理员手工配置,是单向的
2.通信双方的边缘路由器都需要指定,否则会导致数据包有去无回
3.缺乏灵活性，适用于小型网络
配置
全局模式：
ip  route  目标网络ID  子网掩码  下一跳IP

查看路由表
特权：show  ip  route
C直连路由
S静态路由:静态手工配置
S*默认路由

缺省路由（默认路由）
缺省路由是一种特殊的静态路由
缺省路由就是在没有找到任何匹配的具体路由条目的情况下才使用的路由，适用于只有一个出口的末节网络（比如企业的网关出口）

全局:ip route 0.0.0.0 0.0.0.0 下一跳


#三层交换

三层交换技术
1、作用:使用三层交换技术实现VLAN间通信 
三层交换=二层交换+三层转发

2、虚拟接口（SVI）
三层交换机上配置的VLAN接口为虚接口

3、三层交换机的配置
(1)在三层交换机启用路由功能 
全局：ip  routing
(2)配置虚拟接口的IP 地址
全局：interface  vlan  1
ip  address  192.168.2.254  255.255.255.0 
no  shutdown 
(3)在三层交换机上配置Trunk并指定接口封装为802.1q
接口模式：switchport  trunk  encapsulation  dot1q 
switchport  mode  trunk
(4)将三层交换机的接口配置成路由接口
进入接口：no  switchport 


#动态路由:基于某种路由协议实现

动态路由特点:
减少了管理任务
占用了网络带宽
使用范围:大型网络

#OSPF协议
OpenShortestPathFirst:开放式最短路径优先

OSPF区域
为了适应大型的网络，OSPF在网络内划分多个区域
每个OSPF路由器只维护所在区域的完整链路状态信息

区域ID:区域ID可以表示成一个十进制的数字,也可以表示成一个IP

骨干区域Area0:负责区域间路由信息传播

启动OSPF路由进程
Router(config)# router ospf 进程id  #进程id:开启的是第一个进程则为1

指定OSPF协议运行的接口和所在的区域(宣告直连路由)
Router(config-router)# network 直连网段id 反子网掩码 area 区域id
#区域id:开启第一个区域为0

宣告默认路由:default-information originate
=================================================================================
		      04.Network-day04
=================================================================================

#传输层

网络层提供点到点的连接
传输层提供端到端的连接

TCP和UDP协议
1.TCP:TransmissionControlProtocol:传输控制协议
可靠的、面向连接的协议
传输效率低
2.UDP:UserDatagramProtocol:用户数据报协议
不可靠的、无连接的服务
传输效率高

TCP的封装格式-关键字段
源端口号
目标端口号
SYN:请求建立连接
ACK:确认连接/断开连接
FIN:请求断开连接

TCP的连接与断开:三次握手,四次断开
<三次连接:三次握手>
      SYN	ACK,SYN	       ACK
客户端---->服务端-------->客户端---->服务端
<四次断开>
      FIN	ACK	  
客户端---->服务端---->客户端
      FIN       ACK
服务端---->客户端---->服务端

TCP的应用
协议:端口
FTP:21
HTTP:80
HTTPS:443
SSH:22
DNS:53
SMTP:25

UDP的应用
协议:端口
TFTP:69
DNS:53
NTP:123

#访问控制列表
访问控制列表ACL：读取第三,四层头部信息根据预先定义好的规则对包进行过滤

访问控制列表匹配规则:(匹配即停止,无匹配则拒绝)
如果匹配第一条规则,则不再往下检查,路由器将决定该数据包允许通过或拒绝通过
如果不匹配第一条规则,则依次往下检查,直到有任何一条规则匹配
如果最后没有任何一条规则匹配,则路由器根据默认的规则隐含拒绝,将丢弃该数据包

访问控制列表的类型：
1.标准访问控制列表
基于源IP地址过滤数据包 
列表号是1～99 
2.扩展访问控制列表
基于源IP地址、目的IP地址、指定协议、端口等来过滤数据包 
列表号是100～199 

标准ACL配置
1.标准ACL-创建ACL
Router(config)#access-list 列表号 permit或deny 源IP地址 反掩码
#反掩码:0严格匹配,1不匹配

2.对某一IP地址设置ACL
Router(config)#access-list 列表号 permit或deny  host 源IP地址

3.对任意源IP地址允许或拒绝通过
Router(config)#access-list 列表号 permit或deny  any

4.删除ACL:
全局：no  access-list  列表号
注：不能删除单条ACL语句，只能删除整个ACL。

5.隐含的拒绝语句(默认存在)
Router(config)# access-list 1 deny 0.0.0.0 255.255.255.255

6.将ACL应用于接口
Router(config-if)# ipaccess-group 列表号 {in或out}
接口上取消ACL
Router(config-if)# no ipaccess-group 列表号 {in或out}

7.查看访问控制列表
Router(config)# show  access-lists

扩展ACL配置
Router(config)# 全局配置模式:
access-list 101 permit或deny 协议 源IP地址 目标IP地址 eq 端口号         


#NAT:NetworkAddressTranslation:网络地址转换

私有ip地址分类
A类10.0.0.0-10.255.255.255
B类172.16.0.0-172.31.255.255
C类192.168.0.0-192.168.255.255


1.作用:通过将内部网络的私有IP地址翻译成全球唯一的公网IP地址使内部网络可以连接到互联网等外部网络上

2.优点：节省公有合法IP地址,处理地址重叠,隐藏IP地址增加安全性

3.缺点:延迟增大,配置和维护复杂

4.NAT实现方式

静态转换(NAT)
IP地址的对应关系是一对一,而且是不变的,借助静态转换,能实现外部网络对内部网络中某些特设定服务器的访问
静态NAT配置：
配置接口IP及路由
全局：
Ip nat inside source static 私网IP地址 公网IP地址
在内外接口上启用NAT：
出口配置：ip 　nat 　outside
入口配置：ip 　nat 　inside 

#NAT端口映射
建立NAT端口映射关系:配置命令:
Router(config)# 
Ip nat inside source static 协议 私网IP地址 端口号 公网IP地址 端口号

开启/关闭nat排错功能
Router#debug/undebug  ip  nat 

5.*了解内容:端口多路复用(PAT):外网客户端无法直接访问,不适用于服务器
通过改变外出数据包的源IP地址和源端口并进行端口转换，内部网络的所有主机均可共享一个合法IP地址实现互联网的访问，节约
PAT的配置:
全局：ip nat inside source list 1 interface f0/1 overload


6.NAT两种实现方式的区别：
静态转换的对应关系一对一且不变，并且没有节约公用IP，只隐藏了主机的真实地址。
端口多路复用可以使所有内部网络主机共享一个合法的外部IP地址，从而最大限度地节约IP地址资源。


=================================================================================
		      04.Network-day05
=================================================================================

#STP生成树协议
路由环路:利用ttl值:生命周期,每经过一个路由减少1,防止路由环路

STP:Spanning Tree Protocol:生成树协议
逻辑上断开环路，防止广播风暴的产生
当线路故障，阻塞接口被激活，恢复通信，起备份线路的作用

网桥ID
一个八字的字段，前两个字节十进制数为网桥优先级，后六个字是网桥的MAC地址
(网桥优先级的取值范围0-65535默认值为32768)

根网桥
选择交换网络中网桥ID较小的交换机成为根网桥
(优先级小的被选择为根网桥,优先级相同则MAC地址小的为根网桥)
#优先级最小的为主根网桥,优先级次之的为次根网桥
#三台交换机的环路则断开第三台交换机与次根网桥相连的链路

查看交换机mac地址
Switch#show version
ase ethernet MAC Address  #该字段即为MAC地址

注意： 优先级的值是4096的倍数；
全局模式：
spanning-tree  vlan  1  priority  优先级的值
#优先级的值是4096的倍数

查看某个vlan的生成树的配置
特权：show  spanning-tree  vlan  1


#PVST+:增强的每vlan生成树

PVST+配置的意义:
配置网络中比较稳定的交换机为根网桥 
利用PVST+实现网络的负载分担


#HSRP:HotStandbyRoutingProtocol热备份路由选择协议

进入路由器的网关接口

1、配置为HSRP的成员 
standby  1   ip   虚拟网关IP地址 

2、查看HSRP摘要信息 
特权： show  standby  brief

3、配置HSRP的优先级
standby  1   priority  优先级
优先级范围0-255，默认为100

4、HSRP占先权:当本机的HSRP优先级高于其它设备时,立刻抢占活跃身份
standby   1  preempt

5、HSRP端口跟踪:跟踪端口,当链路失效默认优先级减10
standby  1  track  f0/1


=================================================================================
		         05.Shell-day01
=================================================================================


切换用户的Shell环境

系统内解释器
[root@svr7 ~]# cat /etc/shells 
/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh

可安装解释器程序包
[root@svr7 ~]# yum -y install ksh

*若需要临时使用另一种Shell环境,可以直接执行对应的Shell解释器程序
[root@svr7 ~]# ksh		#临时切换成ksh解释器
# exit				#退出
[root@svr7 ~]#

修改用户默认解释器
usermod -s /解释器路径 用户名

查看历史命令条数
[root@svr7 ~]# history | wc -l

清空历史的命令
[root@svr7 ~]# history -c			#清空自己的历史命令
[root@svr7 ~]# cat .bash_history		#查看历史命令记录文件
[root@svr7 ~]# > ~/.bash_history		#清空记录文件

重定向标准输入。
[root@svr7 ~]# mail -s Error  root   < /etc/passwd

*了解内容:以下两种重定向效果是一样的
&> test.txt
> test.txt 2>&1

列出Yum仓库软件单
[root@svr7 ~]# yum list

一个规范的Shell脚本构成包括：
脚本声明（需要的解释器、作者信息:邮箱等联系方式）
注释信息（步骤、思路、用途、变量含义等）
可执行语句（操作代码）


给脚本添加执行权限,直接执行:
[root@svr7 ~]# chmod o+x first.sh                     
[root@svr7 ~]# ./first.sh或/root/first.sh             #开启子进程
[root@svr7 ~]# pstree
─sshd─┬─sshd───bash───sleep.sh───sleep

作为参数:使用bash,sh,source来加载脚本文件
[root@svr7 ~]# bash   first.sh                        #开启子进程
[root@svr7 ~]# pstree
├─sshd─┬─sshd───bash───bash───sleep


[root@svr7 ~]# sh     first.sh                        #开启子进程
[root@svr7 ~]# pstree
├─sshd─┬─sshd───bash───sh───sleep


[root@svr7 ~]# source first.sh                        #不开启子进程
[root@svr7 ~]# pstree				      
├─sshd─┬─sshd───bash───sleep


查看系统变量

使用env可查看所有环境变量：
[root@svr7 ~]# env

使用set可查看所有变量（包括env能看到的环境变量）：
[root@svr7 ~]# set

位置变量:
echo $0                                        //脚本的名称
echo $1                                        //第一个参数
echo $2                                        //第二个参数
echo $*                                        //所有参数
echo $#                                        //所有的综合
echo $$                                        //当前进程的进程号
echo $?                                        //上一个程序的返回状态码


三种引号对变量赋值的影响

1）双引号的应用
使用双引号可以界定一个完整字符串。
[root@svr5 ~]# xx=Tarena IT Group
-bash: IT: command not found			//未界定时赋值失败
[root@svr5 ~]# xx="Tarena IT Group"		//界定后成功
[root@svr5 ~]# touch aa bb                      //创建了两个文件
[root@svr5 ~]# touch "aa bb"                    //创建了一个文件

2）单引号的应用:
界定一个完整的字符串，并且可以实现屏蔽特殊符号的功能
[root@svr7 ~]# test=11
[root@svr7 ~]# echo "$test"
11
[root@svr7 ~]# echo '$test'
$test

3）反撇号或$()的应用
使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换。

暗文密码:
stty -echo	#终端上不显示输入的内容
stty echo	#恢复

自定义的变量默认为局部变量,只在当前Shell环境中有效,在子Shell环境中无法直接使用
[root@svr7 ~]# yy="Tarena IT Group"
[root@svr7 ~]# echo $yy
Tarena IT Group
[root@svr7 ~]# bash                             //开启bash子进程
[root@svr7 ~]# echo $yy                         //查看SCHOOL变量值无结果

发布全局变量:export命令
定义的变量能被子进程使用,发布时直接指定变量名(可以有多个),也可以通过export命令设置新的全局变量
[root@svr7 ~]# export yy                        //发布已定义的变量
[root@svr7 ~]# export XX="1234"                 //发布新变量



=================================================================================
		         05.Shell-day02
=================================================================================

转义符:\的用法
\a与'a'用法相同:屏蔽特殊含义

求模(取余)
余数永远小于除数

let运算
let命令可以直接对变量值做运算再保存新的值
另外，let运算操作并不显示结果，但是可以结合echo命令来查看

[root@svr7 ~]# X=1234  
[root@svr7 ~]# let y=X+22
[root@svr7 ~]# echo $y

[root@svr7 ~]# let i++;        # i++(i=i+1)
[root@svr7 ~]# let i--;        # i--(i=i-1)
[root@svr7 ~]# let i+=num      # i+=num(i=i+num)
[root@svr7 ~]# let i-=num      # i-=num(i=i-num)
[root@svr7 ~]# let i*=num      # i*=num(i=i*num)
[root@svr7 ~]# let i/=num      # i/=num(i=i/num)
[root@svr7 ~]# let i%=num      # i%=num(i=i%num)

小数运算工具

1）bc交互式运算
先执行bc命令进入交互环境，然后再输入需要计算的表达式。

[root@svr7 ~]# bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
0.1+0.2				//加法
.3
0.3-0.2				//减法
.1
0.3*0.2				//乘法
0
0.3/0.2				//除法
1
scale=2				//小数点取两位
0.3*0.2
.06
0.3/0.2
1.50
quit                                              //退出交互计算器

2）bc非交互式运算
将需要运算的表达式通过管道操作交给bc运算。注意，小数位的长度可采用scale=N限制，除此以外也受参与运算的数值的小数位影响。

[root@svr7 ~]# echo "scale=4;12.24+5.678"|bc	//;代表在交互式下的回车
[root@svr7 ~]# echo "scale=4;12.24*5.678"|bc
[root@svr7 ~]# echo "scale=4;12.24/5.678"|bc

条件测试操作

1)字符串测试
使用 test 表达式 或者 [ 表达式 ] 		//表达式两边至少要留一个空格。
条件测试操作本身不显示出任何信息,利用命令执行后的返回状态$?的值来判断

[root@svr7 ~]# test $USER == root
[root@svr7 ~]# echo $?
0
[root@svr7 ~]# test $USER == tom
[root@svr7 ~]# echo $?
1
[root@svr7 ~]# [ $USER != root ]
[root@svr7 ~]# echo $?
1
[root@svr7 ~]# [ $USER != tom ]
[root@svr7 ~]# echo $?
0

2)一行执行多条命令的情况
A && B                        //仅当A命令执行成功，才执行B命令
A || B                        //仅当A命令执行失败，才执行B命令
A ;  B                        //执行A命令后执行B命令，两者没有逻辑关系
A && B || C                   //思考？

3)-z 检查变量的值是否未设置(空值)
[root@svr7 ~]# a="nb" ; b=""
[root@svr7 ~]# [ -z $a ] && echo "空值" || echo "非空值"
非空值
[root@svr7 ~]# [ -z $b ] && echo "空值" || echo "非空值"
空值                                     //变量b已设置但无任何值,为空
[root@svr7 ~]# [ ! -z $a ]              //测试a是否为非空

*还有一个-n可以测试变量是否不为空（相当于! -z）。

提取当前登录的用户数
[root@svr7 ~]# who | wc -l 


=================================================================================
		         05.Shell-day03
=================================================================================

{1..n}与seq区别:
[root@svr7 ~]# a=4
[root@svr7 ~]# echo {1..$a}	//无法用变量
{1..4}
[root@svr7 ~]# seq $a		//可以用变量
1
2
3
4
使用Shell函数:shell中return可以跳出函数并返回值，类似exit

for i in {1..n}			//{1..n}为公式,可直接用
for i in `seq n`		//seq为命令,要加``取命令结果返回值

while死循环
while :
do
    命令序列
done


case语句
    case  变量  in
    匹配值1)			#若变量与匹配值1匹配则执行命令序列1
        命令序列1 ;;
    匹配值2)			#若与匹配值1不匹配则与匹配值2匹配
        命令序列2 ;;
        .. ..
    *)
        默认命令序列
    esac

使用Shell函数
格式1：

    function  函数名 {
        命令序列
        .. ..
    }

格式2：

    函数名() {
        命令序列
        .. ..
    }

删除函数:unset 函数名


颜色输出的命令:echo -e "\033[32mOK\033[0m"。   #输出为绿色的OK

[root@svr7 ~]# vim mycolor.sh
#!/bin/bash
cecho() {
    echo –e "\033[$1m$2\033[0m"      #$1为自定义字体,$2为自定义的输出文本
}

colorecho 32 OK
colorecho 33 OK
colorecho 34 OK
colorecho 35 OK
colorecho 36 OK

$1=0X为字体样式,3X为字体颜色,4X为背景颜色



Shell版本的fork炸弹

    [root@svr7 ~]# vim forkboom.sh
    #!/bin/bash
    .(){
    .|.&
    }
    .

wait 
等所有后台进程结束之后脚本才结束

通过break、continue、exit在Shell脚本中实现中断与退出的功能。

break可以结束整个循环；
continue结束本次循环，进入下一次循环；
exit结束整个脚本，案例如下：



非交互式添加分区

方法一

添加/deb/sdb 下的分区，其实位置为1到1000M，第二个分区位置为1001至3000M，位 置千万不能指定错误
 parted /dev/sdb mklabel  gpt
 parted /dev/sdb mkpart primary 1 1000M
 parted /dev/sdb mkpart primary 1001 3000M

 

=================================================================================
		        05.Shell-day04
=================================================================================

字符串截取及切割:仅显示字符串处理结果,不改变原变量值

字符串截取
方法一:起始位置是从0开始
echo ${#变量名}    	//显示变量长度
echo ${变量名:起始位置:长度}   //截取字符串

方法二:起始编号从1开始:变量值为汉字时,3个字节为1个汉字
expr substr "$变量名" 起始位置 长度

方法三:起始编号从1开始:变量值为汉字时,3个字节为1个汉字
echo $变量名 | cut -b 起始位置-结束位置 或 要截取字符的编号(多个时以,分隔)


字符串的替换
1）只替换第1个子串
格式：echo ${变量名/old/new}

2）替换全部子串
格式：echo ${变量名//old/new}


字符串的匹配删除(掐头去尾)
掐头#:从左向右
1）从左向右，最短匹配删除
格式：echo ${变量名#*关键词}

2）从左向右，最长匹配删除
格式：${变量名##*关键词}

去尾#:从右向左
3）从右向左，最短匹配删除
格式：echo ${变量名%关键词*}

4）从右向左，最长匹配删除
格式：echo ${变量名%%关键词*}

字符串初值的处理
${var:-word}
若变量var已存在且非空则返回$var的值;否则返回字串word,原变量var的值不受影响


数组变量定义
数组名称=(数组参数1 数组参数2 ...)
数组名称[下标号]=值

查看数组变量值
echo ${数组名称[下标号]}
echo ${数组名称[*]}
echo ${#数组名称[*]}    //查看数组长度


expect预期交互
yum -y install expect		//装软件包,系统默认没有

<<EOF

//两个EOF之间输入的内容会通过<<导入到前面的指令中

EOF

#!/bin/bash
expect << EOF
spawn ssh 192.168.4.20
expect 关键词	{send "要输入的内容\n"}		//\n代表回车的意思
expect 关键词	{send "要输入的内容\r"}		//\r代表回车的意思
expect 关键词	{send "要输入的内容"}
EOF
echo 

示例:
#!/bin/bash
expect << EOF
spawn ssh 192.168.4.20
expect password {send "123456\n"}
expect #        {send "touch /12.txt\n"}
expect #        {send "exit\n"}			//最后一行没有实际意义
EOF
echo 

*解决ssh时询问yes/no:
ssh -o StrictHostKeyChecking=no     //ssh -o St(Tab)


正则表达式

		==基本正则列表==
正则符号	描述
^		匹配行首
$		匹配行尾
[]		集合,匹配集合中的任意单个字符(连续的字符可用-,如abc=a-c)
[^]		对集合取反
.		匹配任意单个字符
*		匹配前一个字符任意次数(长度)包括0次(*不允许单独使用)
\{n,m\}		匹配前一个字符n到m次
\{n\}		匹配前一个字符n次
\{n,\}		匹配前一个字符n次及以上
\(\)		保留

		==扩展正则列表==
正则符号	描述
+		最少匹配一次
?		最多匹配一次(0/1次,代表可有可无)
{n,m}		匹配n到m次
()		组合为整体,保留----------------------
|		或者(与()结合一起用)		   |
\b		单词边界			   |	
						   |	
###########################			   |
grep 不支持扩展正则				   |
egrep / grep -E 支持扩展正则			   |
###########################			   |	
						   |
():组合为整体,保留:可理解为复制  <--------------------
示例:
sed 's/^(.)(.*)(.)$/\3\2\1/g' /文件	//将文件每一行开头和结尾字母调换

\n:代表粘贴第n个()内的内容

=================================================================================
		         05.Shell-day05
=================================================================================

sed：Stream EDitor,流式编辑器
非交互，匹配过滤及修改文本
逐行处理，并将结果输出到屏幕

用法1：sed  [选项]  '条件+指令'  文件.. ..
用法2：前置命令 | sed  [选项]  '条件指令'


sed选项：
-n	屏蔽默认输出，sed默认输出文档全部内容
-r	让sed支持扩展正则
-i	sed直接修改源文件，默认sed只通过内存临时修改文件，源文件无影响`````

sed指令：没有条件，则表示匹配所有行
p：print，输出内容
d：delete，删除内容
s/old/new/选项：substitute，替换内容
c:整行修改,将对应行原来所有修改成指定的内容

##########################################################
选项:
无：替换每行中的第一个
行号n：替换第n行中的每一个
g：替换所有
特殊用法:
s/old//g:将所有old替换为空，即删除
s#/bin/bash#/sbin/sh#：old,new包含‘/’，则用s#/old#/new#
n,ms/^/#/：将n-m行注释掉
s/^#an/an/：解除以#an开头的行的注释
sed -n 's/old/new/p'：只显示替换的内容其它不显示
##########################################################


sed条件：(p可更换为其它指令)
nx:对第n行执行x指令
n,mx:对第n-m行执行x指令
nx;mx:对第n&m行执行x指令(多个指令可以使用分号隔离)
n,+mx:第n行以及后面的m行执行x指令
n~mx:第n行开始每m行执行一次x指令,m为步长
1~2x:第1行开始每2行执行一次x指令,即奇数行
2~2x:第2行开始每2行执行一次x指令,即偶数行
/正则/:所有正则必须写到//里面



######################################################################  
sed  -n '$=' /文件路径        //输出文件的行数,$代表最后一行,=代表输出行号
sed  -n  '/root/=' /文件路径  //输出匹配包含root的行号
sed  '/root/!d' /文件路径     //删除不包含root的行，!符号表示取反
######################################################################



=================================================================================
		         05.Shell-day06
=================================================================================

awk工具:编程语言/数据处理引擎
基于模式匹配检查输入文本,逐行处理并输出
在Shell脚本中,获取指定的数据
对文本数据做统计

格式:awk 选项 '条件{指令}' 文件

awk过滤数据时支持仅打印某一列
*若有多条编辑指令，可用分号分隔

最常用的编辑指令:print
awk '{print $n}' test.txt   //打印第n列
awk '{print $n,$m}' test.txt   //打印第n列和第m列

awk常用内置变量：
$0 文本当前行的全部内容
$n 文件的第n列
NR now row文件当前行的行号
NF now filed文件当前行的列数,即有多少列
awk '{print $NF}'		//输出最后一列内容


选项 -F 可指定分隔符,若未指定分隔符,则默认将空格,制表符等作为分隔符
[root@svr5 ~]# awk -F分隔符 '{print $1,$7}' /etc/passwd  
//分隔符可以是单个符号,还可以是多个用[集合]表示
[root@svr5 ~]# awk -F [:/] '{print $1,$10}' /etc/passwd
root bash

awk的print指令不仅可以打印变量，还可以打印常量
[root@svr5 ~]# awk -F: '{print $1,"的解释器:",$7}' /etc/passwd
root 的解释器: /bin/bash
常量与变量用逗号分隔则输出结果会显示空格分隔:
[root@svr5 ~]# awk -F: '{print $1"的解释器:"$7}' /etc/passwd
root的解释器:/bin/bash


awk处理的时机:awk会逐行处理文本,但支持在处理第一行之前做一些准备工作,以及在处理完最后一行之后做一些总结性质的工作

awk 'BEGIN{指令} {指令} END{指令}'  文件
    
BEGIN{ }	行前处理，读取文件内容前执行，指令执行1次
{ }		逐行处理，读取文件过程中执行，指令执行n次
END{ }		行后处理，读取文件结束后执行，指令执行1次

只做预处理的时候,可以没有操作文件:例如:可用于计算功能
[root@svr5 ~]# awk 'BEGIN{A=24;print A*2}'
[root@svr5 ~]# awk 'BEGIN{print x+1}' 	#x可以不定义，直接用，默认值位0
[root@svr5 ~]# awk 'BEGIN{print 3.2+3.5}'

#######################################
column -t	自动制表符对齐
sort		排序(按字符顺序排)
sort -n		排序(按数值大小排序:升序)
sort -rn	排序(按数值大小排序:降序)
#######################################

awk处理条件:
1.使用正则设置条件:/正则/:(正则作为条件时无指令则默认为print)
对第n列进行正则匹配 awk  '$n~/正则/' /文件	
[root@svr5 ~]# awk -F: '$1~/root/' /etc/passwd	//对第一列匹配包含root

2）使用数值/字符串比较设置条件
比较符号：==,!=,>,>=,<,<=
[root@svr5 ~]# awk -F: 'NR==3{print}' /etc/passwd	//输出第三行
逻辑且&&
逻辑或||



遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}
[root@svr5 ~]# awk 'BEGIN{a[0]=0;a[1]=11; for(i in a){print i,a[i]}}'

ab -c 100 -n 100000 http://192.168.4.7/	
ab:访问模拟器 100个人  模拟访问100000次 服务器192.168.4.7

输出信息时，可以使用“\t”显示Tab制表位：
[root@svr5 ~]# awk -F: 'BEGIN{print "User\tUID\tHome"}{print $1 
"\t" $3 "\t" $6}END{print "Total",NR,"lines."}' /etc/passwd
    User    UID     Home
    root    0       /root



=================================================================================
		         05.Shell-day07
=================================================================================

echo $!显示最新一个后台进程的进程号
echo $$显示最新一个进程的进程号

netstat(rhel7简化为ss)命令可以查看系统中启动的端口信息，该命令常用选项如下：
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）

uptime			查看CPU负载
ifconfig eth0		查看网卡流量
free			查看内存信息
df			查看磁盘空间
wc -l /etc/passwd	查看计算机账户数量
who |wc -l		查看登录账户数量
rpm -qa |wc -l		查看已安装软件包数量


[root@svr7 ~]# ifconfig eth0
RX packets 14265  bytes 14314269 (13.6 MiB)	入站流量
TX packets 8054  bytes 28982695 (27.6 MiB)	出站流量

[root@svr7 ~]# uptime 
 11:32:01 up  2:08,  2 users,  load average: 0.00, 0.01, 0.05
					     5分钟 10分钟 15分钟
						 CPU 负载

=================================================================================
=================================================================================

#搭建Nginx服务器

I.构建Nginx服务器
1）使用源码包安装nginx软件包
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel//安装依赖包
[root@proxy ~]# useradd -s /sbin/nologin nginx //利用普通用户身份限制权限
[root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
[root@proxy ~]# cd  nginx-1.10.3
[root@proxy nginx-1.10.3]# ./configure 
> --prefix=/usr/local/nginx 		//指定安装路径
> --user=nginx 				//指定用户(启动服务的用户)
> --group=nginx 			//指定组(启动服务的组)
> --with-http_ssl_module
//开启SSL加密功能,--with--模块名称可以开启未启用的模块功能
[root@proxy nginx-1.10.3]# make && make install    //编译并安装

2）nginx命令的用法
[root@proxy ~]# /usr/local/nginx/sbin/nginx	       #启动服务
[root@proxy ~]# netstat -nultp | grep nginx	       #查看服务状态
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop    #关闭服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload  #重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx –V	       #查看软件信息
[root@proxy ~]# ps aux | grep nginx		       
nginx 4303 0.0 0.1 48364 1968 ? S 11:30   0:00 nginx: worker process  
  ↑
#验证利用用户权限降级成功
[root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/ 
#创建快捷方式,方便后期使用

3）设置防火墙与SELinux
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
[root@proxy ~]# setenforce 0

4）测试首页文件
Nginx Web服务默认首页文档存储目录为/usr/local/nginx/html/，在此目录下默认有一个名为index.html的文件，使用客户端访问测试页面：
[root@client ~]# curl http://192.168.2.5	#curl命令行下的浏览器
<html>
<head>
<title>Welcome to nginx!</title>		#测试成功
</head>
<body bgcolor="white" text="black">
<center><h1>Welcome to nginx!</h1></center>
</body>
</html>

II.升级Nginx服务器

1）编译新版本nginx软件
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   
> --prefix=/usr/local/nginx   
> --user=nginx   
> --group=nginx   
> --with-http_ssl_module
[root@proxy nginx-1.12.2]# make            
2) 备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
[root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  
			     /usr/local/nginx/sbin/nginxold
[root@proxy nginx-1.12.2]# cp objs/nginx /usr/local/nginx/sbin/     
//拷贝新版本
#################################################################
[root@proxy nginx-1.12.2]# make upgrade	//升级(不推荐使用,容易报错)
#################################################################
[root@proxy nginx-1.12.2]# killall nginx
[root@proxy nginx-1.12.2]# nginx
[root@proxy nginx-1.12.2]# nginx -v //查看版本

III.客户端访问测试

分别使用浏览器和命令行工具curl测试服务器页面
[root@client ~]# firefox http://192.168.4.5
[root@client ~]# curl http://192.168.4.5


#用户认证

I.Nginx配置文件框架格式：
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
全局配置（用户名,日志,进程)
http{
    server{
        listen 80;
        server_name 域名1;
	location / {
        root html;#网页文件根目录html是相对路径,在/usr/local/nginx/html
	}
       }
       server{
        listen 80;
        server_name 域名2;
	location / {
        root www;
	}
       }
}

II.实现用户验证
修改Nginx配置文件
1）修改/usr/local/nginx/conf/nginx.conf
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
 ---------------------------------------------------------------
|		     在对应位置追加以下两行			|
 ---------------------------------------------------------------
|auth_basic "XXXXXXXXX";		  //XXXXX是认证提示信息 	|
|auth_basic_user_file "/usr/local/nginx/pass";   //认证密码文件 	|
 ----------------------------------------------------------------
        location / {
            root   html;
            index  index.html index.htm;
        }
  }

2）生成密码文件，创建用户及密码
使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。
[root@proxy ~]# yum -y install  httpd-tools
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass tom //创建密码文件
New password: 
Re-type new password: 
Adding password for user tom
[root@proxy ~]# htpasswd  /usr/local/nginx/pass jerry //追加用户不用-c
New password: 
Re-type new password: 
Adding password for user jerry
[root@proxy ~]# cat /usr/local/nginx/pass
tom:$apr1$vjiiTOFz$LHkGgJjj7xOBeWjUMstUV.
jerry:$apr1$7wBDNQdp$3yM7/ud2mvNeV9LOvP9SY.

3）重启Nginx服务
[root@proxy ~]# nginx -s reload#重新加载配置文件    


III.客户端测试
登录192.168.4.100客户端主机进行测试
[root@client ~]# firefox http://192.168.4.5       //输入密码后可以访问


#基于域名的虚拟主机
I.修改配置文件

1）修改Nginx服务配置，添加相关虚拟主机配置如下
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
server {
        listen       80;                             //端口
        server_name  www.a.com;                      //域名
auth_basic "Input Password:";                        //认证提示符
auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
location / {
            root   html;                             //指定网站根路径
            index  index.html index.htm;
       }
       
}
… …
    server {
        listen  80;                                  //端口
        server_name  www.b.com;                      //域名
location / { 
            root   www; 		             //指定网站根路径
            index  index.html index.htm;
}
}

2）创建网站根目录及对应首页文件
[root@proxy ~]# mkdir /usr/local/nginx/www
[root@proxy ~]# echo "www" > /usr/local/nginx/www/index.html

3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload

II.客户端测试
1）修改客户端主机192.168.4.100的/etc/hosts文件，进行域名解析
[root@client ~]# vim /etc/hosts
192.168.4.5    www.a.com  www.b.com
2）登录192.168.4.100客户端主机进行测试
注意：请先关闭真实机的firefox，SSH –X远程连接调用虚拟机的firefox。
[root@client ~]# firefox http://www.a.com     //输入密码后可以访问
[root@client ~]# firefox http://www.b.com     //直接访问

######################################################################
扩展其他虚拟主机：
1.基于端口的虚拟主机（参考模板）
server {
        listen       8080;              //端口
        server_name  web1.example.com;          //域名
        ......
}
    server {
        listen       8000;
        server_name  web1.example.com;
      	......
}
2.基于IP的虚拟主机（参考模板）
server {
        listen       192.168.0.1:80;          //端口
        server_name  web1.example.com;          //域名
	......
}
    server {
        listen       192.168.0.2:80;
        server_name  web1.example.com;
	......
}
#######################################################################


#SSL虚拟主机
*源码安装Nginx时使用--with-http_ssl_module参数,启用加密模块
对于需要进行SSL加密处理的站点添加ssl相关指令,设置网站需要的私钥和证书
*现在密钥一般与证书结合在一起

加密算法分类:对称算法、非对称算法、信息摘要
对称算法有：AES、DES:主要应用在单机数据加密
非对称算法有：RSA、DSA:主要应用在网络数据加密
信息摘要：MD5、sha256(hasha):主要应用在数据完整性校验、数据秒传等
命令:md5sum /路径文件 查看文件md5码

#############################################
秒传原理:
A:---->云盘(a.mp4)
查看并记录a.mp4的md5sum码
A-->U盘-->B
B:(a.mp4-->b.mp4)-->云盘
查看b.mp4的md5sum码跟a.mp4的是一样的
直接调用a.mp4数据到B云盘账户
实际上是没有上传,只是把a.mp4挂载到B的云盘账户了
#############################################

I.配置SSL虚拟主机
1）生成私钥与证书
[root@proxy ~]# cd /usr/local/nginx/conf
[root@proxy ~]# openssl genrsa > cert.key	//生成私钥
[root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem 
//生成证书(公钥)

2）修改Nginx配置文件，设置加密网站的虚拟主机
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
(shift+G:跳到最后面)
server {
        listen       443 ssl;
        server_name            www.c.com;      #修改域名
        ssl_certificate      cert.pem;         #这里是证书文件
        ssl_certificate_key  cert.key;         #这里是私钥文件
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
        location / {
            root   html;
            index  index.html index.htm;
        }
    }

3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload

II.客户端验证
1）修改客户端主机192.168.4.100的/etc/hosts文件，进行域名解析
[root@client ~]# vim /etc/hosts
192.168.4.5    www.c.com  www.a.com   www.b.com

2）登录192.168.4.100客户端主机进行测试
[root@client ~]# firefox https://www.c.com  //信任证书后可以访问


=================================================================================
		         06.Operation-day02
=================================================================================

#部署LNMP环境

LNMP（Linux、Nginx、MySQL、PHP）
软件安装列表
nginx
mariadb、mariadb-server、mariadb-devel
php、php-fpm、php-mysql
########################################################
LNMP常见问题
Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
PHP默认错误日志文件为/var/log/php-fpm/www-error.log
如果动态网站访问失败，可用参考错误日志，查找错误信息。
########################################################
I.安装软件
1）使用yum安装"源码安装Nginx"的基础依赖包
[root@proxy ~]# yum -y install gcc openssl-devel pcre-devel zlib-devel

2）源码安装Nginx

3）安装MariaDB
Mariadb在新版RHEL7光盘中包含有该软件，配置yum源后可以直接使用yum安装：
[root@proxy ~]# yum -y install   mariadb  mariadb-server mariadb-devel

4）php和php-fpm(该软件包在lnmp_soft中提供)
[root@proxy ~]# yum -y  install  php   php-mysql
[root@proxy ~]# rpm -ivh php-fpm-5.4.16-42.el7.x86_64.rpm

II.启动服务
1）启动Nginx服务

2）启动MySQL服务
[root@proxy ~]# systemctl start  mariadb           //启动服务器
[root@proxy ~]# systemctl status mariadb           //查看服务状态
[root@proxy ~]# systemctl enable mariadb           //设置开机启动

3）启动PHP-FPM服务
[root@proxy ~]# systemctl start php-fpm           //启动服务
[root@proxy ~]# systemctl status php-fpm          //查看服务状态
[root@proxy ~]# systemctl enable php-fpm          //设置开机启动

4）设置防火墙与SELinux
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
[root@proxy ~]# setenforce 0


#构建LNMP平台

I.php-fpm配置文件
1）查看php-fpm配置文件（实验中不需要修改该文件）
[root@proxy ~]# vim /etc/php-fpm.d/www.conf
[www]
listen = 127.0.0.1:9000            //PHP端口号
pm.max_children = 32               //最大进程数量
pm.start_servers = 15              //最小进程数量
pm.min_spare_servers = 5           //最少需要几个空闲着的进程
pm.max_spare_servers = 32          //最多允许几个进程处于空闲状态

II.修改Nginx配置文件并启动服务

##############################################################
server{
        listen 监听端口;
        server_name 域名;
	location / {
        root www;
	}
       }
location:匹配用户客户端地址栏输入的网址
示例:
server{
        listen 监听端口;
        server_name 域名;
	location / {
        root www;
	}
	location /test {
        	deny all;
	}
	location /abc {
        	deny 1.1.1.1;
	}
       }

访问www.a.com/test;拒绝所有访问
访问www.a.com/abc;拒绝1.1.1.1访问
访问www.a.com/qq;先匹配一遍所有loacation没有找到再匹配网页根目录
##############################################################

[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
将配置文件对应内容修改成以下内容:
先dd删除最长的一行:#fastcgi_param......$fastcgi_script_name;

location ~ \.php$ {			#~为正则匹配标记
          root           html;
          fastcgi_pass   127.0.0.1:9000; #转发请求给本机9000端口PHP解释器
          fastcgi_index  index.php;
          include        fastcgi.conf;
        }

[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload


III.创建PHP页面，测试LNMP架构能否解析PHP页面

1）创建PHP测试页面
[root@proxy ~]# vim /usr/local/nginx/html/test1.php
<?php
$i="This is a test Page";
echo $i;
?>

2）创建PHP测试页面,连接并查询MariaDB数据库。
可以参考lnmp_soft/php_scripts/mysql.php:
cp lnmp_soft/php_scripts/mysql.php /usr/local/nginx/html
客户机看一下页面http://www.a.com/mysql.php
mysql -uroot
grant all on *.* to tom@'1.1.1.1' identified by '123';
刷新页面,多出来
Host:1.1.1.1
Name:tom


#地址重写
Nginx服务器的地址重写，主要用到的配置参数是rewrite：
格式:rewrite 旧地址   新地址    [选项]
#旧地址默认支持正则表达式 如a.html中.默认是任意匹配字符的意思

I.修改配置文件(访问a.html重定向到b.html)

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;		
rewrite /a.html /b.html redirect;   #只要写到了server{}中即可    
#redirect选项:让地址栏的地址从www.a.com/b.html-->www.a.com/b.html
}
}
[root@proxy ~]# echo "BB" > /usr/local/nginx/html/b.html

2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload

3）客户端测试
[root@client ~]# firefox  http://192.168.4.5/a.html

II.修改配置文件(访问192.168.4.5的请求重定向至www.tmooc.cn)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/ http://www.tmooc.cn/;	#^/代表正则匹配访问根下任意目录
location / {
    root   html;
index  index.html index.htm;
# rewrite /a.html  /b.html  redirect;
}
}

2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload

3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5


III.修改配置文件:访问192.168.4.5下面子页面,重定向至www.tmooc.cn下相同的页面

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*) http://www.tmooc.cn/$1;	    //$1相当于shell中正则的\1
location / {
    root   html;
index  index.html index.htm;
# rewrite /a.html  /b.html  redirect;
}
}

2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload

3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
[root@room9pc01 ~]# firefox  http://192.168.4.5/test


IV修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
1) 创建网页目录以及对应的页面文件：
[root@proxy ~]# echo "NORMAL" > /usr/local/nginx/html/test.html
[root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
[root@proxy ~]# echo "FIREFOX">/usr/local/nginx/html/firefox/test.html

2) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;
}
#这里，~符号代表正则匹配，*符号代表不区分大小写
if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
rewrite ^(.*)$ /firefox/$1;
}
}
#######################################
http_user_agent:手机浏览器上修改的UA标识
curl -A "UA标识" -A可以用于修改UA标识
如curl -A "firefox"
#######################################
3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload

4）客户端测试
[root@client ~]# firefox  http://192.168.4.5/test.html
[root@client ~]# curl     http://192.168.4.5/test.html


########################################
地址重写选项:
rewrite 旧地址 新地址 [选项];
last		不再读其他rewrite
break		不再读其他语句，结束请求
redirect 	临时重定向
permament 	永久重定向
########################################


=================================================================================
		         06.Operation-day03
=================================================================================

#Nginx反向代理

I.部署实施后端Web服务器

1）部署后端Web1服务器
后端Web服务器可以简单使用yum方式安装httpd实现Web服务，为了可以看出后端服务器的不同，可以将两台后端服务器的首页文档内容设置为不同的内容。
[root@web1 ~]# yum  -y  install  httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0
2）部署后端Web2服务器
[root@web2 ~]# yum  -y  install  httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce 0

II.配置Nginx服务器，添加服务器池，实现反向代理功能

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
...
http {
...

upstream webserver {  			#upstream:指定后端服务器集群
					#集群名称自定义为webserver
            server 192.168.2.100:80;	#定义集群中的具体服务器和端口
            server 192.168.2.200:80;
    }
...
server {
    listen        80;
    server_name  localhost;
        location / {
        proxy_pass http://webserver; 	#将用户的请求转发给webserver集群
    }
}

2）重启nginx服务
[root@proxy ~]# nginx -s reload		#确保nginx是启动状态

3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5     //使用该命令多次访问查看效果
[root@client ~]# curl http://192.168.4.5     //使用该命令多次访问查看效果


III.配置upstream服务器集群池属性

1）设置失败次数，超时时间，权重
weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
...
http {
...
upstream websvr {
	server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
	server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
	server 192.168.2.101 down;
        }
	#weight设置服务器权重值，默认值为1
	#max_fails设置最大失败次数
	#fail_timeout设置失败超时时间，单位为秒
	#down标记服务器已关机，不参与集群调度
...
server {
        listen        80;
        server_name  localhost;
	  location / {
	  proxy_pass http://websvr;
        }
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload

3）关闭一台后端服务器（如web1）
[root@web1 ~]# systemctl stop httpd

4）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5     //使用该命令多次访问查看效果

5）再次启动后端服务器的httpd（如web1）
[root@web1 ~]# systemctl start httpd

6）客户端再次使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5     //使用该命令多次访问查看效果


IV配置upstream服务器集群的调度算法

1）设置相同客户端访问相同Web服务器
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
...
http {
...
upstream websvr {
	ip_hash;	#通过ip_hash设置调度规则为:相同客户端访问相同服务器
	server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;
	server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;
        }
...
server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://websvr;
        }
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload

3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5     //使用该命令多次访问查看效果



#Nginx的TCP/UDP调度器

I.部署支持4层TCP/UDP代理的Nginx服务器

部署nginx服务器
编译安装必须要使用--with-stream参数开启4层代理模块。
[root@proxy ~]# yum –y install gcc pcre-devel openssl-devel//安装依赖包
[root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                           //开启SSL加密功能
> --with-stream                                    //开启4层反向代理功能
[root@proxy nginx-1.12.2]# make && make install    //编译并安装


II.配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能(ssh)

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
stream {
	upstream sshsvr {
	server 192.168.2.100:22;        //后端SSH服务器的IP和端口
	server 192.168.2.200:22;
	}
	server {
	listen 4444;          //代理服务器Nginx监听的端口(自定义)
        proxy_pass sshsvr;
        }
}


http {				//写在http{}外面
...
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload

3）客户端使用访问代理服务器测试轮询效果
[root@client ~]# ssh 192.168.4.5 -p 4444     //使用该命令多次访问查看效果


#Nginx常见问题处理

对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
如果客户端访问服务器提示“Too many open files”如何解决
如何解决客户端访问头部信息过长的问题
如何让客户端浏览器缓存数据
如何自定义返回给客户端的404错误页面
如何查看服务器状态信息
开启gzip压缩功能，提高数据传输效率
开启文件缓存功能

客户机访问此Web服务器验证效果：
使用ab压力测试软件测试并发量
编写测试脚本生成长头部信息的访问请求
客户端访问不存在的页面，测试404错误页面是否重定向

I.优化Nginx并发量

1）优化前使用ab高并发测试
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
Benchmarking 192.168.4.5 (be patient)
socket: Too many open files (24)             //提示打开文件数量过多


2）修改Nginx配置文件，增加并发量
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
worker_processes  2;                    //与CPU核心数量一致

events {
worker_connections 60000;        //每个worker最大并发连接数
}

[root@proxy ~]# nginx -s reload


3）优化Linux内核参数（最大文件数量）
[root@proxy ~]# ulimit -a                        //查看所有属性值
[root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
[root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）

永久配置最大文件数量
[root@proxy ~]# vim /etc/security/limits.conf
    ...
*               soft    	nofile            100000
*               hard    	nofile            100000
#用户或组    硬限制或软限制    需要限制的项目   	  限制的值


4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/



II.优化Nginx数据包头缓存

1）优化前，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]# cat lnmp_soft/buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL                   	//经过5000次循环后，生成一个长的URL地址栏
[root@proxy ~]# ./buffer.sh
<center><h1>414 Request-URI Too Large</h1></center>   //提示头部信息过大

2）修改Nginx配置文件，增加数据包头部缓存大小
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http {
client_header_buffer_size    1k;        //默认请求包头信息的缓存    
large_client_header_buffers  4 4k;  
//最大请求包头部信息的缓存个数4与容量4:4个4k=16k
...
}
[root@proxy ~]# nginx -s reload

3）优化后，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]# cat buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL
[root@proxy ~]# ./buffer.sh



III.浏览器本地缓存静态数据

1）使用Firefox浏览器查看缓存
在Firefox地址栏内输入about:cache将显示Firefox浏览器的缓存信息

2）清空firefox本地缓存数据

3）修改Nginx配置文件，定义对静态页面的缓存时间
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;
        
	location / {
	root   html;
	index  index.html index.htm;
        }
	
	location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
	expires        30d;            //定义客户端缓存时间为30天
	}
}
[root@proxy~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
[root@proxy ~]# nginx -s reload

4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
[root@client ~]# firefox http://192.168.4.5/day.jpg
在Firefox地址栏内输入about:cache，查看缓存数据，查看是否有图片以及过期时间



IV.自定义报错页面

1）优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
[root@client ~]# firefox http://192.168.4.5/xxxxx //访问一个不存在的页面

2）修改Nginx配置文件，自定义报错页面
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
error_page   404  /404.html;    //自定义错误页面
.. ..
[root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
Oops,No NO no page …
[root@proxy ~]# nginx -s reload


3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的404.html页面
[root@client ~]# firefox http://192.168.4.5/xxxxx //访问一个不存在的页面

4）常见http状态码
状态码		功能描述
200		一切正常
301		永久重定向
302		临时重定向
401		用户名或密码错误
403		禁止访问(客户端IP地址被拒绝)
404		文件不存在
414		请求URI头部过长
500		服务器内部错误
502		Bad Gateway


V.如何查看服务器状态信息

1）编译安装时使用--with-http_stub_status_module开启状态页面模块
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel     //安装常见依赖包
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   
> --with-http_ssl_module                           //开启SSL加密功能
> --with-stream                                    //开启TCP/UDP代理模块
> --with-http_stub_status_module               	   //开启status状态页面
[root@proxy nginx-1.12.2]# make && make install    //编译并安装

2）修改Nginx配置文件，定义状态页面
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
location /status {
                stub_status on;
        }
[root@proxy ~]# nginx

2）优化后，查看状态页面信息
[root@proxy ~]# curl  http://192.168.4.5/status
Active connections: 1 
server accepts handled requests
 10 10 3 
Reading: 0 Writing: 1 Waiting: 0
Active connections：当前活动的连接数量。
Accepts：已经接受客户端的连接总数量。
Handled：已经处理客户端的连接总数量（一般与accepts一致，除非服务器限制了连接数量）。
Requests：客户端发送的请求数量。
Reading：当前服务器正在读取客户端请求头的数量。
Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。


VI.对页面进行压缩处理

1）修改Nginx配置文件
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
http {
.. ..
gzip on;                            //开启压缩
gzip_min_length 1000;                //小文件不压缩
gzip_comp_level 4;                //压缩比率
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; 
//对文件压缩，须指定类型，参考mime.types
.. ..
}


VII.服务器内存缓存

1）如果需要处理大量静态文件，可以将文件缓存在内存，下次访问会更快。
http { 
open_file_cache        max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;	//缓存若报错直接关闭，不要提示报错
//设置服务器最大缓存2000个文件，关闭20秒内无请求的文件
//文件的有效时间是60秒，60秒后过期(不管文件有没有人访问，均过期)
//只有访问次数超过5次会被缓存
} 



=================================================================================
		         06.Operation-day04
=================================================================================

#构建memcached服务
memcached是高性能的分布式缓存服务器
用来集中缓存数据库查询结果，减少数据库访问次数
以提高动态Web应用的响应速度

1）使用yum安装软件包memcached
[root@proxy ~]# yum -y  install   memcached
[root@proxy ~]# rpm -qa memcached
memcached-1.4.15-10.el7_3.1.x86_64

2) memcached配置文件（查看即可，不需要修改）
[root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
[Service]
Type=simple
EnvironmentFile=-/etc/sysconfig/memcached	#存放ExecStart$USER等变量的配置文件
ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS

[root@proxy ~]# vim /etc/sysconfig/memcached
PORT="11211"
USER="memcached"
MAXCONN="1024"
CACHESIZE="64"
OPTIONS=""

3）启动服务并查看网络连接状态验证是否开启成功：
[root@proxy ~]# systemctl  start  memcached
[root@proxy ~]# systemctl  status  memcached
[root@proxy ~]# netstat  -anptu  |  grep memcached
tcp    0    0 0.0.0.0:11211      0.0.0.0:*      LISTEN      2839/memcached      
tcp    0    0 :::11211           :::*           LISTEN      2839/memcached     
udp    0    0 0.0.0.0:11211      0.0.0.0:*                  2839/memcached      
udp    0    0 :::11211           :::*                       2839/memcached
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted


II.使用telnet访问memcached服务器
###################################################################
验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
add myname 0 180 10		//新建，myname不存在则添加,存在则报错
set myname 0 180 10		//添加或替换变量
replace myname 0 180 10		//替换，如果myname不存在则报错
get myname			//读取变量
append myname 0 180 10		//向变量中追加数据
delete myname			//删除变量
stats				//查看状态
flush_all			//清空所有
quit                            //退出登录 
//0表示不压缩，180为数据缓存时间(单位秒)，10为需要存储的数据字节数量
##################################################################

1）使用yum安装telnet
[root@proxy ~]# yum -y install telnet

2)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。
[root@proxy ~]# telnet  192.168.4.5  11211
Trying 192.168.4.5...
Connected to 192.168.4.5.
Escape character is '^]'.
set name 0 180 3		//定义变量,变量名称为name
jun				//输入变量的值,值为jun                
STORED
get name			//获取变量的值
VALUE name 0 3			//输出结果
jun
END



#LNMP+memcached

I.部署LNMP环境

II.启动服务

III.创建PHP页面，使用PHP语言测试memcached服务

1）部署测试页面
创建PHP首页文档/usr/local/nginx/html/index.php
测试页面可以参考lnmp_soft/php_scripts/mem.php：＿＿
						↓			
[root@proxy ~]# vim /usr/local/nginx/html/test.php
<?php
$memcache=new Memcache;                //创建memcache对象
$memcache->connect('localhost',11211) or die ('could not connect!!');
$memcache->set('key','test');             //定义变量
$get_values=$memcache->get('key');        //获取变量值
echo $get_values;
?>

2）客户端测试（结果会失败）
客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
[root@client ~]# firefox http://192.168.4.5/test.php
注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。

3）为PHP添加memcache扩展
[root@proxy ~]# yum -y install  php-pecl-memcache
[root@proxy ~]# systemctl restart php-fpm

4）客户端再次测试（结果会成功显示数据结果）
[root@client ~]# firefox http://192.168.4.5/test.php


#PHP的本地Session信息

I.部署后端LNMP服务器相关软件

注意:以下部署LNMP服务器的操作，需要在两台后端服务器做相同的操作
下面我们以一台Web1服务器（192.168.2.100）为例，对Web2服务器执行相同操作即可

1）使用yum安装基础依赖包
[root@web1 ~]# yum -y install gcc openssl-devel pcre-devel zlib-devel
.. ..

2）源码安装Nginx
[root@web1 ~]# tar -xf nginx-1.12.2.tar.gz
[root@web1 ~]# cd nginx-1.12.2
[root@web1 nginx-1.12.2]#  ./configure   \
> --with-http_ssl_module 
[root@web1 nginx-1.12.2]# make && make install

3）安装MariaDB数据库
[root@web1 ~]# yum -y install  mariadb  mariadb-server  mariadb-devel

4）安装PHP（php-fpm软件包在lnmp_soft中有提供）
[root@web1 ~]# yum -y install  php  php-mysql
[root@web1 ~]# yum -y install  php-fpm-5.4.16-42.el7.x86_64.rpm

5）修改Nginx配置文件（修改默认首页与动静分离）
[root@web1 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }


II.启动LNMP服务器相关的服务

1）启动Nginx服务
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@web1 ~]# systemctl stop  httpd                //如果该服务存在，则关闭该服务
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web1 ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN      32428/nginx         
2）启动MySQL服务
[root@web1 ~]# systemctl start mariadb
[root@web1 ~]# systemctl status mariadb
3）启动PHP-FPM服务
[root@web1 ~]# systemctl start  php-fpm
[root@web1 ~]# systemctl status php-fpm
4）关闭SELinux、防火墙
[root@web1 ~]# setenforce 0
[root@web1 ~]# firewall-cmd --set-default-zone=trusted


III.部署前端Nginx调度服务器

1）使用源码安装nginx软件（如果Nginx软件包已存在可以忽略此步骤）
[root@proxy ~]# yum  -y  install   pcre-devel openssl-devel
[root@proxy ~]# tar -xf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure
[root@proxy nginx-1.12.2]# make && make install
2）修改Nginx配置文件
Nginx配置文件中，通过upstream定义后端服务器地址池，默认调度策略为轮询
使用proxy_pass调用upstream定义的服务器地址池：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
upstream webs  {
        server 192.168.2.100:80;
        server 192.168.2.200:80;
  }
 server  {
          listen       80;
          server_name  localhost;
          location  /  {
            proxy_pass http://webs;
            root   html;
            index  index.html index.htm;
          }
}
3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload

4）关闭SELinux、防火墙
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted


5）测试环境是否配置成功
浏览器访问测试页面验证。
[root@client ~]# curl  http://192.168.4.5/index.html        //查看是否有数据


IV.部署测试页面

1）部署测试页面(Web1服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 ~]# php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web1 ~]# php_scripts]# cd php-memcached-demo
[root@web1 ~]# php-memcached-demo]# cp -a  *  /usr/local/nginx/html/

2）浏览器直接访问后端服务器的测试页面（Web1服务器）。
[root@web1 ~]# firefox http://192.168.2.100            //填写账户信息
[root@web1 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web1 ~]# ls
sess_ahilcq9bguot0vqsjtd84k7244                        //注意这里的ID是随机的
[root@web1 ~]# cat sess_ahilcq9bguot0vqsjtd84k7244
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=yellow>。

3）部署测试页面(Web2服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web2 ~]# cd lnmp_soft/php_scripts/
[root@web2 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web2 php_scripts]# cd php-memcached-demo
[root@web2 php-memcached-demo]# cp -a  *  /usr/local/nginx/html/

4）浏览器直接访问后端服务器的测试页面（Web2服务器）。
[root@web2 ~]# firefox http://192.168.2.100             //填写账户信息
[root@web2 ~]# cd /var/lib/php/session/            //查看服务器本地的Session信息
[root@web2 ~]# ls
sess_qqek1tmel07br8f63d6v9ch401                        //注意这里的ID是随机的
[root@web2 ~]# cat sess_qqek1tmel07br8f63d6v9ch401    
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=pink>。

5）浏览器访问前端调度器测试（不同后端服务器Session不一致）。
推荐使用google浏览器测试。
[root@client ~]# google-chrome http://192.168.4.5
//填写注册信息后，刷新，还需要再次注册，说明两台计算机使用的是本地Session
//第二台主机并不知道你再第一台主机已经登录，第一台主机的登录信息也没有传递给第二台主机



#PHP实现session共享

I.构建memcached服务

1）安装Memcached服务（如果192.168.4.5上已经有本软件包，此步骤可以忽略）
[root@proxy ~]# yum -y install memcached

2）启动服务并查看网络连接状态验证是否开启成功：
[root@proxy ~]# systemctl restart memcached
[root@proxy ~]# netstat  -anptu  |  grep memcached
tcp    0    0 0.0.0.0:11211        0.0.0.0:*	LISTEN	      2839/memcached      
tcp    0    0 :::11211             :::*		LISTEN        2839/memcached      
udp    0    0 0.0.0.0:11211        0.0.0.0:*                  2839/memcached      
udp    0    0 :::11211             :::*			      2839/memcached

3）关闭SELinux、防火墙
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted


II.在后端LNMP服务器上部署Session共享

注意：这些操作在两台后端Web服务器上均需要执行，以下操作以Web1（192.168.2.100）服务器为例。
1）为PHP添加memcache扩展
注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
[root@web1 ~]# yum -y install  php-pecl-memcache

2）修改PHP-FPM配置文件，并重启服务
注意，因为后端两台web服务器(web1,web2)都需要修改配置文件(下面也web1为例)。
[root@web1 ~]# vim  /etc/php-fpm.d/www.conf            //修改该配置文件的两个参数
//文件的最后2行
修改前效果如下:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
//原始文件，默认定义Sessoin会话信息本地计算机（默认在/var/lib/php/session）
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
修改后效果如下:
php_value[session.save_handler] = memcache
php_value[session.save_path] = "tcp://192.168.2.5:11211"
//定义Session信息存储在公共的memcached服务器上，主机参数中为memcache（没有d）
//通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）
[root@web1 ~]# systemctl  restart  php-fpm


III.客户端测试
客户端使用浏览器访问两台不同的Web服务器。
操作步骤与练习三一致，最终可以获得相关的Session ID信息。



=================================================================================
		         06.Operation-day05
=================================================================================

#安装部署Tomcat服务器

I.部署Tomcat服务器软件(192.168.2.100/24)

1）使用RPM安装JDK环境
[root@web1 ~]# yum -y install java-1.8.0-openjdk		//安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless	//安装JDK
[root@web1 ~]# java -version					//查看JAVA版本

2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包,在lnmp_soft中有提供）
[root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
[root@web1 ~]# ls /usr/local/tomcat
bin/			//主程序目录
lib/			//库文件目录
logs/			//日志目录  
temp/			//临时目录
work/			//自动编译目录jsp代码转换servlet
conf/			//配置文件目录
webapps/		//页面目录

3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0

4）服务器验证端口信息
[root@web1 ~]# netstat -nutlp | grep java		 //查看java监听的端口
tcp   0      0  :::8080		       :::*   LISTEN	   2778/java           
tcp   0      0  ::ffff:127.0.0.1:8005  :::*   LISTEN       2778/java  
*如果检查端口时,8005端口启动慢,则使用下面的命令：用urandom替换random
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random

5）客户端浏览测试页面
[root@client ~]# firefox http://192.168.2.100:8080

II.修改Tomcat配置文件

1）创建测试JSP页面
[root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
</center>
</body>
</html>

2）重启服务
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

3）客户端浏览测试页面
[root@web1 ~]# firefox http://192.168.2.100:8080
[root@web1 ~]# firefox http://192.168.2.100:8080/test.jsp


#Tomcat部署虚拟主机

I.配置服务器虚拟主机

1）修改server.xml配置文件，创建虚拟主机
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
<Server>
   <Service>
     <Connector port=8080 />
     <Connector port=8009 />
	<Engine name="Catalina" defaultHost="localhost">
	<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
	</Host>
	<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
	</Host>
	</Engine>
</Server>
   </Service>

2）创建虚拟主机对应的页面根路径
[root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
[root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
[root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html

3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

4）客户端设置host文件，并浏览测试页面进行测试
注意：ssh远程连接时使用使用-X参数才可以！！！
[root@web2 ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@web2 ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
[root@web2 ~]# firefox http://www.b.com:8080/

II.修改www.b.com网站的首页目录为base

1）使用docBase参数可以修改默认网站首页路径
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" reloadable="true"/>
</Host>
… …
[root@web1 ~]# mkdir  /usr/local/tomcat/b/base
[root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

2）测试查看页面是否正确
[root@client ~]# firefox http://www.b.com:8080/        //结果为base目录下的页面内容

III.跳转

1）当用户访问http://www.a.com/test打开/var/www/html目录下的页面
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
</Host>
… …
[root@web1 ~]# echo "Test" > /var/www/html/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
2）测试查看页面是否正确
[root@client ~]# firefox http://www.a.com:8080/test    
//返回/var/www/html/index.html的内容
//注意，访问的端口为8080

IV.配置Tomcat支持SSL加密网站

1）创建加密用的私钥和证书文件
[root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
//-genkeypair		生成密钥对
//-alias tomcat		密钥别名
//-keyalg RSA		定义密钥算法为RSA算法
//-keystore		定义密钥文件存储在:/usr/local/tomcat/keystore

2)再次修改server.xml配置文件，创建支持加密连接的Connector
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" clientAuth="false" sslProtocol="TLS" />
//备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可

3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

4）客户端设置host文件，并浏览测试页面进行测试
[root@client ~]# vim /etc/hosts
… …
192.168.2.100      www.a.com  www.b.com
[root@client ~]# firefox https://www.a.com:8443/
[root@client ~]# firefox https://www.b.com:8443/
[root@client ~]# firefox https://192.168.2.100:8443/


V.配置Tomcat日志

1)为每个虚拟主机设置不同的日志文件
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml

<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
#从默认localhost虚拟主机中把Valve这段复制过来，修改成prefix="a_access"
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="a_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>



<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="b_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>


2）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
3）查看服务器日志文件
[root@web1 ~]# ls /usr/local/tomcat/logs/


VI.扩展实验(配置Tomcat集群)

1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
http{
    upstream toms {
        server 192.168.2.100:8080;
        server 192.168.2.200:8080;
    }
    server  {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass  http://toms;
        }
    }
}  

2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器
以下以Web1为例：
[root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
[root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat

3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

4）检验
[root@room1 ~]# google-chrome 192.168.4.5
shift+F5强制刷新几次查看效果(需要预先改网页背景颜色)

#使用Varnish加速Web

################################################
CDN:Content Delivery Network内容分发网络
*国内CDN服务提供商：腾讯,阿里
通过将服务内容分发至全网加速节点
利用全球调度系统使用户能够在就近节点获取所需内容
有效降低访问延迟，提升服务可用性
################################################

I.构建Web服务器

1）使用yum安装web软件包
[root@web1 ~]# yum  -y  install  httpd

2）启用httpd服务（注意需要关闭nginx，否则端口冲突）
[root@web1 ~]# systemctl start httpd
[root@web1 ~]# setenforce 0
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
httpd服务默认通过TCP 80端口监听客户端请求：
[root@web1 ~]# netstat  -anptu  |  grep httpd
tcp        0        0        :::80        :::*        LISTEN        2813/httpd

3）为Web访问建立测试文件
在网站根目录/var/www/html下创建一个名为index.html的首页文件：
[root@web1 ~]# cat /var/www/html/index.html 
192.168.2.100

4）测试页面是否正常（代理服务器测试后台web）
[root@proxy ~]# firefox http://192.168.2.100


II.部署Varnish缓存服务器(192.168.4.5)

1）编译安装软件(python-docutils默认光盘中没有，需要在lnmp_soft中找)
[root@proxy ~]# yum -y install gcc readline-devel	//安装软件依赖包
[root@proxy ~]# yum -y install ncurses-devel		//安装软件依赖包
[root@proxy ~]# yum -y install pcre-devel		//安装软件依赖包
[root@proxy ~]# yum -y install 
python-docutils-0.11-0.2.20130715svn7687.el7.noarch.rpm		//安装软件依赖包
[root@proxy ~]# useradd -s /sbin/nologin varnish		//创建账户
[root@proxy ~]# tar -xf varnish-5.2.1.tar.gz
[root@proxy ~]# cd varnish-5.2.1
[root@proxy varnish-5.2.1]# ./configure
[root@proxy varnish-5.2.1]# make && make install
*验证一下有没有安装成功：
[root@proxy varnish-5.2.1]# varnish（两下tab）
varnishadm   varnishhist  varnishncsa  varnishtest  
varnishd     varnishlog   varnishstat  varnishtop 
2）复制启动脚本及配置文件
[root@proxy varnish-5.2.1]# cp  etc/example.vcl   /usr/local/etc/default.vcl
3）修改代理配置文件
[root@proxy ~]# vim  /usr/local/etc/default.vcl
backend default {
     .host = "192.168.2.100";
     .port = "80";
 }
4）启动服务
 [root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl
//varnishd命令的其他选项说明如下：
//varnishd –s malloc,128M        
//定义varnish使用内存作为缓存，空间容量为128M
//varnishd –s file,/var/lib/varnish_storage.bin,1G 
//定义varnish使用文件作为缓存,空间容量为1G

5）客户端测试
客户端开启浏览器访问：
在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据
[root@client ~]# curl http://192.168.4.5

III.其他操作

1）查看varnish日志
[root@proxy ~]# varnishlog	//varnish详细日志:用于排错
[root@proxy ~]# varnishncsa	//访问日志

2）更新缓存数据：缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）
[root@proxy ~]# varnishadm
varnish> ban req.url ~ a.html	//清空a.html缓存数据，支持正则表达式
varnish> ban req.url ~ .*	//清空所有缓存数据，支持正则表达式


=================================================================================
		         06.Operation-day06
=================================================================================

#Subversion:版本控制软件Svn

I.安装Subversion服务器

1）YUM安装subversion软件
[root@web1 ~]# yum -y install subversion
[root@web1 ~]# rpm -q subversion

2)创建版本库
[root@web1 ~]# mkdir /var/svn/ 
[root@web1 ~]# svnadmin create /var/svn/project
[root@web1 ~]# ls /var/svn/project/
conf/  db/  format  hooks/  locks/  README.txt
####################################################
[root@web1 ~]# svnadmin create /var/svn/project1
[root@web1 ~]# svnadmin create /var/svn/project2
//版本库可创建多个
[root@web1 ~]# rm -rf /var/svn/project1
//可以删除
####################################################


3）本地导入初始化数据
[root@web1 ~]# cd /usr/lib/systemd/system/ 
[root@web1 ~]# svn import . file:///var/svn/project/ -m "备注信息"

4）修改配置文件，创建账户与密码

!!!所有配置文件顶头写,开头不要有空格!!!

[root@web1 ~]# vim /var/svn/project/conf/svnserve.conf
→anon-access = none
//19行，匿名无任何权限
→auth-access = write
//20行，有效账户可写
→password-db = passwd
//27行，密码文件
→authz-db = authz
//34行，ACL访问控制列表文件

[root@web1 ~]# vim /var/svn/project/conf/passwd 
[users]
→uzi = 123
//用户名和密码
→tom = 123
//用户名和密码

[root@web1 ~]# cat /var/svn/project/conf/authz 
[/]			//定义ACL访问控制,/:指该仓库的根目录如/var/svn/project
→uzi = rw		//用户对项目根路径可读可写
→tom = rw
*也可以对其它目录进行访问控制，如[/test]代表对/var/svn/project/test访问控制

5）启动服务
[root@web1 ~]# svnserve -d  -r /var/svn/project
[root@web1 ~]# netstat -nutlp |grep svnserve
tcp        0      0 0.0.0.0:3690    0.0.0.0:*    LISTEN      4043/svnserve  
*启动服务也可以用svnserve -d但客户端访问时要指定绝对路径svn://服务器IP/var/svn/project


II.客户端测试(192.168.2.200)

准备工作：提前YUM安装subversion软件
[root@web2 ~]# yum -y install subversion

1）将服务器上的代码下载到本地
[root@web2 ~]# cd /tmp				//cd到存放文档内容的目录
[root@web2 ~]# svn --username uzi --password 123 co svn://192.168.2.100/ code
//建立本地副本,从服务器192.168.2.100上co下载代码到本地code目录
//用户名tom,密码123456
-----------------------------------------------------------------------
ATTENTION!  Your password for authentication realm:
   <svn://127.0.0.1:3690> b72f45f0-bbe5-4a0c-ad4a-37f52704f0b1
can only be stored to disk unencrypted!  You are advised to configure
your system so that Subversion can store passwords encrypted, if
possible.  See the documentation for details.
You can avoid future appearances of this warning by setting the value
of the 'store-plaintext-passwords' option to either 'yes' or 'no' in
'/root/.subversion/servers'.
-----------------------------------------------------------------------
Store password unencrypted (yes/no)? yes	//提示是否保存密码

[root@web2 ~]# cd /tmp/code
[root@web2 code]# ls
[root@web2 code]# vim user.slice		//挑选任意文件修改其内容
[root@web2 code]# svn ci -m "modify user"	//将本地修改的数据同步到服务器
[root@web2 code]# svn update			//将服务器上新的数据同步到本地
[root@web2 code]# svn info	svn://192.168.2.100	//查看版本仓库基本信息
[root@web2 code]# svn log	svn://192.168.2.100	//查看版本仓库的日志
############################################################################
[root@web2 code]# echo "test" > test.sh			//本地新建一个文件
[root@web2 code]# svn ci -m "new file"		//提交失败，该文件不被svn管理
############################################################################

[root@web2 code]# svn add test.sh		//将文件或目录加入版本控制
[root@web2 code]# svn ci -m "new file"		//再次提交，成功
[root@web2 code]# svn mkdir subdir		//创建子目录
[root@web2 code]# svn rm timers.target		//使用svn删除文件
[root@web2 code]# svn ci -m "xxx"		//提交一次代码
[root@web2 code]# vim umount.target		//任意修改本地的一个文件
[root@web2 code]# svn diff			//查看所有文件的差异
[root@web2 code]# svn diff umount.target	//仅查看某一个文件的差异
[root@web2 code]# svn cat svn://192.168.2.100/reboot.target   //查看服务器文件的内容
[root@web2 code]# sed -i 'd' tmp.mount		//删除文件所有内容，但未提交
[root@web2 code]# svn revert tmp.mount		//还原tmp.mount文件
[root@web2 code]# rm -rf  *.target		//任意删除若干文件
[root@web2 code]# svn update                    //还原
[root@web2 code]# sed -i '1a #test###' tuned.service	//修改本地副本中的代码文件
[root@web2 code]# svn ci  -m  "xxx"		//提交代码
[root@web2 code]# svn merge -r7:2    tuned.service	//将文件从版本7还原到版本2

使用svn命令测试svnserver服务时可以使用的命令列表
 ＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
｜命令		｜	作用			｜
｜add		｜	添加文件		｜
｜ci		｜	提交更新(commit)	｜
｜co		｜	检出代码(checkout)	｜
｜import	｜	导入代码		｜
｜cat		｜	查看代码文件内容		｜
｜del		｜	删除文件		｜
｜diff		｜	文件对比		｜
｜info		｜	查看版本信息		｜
｜list		｜	查看文件列表		｜
｜log		｜	查看版本历史		｜
｜update	｜	更新			｜
∣mkdir		｜	创建目录		∣
 ——————————————————————————


#使用Subversion协同工作

I.多人协同工作

1）远程连接两个终端，每个人下载代码本地副本，注意web1(192.168.2.100)和web2（192.168.2.200）代表了两个不同的主机，看清楚操作是在哪一台计算机上执行！
[root@web1 ~]# cd /tmp
[root@web1 ~]# svn --username tom --password 123 co svn://192.168.2.100/ code
[root@web2 ~]# cd /tmp
[root@web2 ~]# svn --username uzi --password 123 co svn://192.168.2.100/ code
[root@web1 ~]# cd code
[root@web2 ~]# cd code

2) uzi和tom修改不同的文件
[root@web1 mycode]# sed -i "3a ###tom modify#####"  tmp.mount
[root@web1 mycode]# svn ci -m  "has modified"
[root@web2 mycode]# sed -i "3a ###uzi modify#####"  umount.target
[root@web2 mycode]# svn ci -m "has modified"
[root@web2 mycode]# svn update
[root@web1 mycode]# svn update

3）uzi和tom修改相同文件的不同行
[root@web1 mycode]# sed -i "3a ###tom modify#####" user.slice
[root@web1 mycode]# svn ci -m  "modified"
[root@web2 mycode]# sed -i "6a ###uzi modify#####" user.slice
[root@web2 mycode]# svn ci -m "modified"	//提交失败
Sending        svnserve
Transmitting file data .svn: Commit failed (details follow):
svn: File '/user.slice' is out of date（过期）
[root@web2 mycode]# svn update			//提示失败后，先更新再提交即可
[root@web2 mycode]# svn ci -m "modified"	//提交成功
Sending        user.slice
Transmitting file data .
[root@web1 mycode]# svn update

4) uzi和tom修改相同文件的相同行
[root@web1 mycode]# sed  -i  '1c [UNIT]' tuned.service
[root@web1 mycode]# svn ci -m "modified"
[root@web2 mycode]# sed  -i  '1c [unit]' tuned.service
[root@web2 mycode]# svn ci -m "modified"
Sending        tuned.service
Transmitting file data .svn: Commit failed (details follow):
svn: File '/tuned.service' is out of date(过期)
[root@web2 mycode]# svn update			//出现冲突，需要解决
Conflict discovered in 'tuned.service'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (mc) mine-conflict, (tc) theirs-conflict,
        (s) show all options:p			//选择先标记p，随后解决
[root@web2 mycode]# ls
tuned.service   tuned.service.mine        tuned.service.r10    tuned.service.r9
[root@web2 mycode]# mv tuned.service.mine tuned.service
[root@web2 mycode]# rm  -rf  tuned.service.r10 tuned.service.r9
[root@web2 mycode]# svn ci -m "modified"	//解决冲突


II.使用dump指令备份版本库数据

[root@web1 ~]# svnadmin dump /var/svn/project > project.bak	//备份
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
* Dumped revision 4.
* Dumped revision 5.
* Dumped revision 6.
* Dumped revision 7.
* Dumped revision 8.
* Dumped revision 9.
* Dumped revision 10.
* Dumped revision 11.
[root@web1 ~]# svnadmin create /var/svn/project2		//新建空仓库
[root@web1 ~]# svnadmin load /var/svn/project2 < project.bak	//还原


III.注册使用Github:https://github.com

命令行操作（需要联网的主机，如真实机）
[root@pc001 ~]# yum -y install git
[root@pc001 ~]# git clone https://github.com/账户名称/仓库名称
#clone指令用于将服务器仓库中的资料打包下载到本地
[root@pc001 ~]# cd 仓库名称
[root@pc001 ~]# 任意修改文件，或新建文件
[root@pc001 ~]# git add .
#add添加新文件
[root@pc001 ~]# git commit -m "test"
[root@pc001 ~]# git push
#commit和push实现提交代码的功能
[root@pc001 ~]# git pull
#pull更新，类似于svn update


#制作nginx的RPM包

I.安装rpm-build软件

1）安装rpm-build软件包
[root@web1 ~]# yum -y install  rpm-build

2）生成rpmbuild目录结构
[root@web1 ~]# rpmbuild -ba nginx.spec		//会报错，没有文件或目录
[root@web1 ~]# ls /root/rpmbuild		//自动生成的目录结构
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS

3）准备工作，将源码软件复制到SOURCES目录
[root@web1 ~]# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/

4）创建并修改SPEC配置文件
[root@web1 ~]# vim /root/rpmbuild/SPECS/nginx.spec 
Name:nginx        
Version:1.12.2
Release:    10
Summary: Nginx is a web server software.    
#Group
License:GPL					//GPL开源协议
URL:    www.test.com    
Source0:nginx-1.12.2.tar.gz
#BuildRequires:    
#Requires:    
%description
nginx [engine x] is an HTTP and reverse proxy server.
%prep
%setup –q					//自动解压源码包，并cd进入目录
%build
./configure
make %{?_smp_mflags}
%install
make install DESTDIR=%{buildroot}
######################################################################
cp /root/rpmbuild/SPECS/nginx.sh %{buildroot}/usr/local/nginx/    
//注意，cp非必须操作，这里是将一个脚本拷贝到安装目录，必须提前准备该文件
######################################################################
%files
%doc
/usr/local/nginx/*				//对哪些文件与目录打包
%changelog

##########################################################################
可以在nginx.spec文件中添加安装后脚本
任意空白插入
%post
useradd -s /sbin/nologin nginx	//如：可以写添加普通用户用于启动服务的脚本
然后
./configure --user=nginx	//就可以指定启动服务降权用户了
##########################################################################


II.使用配置文件创建RPM包

1）安装依赖软件包
[root@web1 ~]# yum -y install  gcc  pcre-devel zlib-devel openssl-devel

2）rpmbuild创建RPM软件包
[root@web1 ~]# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
[root@web1 ~]# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
[root@web1 ~]# rpm -qpi /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
Name        : nginx        Relocations: (not relocatable)
Version     : 1.12.2        Vendor: (none)
Release     : 10            Build Date: Mon 02 May 2016 02:30:53 AM PDT
Install Date: (not installed)            Build Host: localhost
Group       : Applications/Internet        Source RPM: nginx-1.8.0-1.src.rpm
Size        : 721243                    License: GPL
Signature   : (none)
URL         : www.nginx.org
Summary     : Nginx is a web server software.
Description :
nginx [engine x] is an HTTP and reverse proxy server.
[root@web1 ~]# rpm -qpl nginx-1.12.2-10.x86_64.rpm 
/usr
/usr/local
/usr/local/nginx
/usr/local/nginx/conf
/usr/local/nginx/conf/fastcgi.conf
/usr/local/nginx/conf/fastcgi.conf.default
/usr/local/nginx/conf/fastcgi_params
/usr/local/nginx/conf/fastcgi_params.default
/usr/local/nginx/conf/koi-utf
/usr/local/nginx/conf/koi-win
/usr/local/nginx/conf/mime.types
/usr/local/nginx/conf/mime.types.default
/usr/local/nginx/conf/nginx.conf
/usr/local/nginx/conf/nginx.conf.default
/usr/local/nginx/conf/scgi_params
/usr/local/nginx/conf/scgi_params.default
/usr/local/nginx/conf/uwsgi_params
/usr/local/nginx/conf/uwsgi_params.default
/usr/local/nginx/conf/win-utf
/usr/local/nginx/html
/usr/local/nginx/html/50x.html
/usr/local/nginx/html/index.html
/usr/local/nginx/logs
/usr/local/nginx/sbin
/usr/local/nginx/sbin/nginx

III.安装、卸载软件
[root@web1 ~]# rpm -ivh /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
[root@web1 ~]# rpm -qa |grep nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web1 ~]# curl http://127.0.0.1/


####################################
/etc/rc.local：开机执行脚本(快捷方式)
-->实际路径:/etc/rc.d/rc.local
####################################

####################################
varnish&memcached区别
varnish:缓存文件
memcached:缓存数据
####################################


=================================================================================
		         06.Operation-day07
=================================================================================
VPN:VirtualPrivateNetwork:虚拟私有网络：在公网上建立虚拟私有网络，进行加密通讯
目前主流VPN技术:GRE,PPTP,L2TP+IPSec,SSL
GRE支持Linux,支持思科路由器、交换机设备，不支持Windows,

#配置GRE VPN环境

I.启用GRE模块（client和proxy都需要操作，下面以client为例）

1）查看计算机当前加载的模块
[root@client ~]# lsmod				//显示模块列表
[root@client ~]# lsmod  | grep ip_gre		//确定是否加载了gre模块
2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre 
3）查看模块信息
[root@client ~]# modinfo ip_gre
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
alias:          netdev-gretap0
alias:          netdev-gre0
alias:          rtnl-link-gretap
alias:          rtnl-link-gre
license:        GPL
rhelversion:    7.4
srcversion:     F37A2BF90692F86E3A8BD15
depends:        ip_tunnel,gre
intree:         Y
vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C
sig_hashalgo:   sha256
parm:           log_ecn_error:Log packets received with corrupted ECN (bool)

II.Client主机创建VPN隧道

1）创建隧道
[root@client ~]# ip tunnel add tun0  mode gre remote 201.1.2.5 local 201.1.2.10
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
2）启用该隧道（类似与设置网卡up）
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up		//设置UP
[root@client ~]# ip link show
2）为VPN配置隧道IP地址
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 dev tun0
//为隧道tun0设置本地IP地址为10.10.10.10/24
//隧道对面的主机IP的隧道IP为10.10.10.5/24
[root@client ~]# ip a s				//查看IP地址
3）关闭防火墙
[root@client ~]# firewall-cmd --set-default-zone=trusted


III.Proxy主机创建VPN隧道

1）创建隧道
[root@proxy ~]# ip tunnel add tun0  mode gre  remote 201.1.2.10 local 201.1.2.5
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
2）启用该隧道（类似与设置网卡up）
[root@proxy ~]# ip link show
[root@proxy ~]# ip link set tun0 up		//设置UP
[root@proxy ~]# ip link show
2）为VPN配置隧道IP地址
[root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.5/24）
//隧道对面的主机IP的隧道IP为10.10.10.10/24
[root@proxy ~]# ip a s				//查看IP地址
3）开启路由转发、关闭防火墙
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
4)测试连通性
[root@client ~]#  ping 10.10.10.5
[root@proxy ~]#   ping 10.10.10.10


#创建PPTP VPN

I.部署VPN服务器

1）安装软件包（软件包参考lnmp_soft）
[root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
[root@proxy ~]# rpm -qc pptpd				//查询软件包配置文件
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd
2)修改配置文件
[root@proxy ~]# vim /etc/pptpd.conf
.. ..
localip 201.1.2.5					//服务器本地IP
remoteip 192.168.3.1-50					//分配给客户端的IP池
[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128					//使用MPPE加密数据
ms-dns 8.8.8.8						//DNS服务器
[root@proxy ~]# vim /etc/ppp/chap-secrets		//修改账户配置文件
jacob           *               123456      *
//用户名    服务器标记    密码    客户端
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward	//开启路由转发
3）启动服务
[root@proxy ~]# systemctl start pptpd
[root@proxy ~]# systemctl enable pptpd
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
4）翻墙设置（非必需操作）
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.5

II.客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。

I.部署VPN服务器

1）安装软件包（软件包参考lnmp_soft）
[root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
[root@proxy ~]# rpm -qc pptpd
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd
2)修改配置文件
[root@proxy ~]# vim /etc/pptpd.conf
/localip					//搜索localip有模版，复制粘贴修改
localip 201.1.2.5				//服务器本地IP
remoteip 192.168.3.1-50				//分配给客户端的IP池

[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128				//使用MPPE加密数据(本来就有,不用改)

#ms-dns 10.0.0.1
#ms-dns 10.0.0.2
ms-dns 8.8.8.8					//指定DNS服务器(只需追加写入这一行)

[root@proxy ~]# vim /etc/ppp/chap-secrets	//修改账户配置文件
# client        server		secret		IP addresses
jacob           *		123456		*
用户名    	服务器标记	密码		允许的客户端IP

[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward    //开启路由转发(默认已开启)

3）启动服务
[root@proxy ~]# systemctl start pptpd
[root@proxy ~]# systemctl enable pptpd
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
4）翻墙设置（非必需操作）
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.5

II.客户端设置

启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20

右击:网络-->属性-->设置新的连接或网络-->连接到工作区-->使用我的Internet连接(VPN)-->
我将稍后设置Internet连接-->Internet地址:201.1.2.5-->用户名:jacob-->密码:123456-->创建

右击:网络-->属性-->更改适配器设置-->右击:VPN连接-->连接



#创建L2TP+IPSec VPN

I.部署IPSec服务

1）安装软件包
[root@client ~]# yum -y install libreswan
2)新建IPSec密钥验证配置文件
[root@client ~]# cat /etc/ipsec.conf		//仅查看一下该主配置文件
include /etc/ipsec.d/*.conf			//加载该目录下的所有配置文件
[root@client ~]# cp lnmp_soft/vpn/myipsec.conf /etc/ipsec.d/
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
[root@client ~]# vim /etc/ipsec.d/myipsec.conf            
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv			//允许建立的VPN虚拟网络
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret				//加密认证
        ike=3des-sha1;modp1024			//算法
        phase2alg=aes256-sha1;modp2048		//算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10				//重要!改成服务器本机的外网IP
    leftprotoport=17/1701
    right=%any					//允许任何客户端连接
    rightprotoport=17/%any
3)创建IPSec预定义共享密钥
[root@client ~]# cat /etc/ipsec.secrets		//仅查看，不要修改该文件
include /etc/ipsec.d/*.secrets
[root@client ~]# vim /etc/ipsec.d/mypass.secrets	//新建该文件
201.1.2.10   %any:    PSK    "randpass"		//randpass为密钥
						//201.1.2.10是VPN服务器的IP
4)启动IPSec服务
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep pluto
udp        0      0 127.0.0.1:4500          0.0.0.0:*	3148/pluto          
udp        0      0 192.168.4.100:4500      0.0.0.0:*	3148/pluto          
udp        0      0 201.1.2.10:4500        0.0.0.0:*	3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*	3148/pluto          
udp        0      0 192.168.4.100:500       0.0.0.0:*	3148/pluto          
udp        0      0 201.1.2.10:500         0.0.0.0:*	3148/pluto          
udp6       0      0 ::1:500                 :::*	3148/pluto


II.部署XL2TP服务

1）安装软件包（软件包参考lnmp_soft）
[root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm
2) 修改xl2tp配置文件（修改3个配置文件的内容）
[root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf		//修改主配置文件
[global]
.. ..    
[lns default]
.. ..
ip range = 192.168.3.128-192.168.3.254			//分配给客户端的IP池
local ip = 201.1.2.10					//VPN服务器的IP地址

[root@client ~]# vim /etc/ppp/options.xl2tpd		//认证配置
require-mschap-v2					//去掉注释，强制要求认证
#crtscts						//注释或删除该行
#lock							//注释或删除该行
root@client ~]# vim /etc/ppp/chap-secrets		//修改密码文件
# client        server  	secret		IP addresses
june            *       	123456		*            
账户名称	服务器标记	密码		客户端IP
3）启动服务
[root@client ~]# systemctl start xl2tpd
[root@client ~]# netstat  -ntulp |grep xl2tpd        
udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd
4）设置路由转发，防火墙
[root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@client ~]# firewall-cmd --set-default-zone=trusted
5）翻墙设置（非必需操作）
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.200


II.客户端设置
启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20
1. 新建网络连接，输入VPN服务器账户与密码（参考:创建PPTP VPN）
   设置VPN连接的属性，预共享密钥是IPSec配置文件中填写的randpass


2. 设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：
   单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
   找到下面的注册表子项，然后单击它：
   HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
   在"编辑"菜单上，单击"新建"->"DWORD值"
   在"名称"框中，键入"ProhibitIpSec"
   在"数值数据"框中，键入"1"，然后单击"确定"
   退出注册表编辑器，然后重新启动计算机


#NTP时间同步


I.部署NTP服务:Network Time Protocol:采用分层设计,Stratum层的总数限制在15以内,包括15

1）安装软件包
[root@proxy ~]# yum -y install chrony
[root@proxy ~]# rpm -qc chrony                        //查看配置文件列表
/etc/chrony.conf
/etc/chrony.keys
.. ..
2)修改配置文件
[root@proxy ~]# cat /etc/chrony.conf
server 0.centos.pool.ntp.org iburst	//server用户客户端指向上层NTP服务器
allow 192.168.4.0/24			//允许那个IP或网络访问NTP
deny  192.168.4.1			//拒绝那个IP或网络访问NTP
local stratum 10			//设置NTP服务器的层数量
.. ..
4)启动NTP服务
[root@proxy ~]# systemctl  restart  chronyd
[root@proxy ~]# systemctl  enable  chronyd
5)设置防火墙
[root@proxy ~]# firewall-cmd --set-default-zone=trusted

II.配置客户端

1）安装软件包
[root@client ~]# yum –y install chrony
2) 修改配置文件
[root@client ~]# vim /etc/chrony.conf
server 192.168.4.5 iburst
//设置与哪台服务器同步数据,iburst参数设置重启服务后尽快同步时间
3) 将客户端时间修改为错误的时间
[root@client ~]#  date  -s  "hour:minute"	//调整时间（小时：分钟）
[root@client ~]#  date				//查看修改后的时间
4) 重启chrony与服务器同步时间
[root@client ~]# systemctl  restart  chronyd
5) 确认时间是否已经同步
[root@client ~]# date				//多执行几次查看结果


#pssh远程套件工具

I.准备工作

1）安装软件包
[root@proxy ~]# rpm -ivh  pssh-2.3.1-5.el7.noarch.rpm
2)修改/etc/hosts本地解析文件
cat /etc/hosts
… …
192.168.2.100  host1
192.168.2.200  host2
192.168.4.100  host3
… …
3)创建主机列表文件
[root@proxy ~]# cat /root/host.txt            //每行一个用户名、IP或域名
… …
root@host1
host2
host3


II.使用密码批量、多并发远程其他主机

1）语法格式
[root@proxy ~]# man pssh                    //通过man帮助查看工具选项的作用
pssh提供并发远程连接功能
-A                使用密码远程其他主机（默认使用密钥）
-i                将输出显示在屏幕
-H                设置需要连接的主机
-h                设置主机列表文件
-p                设置并发数量
-t                设置超时时间
-o dir            设置标准输出信息保存的目录
-e dir            设置错误输出信息保存的目录
-x                传递参数给ssh
2)使用密码远程多台主机执行命令，屏幕显示标准和错误输出信息
[root@proxy ~]# pssh -i  -A -H  'host1 host2 host3'   \
>  -x '-o StrictHostKeyChecking=no'   echo hello
3)使用密码远程多台主机执行命令，不显示标准和错误输出信息，通过读取host.txt读取主机信息
[root@proxy ~]# pssh -A -h host.txt   echo hello


III.使用密钥批量、多并发远程其他主机

1）生成密钥并发送密钥到其他主机
[root@proxy ~]# ssh-keygen -N  ''   -f /root/.ssh/id_rsa     //非交互生成密钥文件
[root@proxy ~]# ssh-copy-id  host1
[root@proxy ~]# ssh-copy-id  host2
[root@proxy ~]# ssh-copy-id  host3
2)使用密钥远程其他主机
[root@proxy ~]# pssh -h host.txt  echo hello
3)使用密钥远程其他主机，将标准输出信息写入到/tmp目录
[root@proxy ~]# pssh -h host.txt -o /tmp/  echo hello

IV批量、多并发拷贝数据到其他主机

1）语法格式
[root@proxy ~]# man pscp.pssh                    //通过man帮助查看工具选项的作用
pscp.pssh提供并发拷贝文件功能
-r    递归拷贝目录
其他选项基本与pssh一致
2)将本地的/etc/hosts拷贝到远程主机的/tmp目录下
[root@proxy ~]# pscp.pssh -h host.txt  /etc/hosts  / tmp
3)递归将本地的/etc目录拷贝到远程主机的/tmp目录下
[root@proxy ~]# pscp.pssh -r -h host.txt   /etc   /tmp 


V.批量、多并发从其他主机下载数据到本机

1）语法格式
[root@proxy ~]# man pslurp		//通过man帮助查看工具选项的作用
pslurp提供远程下载功能
*选项与pscp.pssh基本一致
2)将远程主机的/etc/passwd，拷贝到当前目录下，存放在对应IP下的pass文件中
[root@proxy ~]# pslurp  -h host.txt  /etc/passwd  /pass
注意：最后的pass是文件名
3)将远程主机的/etc/passwd目录，拷贝到media下，存放在对应IP下的pass文件
[root@proxy ~]# pslurp -h host.txt -L  /media   /etc/passwd   /pass


VI.批量、多并发杀死其他主机的进程

1）语法格式
[root@proxy ~]# man pnuke                    //通过man帮助查看工具选项的作用
pnuke提供远程杀死进程的功能
选项与pssh基本一致
2)将远程主机上的sleep进程杀死
[root@client ~]# sleep 100
[root@web1 ~]# sleep 100
[root@web2 ~]# sleep 100
[root@proxy ~]# pnuke  -h host.txt  sleep
3)将远程主机上的test相关脚本都杀死（如：test1,testtt,test2等等）
[root@proxy ~]# pnuke  -h host.txt  test
4)将远程主机上的test.sh脚本杀死
[root@proxy ~]# pnuke  -h host.txt  test.sh




=================================================================================
		         07.Cluster-day01
=================================================================================

集群与存储

存储
iscsi	共享存储
ceph	分布式存储

集群
配置LB集群
配置HA集群

#常见存储技术

SCSI:Small Computer System Interface
作为输入/输出接口
主要用于硬盘，光盘，磁带机等设备

DAS:Direct-Attached Storage:直连式存储
将存储设备通过SCSI接口或光纤通道直接连接到计算机上
不能实现数据与其他主机共享
占用服务器操作系统资源：CPU,IO等
相对于网络传输数据要快
数据量越大，性能越差

NAS:Network-Attached Storage:网络连接存储
专用数据存储服务器，以数据为中心，将存储设备与服务器彻底分离
集中管理数据，从而释放带宽、提高性能、降低成本、保护投资
通过TCP/IP协议访问数据
采用标准的NFS/HTTP/CIFS等


SAN:Storage Area Network:存储区域网络
通过交换机、路由器、集线器等网络设备
将磁盘阵列、磁带等存储设备与相关服务连接起来
形成高速专网网络
组成部分:路由器、交换机;接口:SCSI/FC;通信协议:SCSI/IP
#############################################
FC:Fibre Channel
与传统SCSI相比，FC数据传输速率更快，传输距离更远
设备连接支持更多，性能更稳定，安装更简易
FC主要组件：光纤线缆，HBA(光纤接口)，FC交换机
FC交换机交换拓扑
点到点:point-to-point
简单两个设备互连
已裁定的环路:arbitrated loop
可多达126个设备共享一段信道或环路
交换式拓扑:switched fabric
所有设备通过光纤交换机互连
#############################################
*IP-SAN:双绞网线+普通网络设备,用于公司内部存储
*FC-SAN:光纤线缆+光纤网络设备，用于远距离存储

ISCSI:Internet SCSI
将SCSI数据块映射为以太网数据包
基于IP storage理论的新型存储技术
将SCSI接口技术与IP网络相结合
在IP网络上构建SAN
ISCSI优势：
基于IP协议技术标准
允许网络在TCP/IP协议上传输SCSI命令
相对FC-SAN，ISCSI成本比IP-SAN更低
解决了传输速率,存储容量,兼容性,开放性,安全性问题
没有距离限制

192.168.4.50 client50
192.168.4.51 storage51 添加1块5G硬盘
配置yum源
关闭防火墙,selinux和NetworkManager服务
[root@client50 ~]# systemctl stop NetworkManager
[root@client50 ~]# systemctl disable NetworkManager

配置httpd服务
[root@client50 ~]# yum -y install httpd
[root@client50 ~]# systemctl restart httpd
[root@client50 ~]# systemctl enable httpd
[root@client50 ~]# echo test > /var/www/html/test.html
真机上测试
[root@CheungJune ~]# curl 192.168.4.50/test.html
test

配置iscsi
[root@storage51 ~]# yum -y install targetcli
[root@storage51 ~]# fdisk /dev/vdb 
[root@storage51 ~]# targetcli 
o- / ...................................................................... [...]
  o- backstores ........................................................... [...]
  | o- block ............................................... [Storage Objects: 1]
  | | o- diskb ....................... [/dev/vdb1 (0 bytes) write-thru activated]
  | |   o- alua ................................................ [ALUA Groups: 1]
  | |     o- default_tg_pt_gp ..................... [ALUA state: Active/optimized
  | o- fileio .............................................. [Storage Objects: 0]
  | o- pscsi ............................................... [Storage Objects: 0]
  | o- ramdisk ............................................. [Storage Objects: 0]
  o- iscsi ......................................................... [Targets: 1]
  | o- iqn.2018-10.cn.tedu.storage51:vdb .............................. [TPGs: 1]
  |   o- tpg1 ............................................ [no-gen-acls, no-auth]
  |     o- acls ....................................................... [ACLs: 1]
  |     | o- iqn.2018-10.cn.tedu.client50:vdb ................ [Mapped LUNs: 1]
  |     |   o- mapped_lun0 .............................. [lun0 block/diskb (rw)]
  |     o- luns ....................................................... [LUNs: 1]
  |     | o- lun0 .................. [block/diskb (/dev/vdb1) (default_tg_pt_gp)]
  |     o- portals ................................................. [Portals: 1]
  |       o- 0.0.0.0:3260 .................................................. [OK]
  o- loopback ...................................................... [Targets: 0]
[root@storage51 ~]# systemctl restart target
[root@storage51 ~]# systemctl enable target
[root@storage51 ~]# ss -nultp | grep 3260
tcp    LISTEN     0      256       *:3260                  *:*
[root@client50 ~]# vim /etc/iscsi/initiatorname.iscsi 
InitiatorName=iqn.2018-10.cn.tedu.client50:vdb
[root@client50 ~]# man iscsiadm
[root@client50 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 192.168.4.51 --discover
[root@client50 ~]# systemctl restart iscsi iscsid
[root@client50 ~]# systemctl enable iscsi iscsid
[root@client50 ~]# lsblk 
NAME	MAJ:MIN	RM	SIZE	RO	TYPE MOUNTPOINT
sda	8:0	0	5G	0	disk 
[root@client50 ~]# fdisk /dev/sda 
[root@client50 ~]# lsblk 
NAME	MAJ:MIN	RM	SIZE	RO	TYPE	MOUNTPOINT
sda	8:0	0	5G	0	disk 
[root@client50 ~]# mkfs.ext4 /dev/sda1 
[root@client50 ~]# blkid /dev/sda1 
/dev/sda1: UUID="3a672dc7-93d4-4858-a8fd-708e3b0b786a" TYPE="ext4"
[root@client50 ~]# rm -rf /var/www/html/test.html 
[root@client50 ~]# mount /dev/sda1 /var/www/html
[root@client50 ~]# echo hello > /var/www/html/test.html
[root@client50 ~]# echo test > /var/www/html/test2.html
[root@client50 ~]# ls /var/www/html/
[root@CheungJune ~]# curl 192.168.4.50/test.html
hello
[root@CheungJune ~]# curl 192.168.4.50/test2.html
test


#udev配置
udev作用:为设备提供持久，一致的名字(与主次设备编号无关)
udev程序的主配置文件/etc/udev/udev.conf
udev自定义规则文件目录/etc/udev/rules.d
自定义规则文件模板:/etc/udev/rules.d/70-persistent-ipoib.rules
			 文件名格式:1到99数字-描述信息.rules

显示系统的设备信息:
udevadm monitor -p

查看sdb的绝对路径信息
[root@client50 ~]# udevadm info -q path -n /dev/sdb
/devices/platform/host3/session1/target3:0:0/3:0:0:0/block/sdb

查看sdb的信息
[root@client50 ~]# udevadm info -q all -p /devices/platform/host3/session1/target3:0:0/3:0:0:0/block/sdb -a
将以下字段复制到自定义规则文件里
SUBSYSTEM=="block", ATTR{size}=="10485760", ATTRS{model}=="diskb           ", ATTRS{vendor}=="LIO-ORG "

[root@storage51 ~]# vim /etc/udev/rules.d/50-iscsidisk.rules
不同字段之间用, (逗号+空格)分隔开
SUBSYSTEM=="block", ATTR{size}=="10485760", ATTRS{model}=="diskb           ", ATTRS{vendor}=="LIO-ORG ", SYMLINK+="iscsi/vdb"
#######################################
操作符
==	表示匹配
!=	表示不匹配
=	指定赋予的值
+=	添加新值
:=	指定值，且不允许被替换

示例:
ACTION=="add"
KERNEL=="sd[a-z]1"
BUS=="scsi"
DRIVER!="ide-cdrom"
PROGRAM=="myapp.pl", RESULT=="test"
NAME="udisk"
SYMLINK+="iscsi/vdb"
OWNER="student"
MODE="0600"
#######################################
[root@client50 ~]# iscsiadm --mode node --targetname iqn.2018-10.cn.tedu.storage51:vdb --portal 192.168.4.51:3260 -u
[root@client50 ~]# iscsiadm --mode node --targetname iqn.2018-10.cn.tedu.storage51:vdb --portal 192.168.4.51:3260 -l
[root@client50 ~]# ls -l /dev/iscsi/vdb
lrwxrwxrwx. 1 root root 6 Oct  8 16:47 /dev/iscsi/vdb -> ../sdb

[root@client50 ~]# mount /dev/iscsi/vdb /var/www/html/
mount: /dev/sdb is write-protected, mounting read-only
mount: unknown filesystem type '(null)'
//直接挂载报错，未知文件系统类型，需要重新分区格式化

[root@client50 ~]# fdisk /dev/iscsi/vdb
Command (m for help): p
Device Boot	Start	End		Blocks	Id	System
/dev/iscsi/vdb1	2048	10485759	5241856	83	Linux
Command (m for help): d
Selected partition 1
Partition 1 is deleted
Command (m for help): n
Command (m for help): w
[root@client50 ~]# mkfs.ext4 /dev/iscsi/vdb1
[root@client50 ~]# mount /dev/iscsi/vdb /var/www/html/
[root@client50 ~]# echo test > /var/www/html/test.html
[root@CheungJune ~]# curl http://192.168.4.50/test.html
test


#iscsi多路径

准备工作:配置eth1网卡ip
[root@client50 ~]# cd /etc/sysconfig/network-scripts/
[root@client50 network-scripts]# ls
ifcfg-eth0   ifdown-isdn      ifup          ifup-plip      ifup-tunnel
ifcfg-lo     ifdown-post      ifup-aliases  ifup-plusb     ifup-wireless
ifdown       ifdown-ppp       ifup-bnep     ifup-post      init.ipv6-global
ifdown-bnep  ifdown-routes    ifup-eth      ifup-ppp       network-functions
ifdown-eth   ifdown-sit       ifup-ib       ifup-routes    network-functions-ipv6
ifdown-ib    ifdown-Team      ifup-ippp     ifup-sit
ifdown-ippp  ifdown-TeamPort  ifup-ipv6     ifup-Team
ifdown-ipv6  ifdown-tunnel    ifup-isdn     ifup-TeamPort
[root@client50 network-scripts]# cp ifcfg-eth0 ifcfg-eth1
TYPE=Ethernet
BOOTPROTO=no
NAME=eth1
DEVICE=eth1
ONBOOT=yes
IPADDR=192.168.2.50
[root@client50 network-scripts]# ifdown eth1
[root@client50 network-scripts]# ifup eth1

[root@client50 network-scripts]# scp ifcfg-eth1 192.168.4.51:/etc/sysconfig/network-scripts/ifcfg-eth1
[root@storage51 network-scripts]# cd /etc/sysconfig/network-scripts/
[root@storage51 network-scripts]# vim ifcfg-eth1
TYPE=Ethernet
BOOTPROTO=no
NAME=eth1
DEVICE=eth1
ONBOOT=yes
IPADDR=192.168.2.51

排除udev的影响
[root@client50 ~]# mv /etc/udev/rules.d/50-iscsidisk.rules /etc/udev/rules.d/50-iscsidisk.rules.bck

把client50所有硬盘删除剩下系统默认存在的硬盘
[root@client50 ~]# lsblk 
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sr0            11:0    1 1024M  0 rom  
vda           252:0    0   20G  0 disk 
├─vda1        252:1    0    1G  0 part /boot
└─vda2        252:2    0   19G  0 part 
  ├─rhel-root 253:0    0   17G  0 lvm  /
  └─rhel-swap 253:1    0    2G  0 lvm  [SWAP]

通过两个不同网段去发现iscsi网络磁盘
[root@client50 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 192.168.4.51 --discover
192.168.4.51:3260,1 iqn.2018-10.cn.tedu.storage51:vdb
[root@client50 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 192.168.2.51 --discover
192.168.2.51:3260,1 iqn.2018-10.cn.tedu.storage51:vdb

通过两个不同网段去登录iscsi网络磁盘
[root@client50 ~]# iscsiadm --mode node --targetname iqn.2018-10.cn.tedu.storage51:vdb --portal 192.168.4.51:3260 -l
[root@client50 ~]# lsblk 
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0    5G  0 disk 

[root@client50 ~]# iscsiadm --mode node --targetname iqn.2018-10.cn.tedu.storage51:vdb --portal 192.168.2.51:3260 -l
[root@client50 ~]# lsblk 
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda             8:0    0    5G  0 disk 
sdb             8:16   0    5G  0 disk 

安装多路径服务的包
[root@client50 ~]# yum -y install device-mapper-multipath
创建配置文件，自动生成配置文件
[root@client50 ~]# mpathconf --user_friendly_names n	#不用用户名验证,要用wwid验证
配置文件路径
[root@client50 ~]# ls /etc/multipath.conf 

查看磁盘wwid
[root@client50 ~]# /usr/lib/udev/scsi_id -g /dev/sda
360014057108497034c44ba6b057b3d7b
[root@client50 ~]# /usr/lib/udev/scsi_id -g /dev/sdb
360014057108497034c44ba6b057b3d7b

新开终端，修改配置文件
[root@client50 ~]# vim /etc/multipath.conf 
shift+G在末尾添加
multipaths {
        multipath{
                wwid "360014057108497034c44ba6b057b3d7b"//复制粘贴前面的wwid
                alias mpath		//自定义名称
        }
}
重启multipathd服务
[root@client50 ~]# systemctl restart multipathd
[root@client50 ~]# systemctl enable multipathd

查看多路径设备
[root@client50 ~]# ls /dev/mapper/
control  mpath  rhel-root  rhel-swap
[root@client50 ~]# ls /dev/mapper/mpath 
/dev/mapper/mpath
重新加载多路径信息
[root@client50 ~]# multipath -rr
reload: mpath (360014057108497034c44ba6b057b3d7b) undef LIO-ORG ,diskb           
size=5.0G features='0' hwhandler='0' wp=undef
|-+- policy='service-time 0' prio=1 status=undef
| `- 5:0:0:0 sda 8:0  active ready running
`-+- policy='service-time 0' prio=1 status=undef
  `- 6:0:0:0 sdb 8:16 active ready running
查看多路径信息
[root@client50 ~]# multipath -ll
mpath (360014057108497034c44ba6b057b3d7b) dm-2 LIO-ORG ,diskb           
size=5.0G features='0' hwhandler='0' wp=rw
|-+- policy='service-time 0' prio=1 status=enabled
| `- 5:0:0:0 sda 8:0  active ready running
`-+- policy='service-time 0' prio=1 status=enabled
  `- 6:0:0:0 sdb 8:16 active ready running
断掉一张网卡
[root@client50 ~]# ifdown eth1
[root@client50 ~]# multipath -rr
[root@client50 ~]# multipath -ll
mpath (360014057108497034c44ba6b057b3d7b) dm-2 LIO-ORG ,diskb           
size=5.0G features='0' hwhandler='0' wp=rw
|-+- policy='service-time 0' prio=1 status=active
| `- 5:0:0:0 sda 8:0  active ready running
`-+- policy='service-time 0' prio=0 status=enabled
  `- 6:0:0:0 sdb 8:16 failed faulty running
重新启动网卡
[root@client50 ~]# ifup eth1
[root@client50 ~]# multipath -rr
[root@client50 ~]# multipath -ll
mpath (360014057108497034c44ba6b057b3d7b) dm-2 LIO-ORG ,diskb           
size=5.0G features='0' hwhandler='0' wp=rw
|-+- policy='service-time 0' prio=1 status=enabled
| `- 5:0:0:0 sda 8:0  active ready running
`-+- policy='service-time 0' prio=1 status=enabled
  `- 6:0:0:0 sdb 8:16 active ready running

##############################################
激活网卡
[root@client56 ~]# /etc/init.d/network restart 
ONBOOT=yes		网卡配置文件需开启此项

net-tools提供ifconfig
ifup
ifdown
##############################################

##################################################
iscsi扩展
不可以多台主机同时挂载:
由于ext4是本地文件系统会造成无法同步多台主机之间的文件
可用gfs文件系统解决该问题
iscsi适合HA集群，不适合LB集群
##################################################


NFS环境准备
web52:192.168.4.52
web53:192.168.4.53

文件系统类型
本地文件系统:EXT3/4,SWAP,NTFS		--本地磁盘
伪文件系统:/proc,/sys			--内存空间
网络文件系统:NFS(NetworkFileSystem)	--网络存储空间

#配置NFS服务器
主要软件包:nfs-utils,rpcbind
系统服务脚本:nfs,rpcbind
主配置文件:/etc/exports

[root@storage51 ~]# fdisk /dev/vdc 
[root@storage51 ~]# mkfs.ext4 /dev/vdc
[root@storage51 ~]# mkdir /sharedir
[root@storage51 ~]# chmod o+w /sharedir/
[root@storage51 ~]# mount /dev/vdc1 /sharedir/
[root@storage51 ~]# vim /etc/exports
/sharedir *(rw)
[root@storage51 ~]# systemctl restart nfs-server.service 
[root@storage51 ~]# echo test > /sharedir/test.html

[root@web52 ~]# showmount -e 192.168.4.51
Export list for 192.168.4.51:
/sharedir 192.168.4.0/24
[root@web52 ~]# mount 192.168.4.51:/sharedir /var/www/html/
[root@web52 ~]# ls /var/www/html/
lost+found  test.html

[root@web53 ~]# showmount -e 192.168.4.51
Export list for 192.168.4.51:
/sharedir 192.168.4.0/24
[root@web53 ~]# mount 192.168.4.51:/sharedir /var/www/html/
[root@web53 ~]# ls /var/www/html/
lost+found  test.html

=================================================================================
		         07.Cluster-day02
=================================================================================

#集群
概念：用一组服务器集中在一起，提供同一种的服务，在客户端卡看来像是只有一个服务器
优势：低成本且性能，可靠性，灵活性方面相对收益较高
目的：提高性能，降低成本，提高可扩展性，增强可靠性
分类：
高性能计算集群HPC--------用于专业领域，互联网企业不用
负载均衡集群LB-----------客户端负载在计算机集群中尽可能平均分摊
高可用集群HA-------------避免单点故障，当一个系统发生故障时，可以快速迁移
*任务调度是LB集群系统中的核心技术

#LVS:LinuxVirtualSystem:Linux虚拟服务器

LVS集群组成
前端	负载均衡层：由一台或多台负载调度器构成
中间	服务器群组层：由一组实际运行应用服务的服务器组成
底端	数据共享存储层：提供共享存储空间的存储区域

LVS术语
RealServer	真实服务器：真正提供应用服务的服务器
DirectorServer	调度服务器：将负载分发到RealServer的服务器
VIP		虚拟IP地址：公布给用户访问的虚拟IP地址（调度服务器的IP）
RIP		真实IP地址：集群节点上使用的IP地址
DIP		集群节点上使用的IP地址

LVS工作模式
VS/NAT模式	通过网络地址转换实现的虚拟服务器，大并发访问时，调度器的性能成为瓶颈
VS/DR模式	直接使用路由技术实现虚拟服务器，节点服务器需要配置VIP，注意MAC地址广播
VS/TUN模式	通过隧道方式实现虚拟服务器（几乎不用，仅当服务器不在同一个网段才用到）

负载均衡调度算法
LVS共有10种调度算法
常用调度算法有4种
轮询		RR:RoundRobin:将客户端请求平均分发到RealServer
加权轮询	WRR:WeightedRoundRobin根据RealServer权重值进行轮询调度
最少连接	LC:LeastConnections选择连接数最少的服务器
加权最少连接	WLC:WeightedLeastConnections根据RealServer权重值进行最少连接


#NAT模式

实验环境准备:
eth0-4.0网段模拟私网
eth1-2.0网段模拟公网

client:
client50	eth1:192.168.2.50	网关地址:192.168.2.54

proxy server:	开启内核路由转发功能，使其能够收发不同网段的IP包
proxy54		eth0:192.168.4.54
		eth1:192.168.2.54

real server:
web52		eth0:192.168.4.52	网关地址:192.168.4.54	开启httpd
web53		eth0:192.168.4.53	网关地址:192.168.4.54	开启httpd

storage server
storage51	eth0:192.168.4.51	通过NFS共享存储网页文件

分发器proxy54开启内核路由转发功能
[root@web52 ~]# sysctl -p

[root@proxy54 ~]# sysctl -a | grep ip_forward
net.ipv4.ip_forward = 1

[root@proxy54 ~]# vim /etc/sysctl.conf 
net.ipv4.ip_forward = 1

[root@web52 ~]# sysctl -p
net.ipv4.ip_forward = 1

web52和web53设置网关
配置web52的网关
查看网关
[root@web52 ~]# route -n
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.4.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
禁用NetworkManager否则会影响网关配置
[root@web52 ~]# systemctl stop NetworkManager
配置网关
[root@web52 ~]# route add default gw 192.168.4.54
[root@web52 ~]# route -n
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.4.54    0.0.0.0         UG    0      0        0 eth0
192.168.4.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
配置web53的网关
[root@web53 ~]# systemctl stop NetworkManager
[root@web53 ~]# route add default gw 192.168.4.54
root@web53 ~]# route -n
如果配错了则删除重新配
[root@web53 ~]# route del default gw 192.168.4.54

客户端client50配置网关
[root@client50 ~]# systemctl stop NetworkManager
[root@client50 ~]# route add default gw 192.168.2.54


配置分发器proxy54
安装提供lvs服务的软件包
[root@proxy54 ~]# yum -y install ipvsadm
查看一下服务，不需要启动
[root@proxy54 ~]# systemctl status ipvsadm
● ipvsadm.service - Initialise the Linux Virtual Server
   Loaded: loaded (/usr/lib/systemd/system/ipvsadm.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
查看help帮助和man帮助手册
[root@proxy54 ~]# man ipvsadm
[root@proxy54 ~]# ipvsadm --help

创建虚拟服务
[root@proxy54 ~]# ipvsadm -ln
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
[root@proxy54 ~]# ipvsadm -A -t 192.168.2.54:80	-s rr
		#-A:添加虚拟服务器,-t:tcp协议,:80代表http协议,-s:指定调度算法

添加realserver
[root@proxy54 ~]# ipvsadm -a -t 192.168.2.54:80 -r 192.168.4.52:80 -m
[root@proxy54 ~]# ipvsadm -a -t 192.168.2.54:80 -r 192.168.4.53:80 -m
		#-a:添加realserver,-r:realserver的ip,-m:代表NAT模式

永久保存配置:把策略保存到服务配置文件
[root@proxy54 ~]# vim /etc/sysconfig/ipvsadm-config 
IPVS_SAVE_ON_RESTART="yes"

[root@proxy54 ~]# ipvsadm -S > /etc/sysconfig/ipvsadm

查看配置信息
[root@proxy54 ~]# ipvsadm -ln
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.2.54:80 rr
  -> 192.168.4.52:80              Masq    1      0          0         
  -> 192.168.4.53:80              Masq    1      0          0    
				  #Masq代表NAT模式
查看详细状态信息
[root@proxy54 ~]# ipvsadm -ln --stats
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port               Conns   InPkts  OutPkts  InBytes OutBytes
  -> RemoteAddress:Port
TCP  192.168.2.54:80                     0        0        0        0        0
  -> 192.168.4.52:80                     0        0        0        0        0
  -> 192.168.4.53:80                     0        0        0        0        0

实时监控状态
[root@proxy54 ~]# watch -n 1 ipvsadm -ln --stats

如果配错，删除所有配置信重新配置
[root@proxy54 ~]# ipvsadm -C

管理集群
删除realserver
[root@proxy54 ~]# ipvsadm -d 192.168.2.54:80 -r 192.168.4.53
添加realserver
[root@proxy54 ~]# ipvsadm -a 192.168.2.54:80 -r 192.168.4.53:80 -m
修改调度算法
[root@proxy54 ~]# ipvsadm -E -t 192.168.2.54:80 -s wrr
修改realserver权重值（默认为1）
[root@proxy54 ~]# ipvsadm -e -t 192.168.2.54:80 -w 3 -r 192.168.4.52:80 -m
stats计数器清零
[root@proxy54 ~]# ipvsadm -Z
[root@proxy54 ~]# ipvsadm -ln --stats
Prot LocalAddress:Port               Conns   InPkts  OutPkts  InBytes OutBytes
  -> RemoteAddress:Port
TCP  192.168.2.54:80                     0        0        0        0        0
  -> 192.168.4.52:80                     0        0        0        0        0
  -> 192.168.4.53:80                     0        0        0        0        0
把服务设置成开机启动
[root@proxy54 ~]# systemctl enable ipvsadm


#DR模式

实验环境准备:

client:
client50	eth1:192.168.4.50	

proxy server:	
proxy54		eth0:192.168.4.54

real server:
web52		eth0:192.168.4.52	开启httpd
web53		eth0:192.168.4.53	开启httpd

storage server
storage51	eth0:192.168.4.51	通过NFS共享存储网页文件

配置分发器proxy54
在eth0接口上绑定vip地址192.168.4.253
[root@proxy54 ~]# ifconfig eth0:1 192.168.4.253

创建集群
创建虚拟服务
[root@proxy54 ~]# ipvsadm -A -t 192.168.4.253:80 -s rr
				#这里填写vip

添加realserver
[root@proxy54 ~]# ipvsadm -a -t 192.168.4.253:80 -r 192.168.4.52:80 -g
						    #-g:代表DR模式
[root@proxy54 ~]# ipvsadm -a -t 192.168.4.253:80 -r 192.168.4.53:80
						    #不指定模式选项默认为DR模式

保存配置
[root@proxy54 ~]# ipvsadm -S > /etc/sysconfig/ipvsadm-config 

查看状态信息
[root@proxy54 ~]# ipvsadm -ln
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.253:80 rr
  -> 192.168.4.52:80              Route   1      0          0         
  -> 192.168.4.53:80              Route   1      0          0    

配置realserver:两台都要配置
修改网络接口的内核参数
临时修改
[root@web52 ~]# cd /proc/sys/net/ipv4/conf/
[root@web52 conf]# ls
all  default  eth0  eth1  eth2  eth3  lo  virbr0  virbr0-nic
[root@web52 conf]# echo 1 > lo/arp_ignore 
[root@web52 conf]# echo 2 > lo/arp_announce
[root@web52 conf]# echo 1 > all/arp_ignore 
[root@web52 conf]# echo 2 > all/arp_announce
设置开机自动修改
[root@web52 conf]# chmod +x /etc/rc.d/rc.local
[root@web52 conf]# vim /etc/rc.d/rc.local
echo 1 > /proc/sys/net/ipv4/conf/lo/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/lo/arp_announce
echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce
或
[root@web52 conf]# vim /etc/bashrc
echo 1 > /proc/sys/net/ipv4/conf/lo/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/lo/arp_announce
echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce

在lo接口绑定vip地址192.168.4.253
[root@web52 ~]# ifconfig lo:1 192.168.4.253/32
[root@web52 ~]# ifconfig lo:1
###################################
若配置错误会导致无法远程连接
需要去到本机，重新绑定成正确配置即可
###################################
设置开机自动绑定
[root@web52 conf]# vim /etc/rc.local
ifconfig lo:1 192.168.4.253/32

运行网站服务并编写网页文件

测试
另开终端
[root@proxy54 ~]# watch -n 1 ipvsadm -ln --stats
[root@client50 ~]# curl 192.168.4.253/test.html		#多运行几次这条命令看效果
可以看到OutPkts参数为0说明调度服务器只是接受数据，没有返回数据

#################################################
LVS扩展
LVS服务做LB集群时，不能对realserver服务进行健康检查
解决思路:编写脚本进行监控(配合计划任务)
checklvs.sh
#!/bin/bash
当realserver的80端口不是开放状态时就在本机执行删除realserver的命令
如ipvsadm -d -t 192.168.4.253:80 -r 192.168.4.xx
当检测到80端口是开放状态之后，再把删除的realserver重新添加到虚拟服务里

如何检测80端口是否为开放状态:
yum -y install nmap
nmap -sS -n -p 80 web服务器ip

[root@proxy54 ~]# nmap -sS -n -p 80 192.168.4.52 | grep open
有输出则为开启状态
无输出则为关闭状态
#################################################

=================================================================================
		         07.Cluster-day03
=================================================================================
实验准备
client		client50	4.50
LVS/DR		proxy54		vip:4.253,dip:4.54
realserver	web52&web53	web52'rip:4.52,web53'rip:4.53
web55		eth0-4.55	keepalive高可用集群-主
web57		eth0-4.57	keepalive高可用集群-备
host56		eth0-4.56	备用DR

#keepalived配置HA集群
*keepalived 可以解决任何单点故障

mainweb55和bckweb57配置提供网站服务的HA集群
配置步骤
1.mainweb55和bckweb57配置httpd服务并编写测试网页文件

2.mainweb55和bckweb57安装keepalived软件
[root@mainweb55 ~]# yum -y install keepalived 
[root@bckweb57 ~]# yum -y install keepalived

3.在mainweb55和bckweb57上修改配置文件(vip地址:192.168.4.252)
3.1.配置主服务器mainweb55的配置文件
vim /etc/keepalived/keepalived.conf
命令模式:35回车,光标跳到35行，1000dd删除不需要的配置
vrrp_strict		-->	#vrrp_strict
vrrp_instance VI_1 {	-->	vrrp_instance webha {	#自定义集群名称
state MASTER		-->	state MASTER		#主服务器默认MASTER保持不变
priority 100		-->	priority 150		#把mainweb55的优先级调高
							#高于bckweb57默认的100
auth_pass 1111		-->	auth_pass 123456	#修改认证密码

virtual_ipaddress {		
192.168.200.16			virtual_ipaddress {
192.168.200.17		-->	192.168.4.252		#指定vip地址
192.168.200.18			    }
    }

3.2.配置备用服务器
vim /etc/keepalived/keepalived.conf
命令模式:35回车,光标跳到35行，1000dd删除不需要的配置
vrrp_strict		-->	#vrrp_strict
vrrp_instance VI_1 {	-->	vrrp_instance webha {	#集群名称与mainweb55一致
state MASTER		-->	state BACKUP		#状态改成BACKUP
priority 100		-->	priority 100		#优先级保持默认不修改
auth_pass 1111		-->	auth_pass 123456	#认证密码与mainweb55一致

virtual_ipaddress {		
192.168.200.16			virtual_ipaddress {
192.168.200.17		-->	192.168.4.252		#指定vip地址
192.168.200.18			    }
    }

4.启动keepalived服务(先启动主服务器)
[root@mainweb55 ~]# systemctl start keepalived
[root@mainweb55 ~]# systemctl enable keepalived
[root@bckweb57 ~]# systemctl start keepalived
[root@bckweb57 ~]# systemctl enable keepalived

5.查看vip地址
[root@mainweb55 ~]# ip addr show | grep 192.168.4.252	#优先级高的才能获得vip
    inet 192.168.4.252/32 scope global eth0
[root@bckweb57 ~]# ip addr show | grep 192.168.4.252


#综合应用:配置LVS调度器--HA集群
需求:把proxy56配置为备用的LVS调度器，当proxy54宕机后
客户端主机仍然可以连接vip地址192.168.4.253访问网站集群

配置步骤
在proxy56安装ipvsadm
[root@proxy56 ~]# yum -y install ipvsadm

删除proxy54已有的ipvsadm策略，ifconig eth0:1 vip地址，/etc/rc.local里的ifconfig....
[root@proxy54 ~]# ipvsadm -C
[root@proxy54 ~]# ipvsadm -S > /etc/sysconfig/ipvsadm
[root@proxy54 ~]# vim /etc/rc.local 

分别在proxy54和proxy56安装keepalived

修改proxy54(主分发器)的配置文件
#vrrp_strict
vrrp_instance lvsha {
priority 150
auth_pass 123123
virtual_ipaddress {192.168.4.253}
保留一个virtual_server删除其他配置，然后修改成:
virtual_server 192.168.4.253 80 {
   delay_loop 6
   lb_algo rr 
   lb_kind DR
   #persistence_timeout 50
   protocol TCP
   connect_timeout 3
   nb_get_retry 3
   delay_before_retry 3
   
real_server 192.168.4.52 80 {
       weight 1
    }   
real_server 192.168.4.53 80 {
       weight 1
    }
}
[root@proxy54 ~]# systemctl restart keepalived.service 
[root@proxy54 ~]# systemctl enable keepalived.service 
[root@proxy54 ~]# ipvsadm -ln
[root@proxy54 ~]# ip addr show | grep 192.168.4.253

修改proxy56(备用分发器)的配置文件
[root@proxy54 ~]# scp /etc/keepalived/keepalived.conf 192.168.4.56:/etc/keepalived/keepalived.conf
[root@proxy56 ~]# vim /etc/keepalived/keepalived.conf 
state BACKUP
priority 100
[root@proxy56 ~]# systemctl restart keepalived.service 
[root@proxy56 ~]# systemctl enable keepalived.service 
[root@proxy56 ~]# ipvsadm -ln
[root@proxy56 ~]# ip addr show | grep 192.168.4.253

扩展知识:配置keepalived对lvs服务的realserver做健康性检查,当某台realserver宕机则跳过它
virtual_server 192.168.4.253 80 {
    delay_loop 6
    lb_algo rr 
    lb_kind DR 
    #persistence_timeout 50
    protocol TCP
    
    real_server 192.168.4.52 80 {
        weight 1
        TCP_CHECK {			#添加TCP_CHECK配置
            connect_timeout 3		#将上面三行剪切回来
            nb_get_retry 3
            delay_before_retry 3
        }   
    }       
    real_server 192.168.4.53 80 {
        weight 1
        TCP_CHECK {
            connect_timeout 3
            nb_get_retry 3
            delay_before_retry 3
        }
    }


#HaProxy配置LB集群(基于传输层:端口)
*HaProxy既可以做基于传输层:端口的LB集群,还可以做基于应用层的LB集群
还可以做健康性检查，相对于LVS功能更加强大，企业里应用的更多

HaProxy工作模式
mode	http	客户端请求被深度分析后再发往服务器
mode	tcp	客户端与服务器之间建立会话，不检查第七层信息
mdoe	health	仅做健康状态检查，不建议使用

实验准备
[root@mainweb55 ~]# systemctl stop keepalived.service 
[root@mainweb55 ~]# systemctl disable keepalived.service 
[root@mainweb55 ~]# systemctl status httpd
[root@mainweb55 ~]# ls /var/www/html/

[root@bckweb57 ~]# systemctl stop keepalived.service 
[root@bckweb57 ~]# systemctl disable keepalived.service 
[root@bckweb57 ~]# systemctl status httpd
[root@bckweb57 ~]# ls /var/www/html/

[root@proxy56 ~]# systemctl stop keepalived.service 
[root@proxy56 ~]# systemctl disable keepalived.service 

在proxy56上配置HaProxys
安装HaProxy软件包
[root@proxy56 ~]# yum -y install haproxy
查看服务状态
[root@proxy56 ~]# systemctl status haproxy.service 
● haproxy.service - HAProxy Load Balancer
   Loaded: loaded (/usr/lib/systemd/system/haproxy.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
修改配置文件
[root@proxy56 ~]# vim /etc/haproxy/haproxy.cfg 
#############################################################
global:全局设置进程参数，总是具有最高优先级
default:为后续的其他部分设置缺省参数，缺省参数可以被后续部分重置
listen:把frontend和backend结合到一起的完整声明
frontend和backend用于配置基于应用层的负载均衡集群
#############################################################
从60行frontend开始后面全部删除
最后一行添加:
stats uri /admin

listen weblb 192.168.4.56:80
       cookie SERVERID rewrite
       balance roundrobin
       server web1 192.168.4.55:80 cookie app1inst1 check inter 2000 rise 2 fall 5
       server web1 192.168.4.57:80 cookie app2inst2 check inter 2000 rise 2 fall 5
#app1inst1:自定义cookie名称，2000:2000ms为连接超时时间
#2:每隔2ms连一次，5:连接5次都失败则定义为断开连接
[root@proxy56 ~]# systemctl restart haproxy.service
[root@proxy56 ~]# systemctl enable haproxy.service

访问uri查看健康状况日志
[root@proxy56 ~]# firefox http://192.168.4.56/admin

在client50访问192.168.4.56查看负载均衡效果
[root@client50 ~]# curl  http://192.168.4.56/test.html

=================================================================================
		         07.Cluster-day04
=================================================================================
#################################################################################
实验环境准备
client:eth0-192.168.4.50
node1:eth0-192.168.4.51
node2:eth0-192.168.4.52
node3:eth0-192.168.4.53

I.安装前准备
1）物理机为所有节点配置yum源，注意所有的虚拟主机均需要挂载安装光盘
[root@June ~]# yum -y install vsftpd
[root@June ~]# mkdir  /var/ftp/ceph
[root@June ~]# mount -o loop rhcs2.0-rhosp9-20161113-x86_64.iso  /var/ftp/ceph
或
[root@June ~]# vim /etc/fstab 
rhcs2.0-rhosp9-20161113-x86_64.iso /var/ftp/ceph iso9660 defaults 0 0
[root@June ~]# mount -a

[root@June ~]# systemctl  restart  vsftpd

2）修改所有节点yum配置（以node1为例）
[root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
[mon]
name=mon
baseurl=ftp://192.168.4.254/ceph/rhceph-2.0-rhel-7-x86_64/MON
gpgcheck=0
[osd]
name=osd
baseurl=ftp://192.168.4.254/ceph/rhceph-2.0-rhel-7-x86_64/OSD
gpgcheck=0
[tools]
name=tools
baseurl=ftp://192.168.4.254/ceph/rhceph-2.0-rhel-7-x86_64/Tools
gpgcheck=0

3）配置无密码连接:node1是管理集群的服务器，所以只需在node1上创建传输密钥
[root@node1 ~]# ssh-keygen   -f /root/.ssh/id_rsa    -N ''
[root@node1 ~]# for i in 50  51  52  53		//注意:也要发给自己
> do
> ssh-copy-id  192.168.4.$i
> done

4）修改/etc/hosts并同步到所有主机
[root@node1 ~]# cat /etc/hosts
192.168.4.10    client
192.168.4.11    node1
192.168.4.12    node2
192.168.4.13    node3
[root@node1 ~]# for i in 50  51  52  53
> do
> scp  /etc/hosts  192.168.2.$i:/etc/
> done

II.配置NTP时间同步
1）创建NTP服务器。
[root@client ~]#  yum -y install chrony
[root@client ~]#  cat /etc/chrony.conf
server 0.centos.pool.ntp.org iburst
allow 192.168.4.0/24
local stratum 10
[root@client ~]# systemctl  restart  chronyd

2）其他所有节点与NTP服务器同步时间（以node1为例）。
[root@node1 ~]#  cat /etc/chrony.conf
server 192.168.4.10   iburst
[root@node1 ~]# systemctl  restart  chronyd


III.物理机上为node1-3虚拟机准备3块10G磁盘
#################################################################################
##分布式存储##
两款分布式存储主流软件
FastDFS	阿里巴巴开发，软件作者:余庆
Ceph	原来是开源，目前被红帽收购


#部署CEPH集群


1.1创建集群-->node1:
安装CEPH集群管理工具
[root@node1 ~]# yum -y install ceph-deploy
查看帮助手册
[root@node1 ~]# ceph-deploy --help
创建工作目录
[root@node1 ~]# mkdir /root/ceph-cluster
创建Ceph集群配置(所有节点都为mon)
[root@node1 ~]# cd /root/ceph-cluster/
[root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
给所有节点安装Ceph软件包
[root@node1 ceph-cluster]# ceph-deploy install node1 node2 node3
初始化所有节点的mon服务
[root@node1 ceph-cluster]# ceph-deploy mon create-initial
//不需要指定主机，因为创建Ceph集群的配置文件中已经有了
//所以要求主机名解析必须对，否则连接不到对应主机

1.2创建OSD
创建OSD-->node1,node2,node3:(以node1为例)
*ext2/3/4:日志文件系统,格式化成这种文件系统会自动划分一部分空间用于储存日志
1.2.1创建日志盘(将vdb分成50%+50%分别作为vdc和vdd的日志盘)
[root@node1 ~]# parted /dev/vdb mklabel gpt
[root@node1 ~]# parted /dev/vdb mkpart primary 1M 50%                     
[root@node1 ~]# parted /dev/vdb mkpart primary 50% 100%                   
[root@node1 ~]# lsblk 
[root@node1 ~]# chown ceph.ceph /dev/vdb*
[root@node1 ~]# echo " chown ceph.ceph /dev/vdb* " >> /etc/rc.local 
[root@node1 ~]# chmod +x /etc/rc.d/rc.local 
初始化清空磁盘数据-->node1:
[root@node1 ceph-cluster]# cd /root/ceph-cluster/
[root@node1 ceph-cluster]# ceph-deploy disk zap node1:vdc node1:vdd
[root@node1 ceph-cluster]# ceph-deploy disk zap node2:vdc node2:vdd
[root@node1 ceph-cluster]# ceph-deploy disk zap node3:vdc node3:vdd
创建OSD存储空间-->ndoe1:
[root@node1 ceph-cluster]# ceph-deploy osd create node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2
[root@node1 ceph-cluster]# ceph-deploy osd create node2:vdc:/dev/vdb1 node2:vdd:/dev/vdb2
[root@node1 ceph-cluster]# ceph-deploy osd create node3:vdc:/dev/vdb1 node3:vdd:/dev/vdb2
//创建osd存储设备，vdc为集群提供存储空间，vdb1提供日志存储
//一个存储设备对应一个日志设备，日志需要SSD，不需要很大
 
1.3验证
查看集群状态-->node1:
[root@node1 ceph-cluster]# ceph -s
     health HEALTH_OK		
     monmap e1: 3 mons at {node1=192.168.4.51:6789/0,node2=192.168.4.52:6789/0,node3=192.168.4.53:6789/0}		
//健康状态ok，且看到node1-3即为集群创建成功


#块存储集群
查看存储池(默认有一个rbd池)
[root@node1 ~]# ceph osd lspools
0 rbd,
创建镜像，查看镜像
[root@node1 ~]# rbd create rbd/image1 --image-feature layering --size 10G
//image1为自定义名称，--image-feature layering指定镜像为层级
[root@node1 ~]# rbd create image2 --image-feature layering --size 15G
//创建镜像时不指定存储池则默认属于rbd存储池
[root@node1 ~]# rbd list		//列出镜像
[root@node1 ~]# rbd remove image2	//创建错了则移除镜像重新创建
[root@node1 ~]# rbd list
[root@node1 ~]# rbd create rbd/image2 --image-feature layering --size 5G
[root@node1 ~]# rbd list
[root@node1 ~]# rbd info image1		//查看镜像详细信息
修改镜像容量大小
[root@node1 ~]# rbd resize --size 1G image1 --allow-shrink	
//注意:缩小容量需要加--allow-shrink选项
[root@node1 ~]# rbd resize --size 2G image1 

本地测试：
将镜像映射为本地磁盘
[root@node1 ~]# rbd map image1
/dev/rbd0
[root@node1 ~]# lsblk /dev/rbd0
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
rbd0 251:0    0   2G  0 disk 
[root@node1 ~]# ls /dev/rbd0
/dev/rbd0
创建挂载目录
[root@node1 ~]# mkdir /notedir
格式化
[root@node1 ~]# mkfs.ext4 /dev/rbd0
[root@node1 ~]# blkid /dev/rbd0
/dev/rbd0: UUID="aa5feb6b-6caf-49d8-bc68-5f2f985e051c" TYPE="ext4"
挂载
[root@node1 ~]# mount /dev/rbd0 /notedir/
存储文件
[root@node1 ~]# echo 123 > /notedir/test.txt
[root@node1 ~]# cat /notedir/test.txt 
123

#客户端使用ceph镜像存储文件的配置步骤

1.安装ceph-common软件包
[root@client ~]# yum -y install ceph-common
安装完成后默认有rbdmap可执行程序
[root@client ~]# ls /etc/ceph/
rbdmap
2.从管理主机node1拷贝集群配置文件：通过配置文件client才能找到集群的位置
[root@client ~]# scp node1:/etc/ceph/ceph.conf /etc/ceph/
3.从管理主机node1拷贝连接密钥:通过连接密钥才能获取连接集群的权限
[root@client ~]# scp 192.168.4.51:/etc/ceph/ceph.client.admin.keyring /etc/ceph/
4.映射镜像到本地磁盘
[root@client ~]# rbd map image2
/dev/rbd0
[root@client ~]# lsblk /dev/rbd0
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
rbd0 251:0    0   5G  0 disk 
查看映射
[root@client ~]# rbd showmapped
id pool image  snap device    
0  rbd  image2 -    /dev/rbd0 
格式化
[root@client ~]# mkfs.ext4 /dev/rbd0 
挂载使用
[root@client ~]# mount /dev/rbd0 /mnt/

#创建镜像快照:在管理主机上创建
*快照使用COW技术,对大数据快照速度会很快
*COW:CopyOnlineWrite写时技术:新创建快照文件本身不占空间
*仅当对原文档做写操作时,才会把旧数据复制到快照文件里
//写操作包括:删除，修改文档内容(添加/删除内容)
*用于以后有需要时还原到快照时的样子

查看镜像快照
[root@node1 ~]# rbd snap ls image2
创建镜像快照
[root@node1 ~]# rbd snap create image2 --snap image2-snap1
[root@node1 ~]# rbd snap ls image2
SNAPID NAME            SIZE 
     4 image2-snap1 5120 MB 

#使用快照恢复数据
删除客户端写入的测试文件
[root@client ~]# rm -rf /mnt/test.sh 
在管理主机上使用快照恢复删除的文件
[root@node1 ~]# rbd snap rollback image2 --snap image2-snap1
Rolling back to snapshot: 100% complete...done.
客户端重新挂载分区
[root@client ~]# umount /mnt/
[root@client ~]# mount /dev/rbd0 /mnt/
[root@client ~]# ls /mnt/
lost+found  test.sh

#快照克隆:若想从快照恢复出来一个新的镜像，则可以使用克隆
*注意:克隆前，需要对快照进行保护操作,被保护的快照无法删除
保护快照
[root@node1 ~]# rbd snap protect image2 --snap image2-snap1
尝试删除快照，会失败
[root@node1 ~]# rbd snap rm image2 --snap image2-snap1
rbd: snapshot 'image2-snap1' is protected from removal.
2018-10-11 16:53:53.370161 7f92d80 -1 librbd::Operations: snapshot is protected
克隆快照
[root@node1 ~]# rbd clone image2 --snap image2-snap1 image2-clone --image-feature layering
//使用image2的快照image2-snap1克隆一个新的image2-clone镜像
查看克隆镜像以及其与父镜像快照的关系
[root@node1 ~]# rbd info image2-clone
rbd image 'image2-clone':
	size 5120 MB in 1280 objects
	order 22 (4096 kB objects)
	block_name_prefix: rbd_data.1063238e1f29
	format: 2
	features: layering
	flags: 
	parent: rbd/image2@image2-snap1		//父镜像快照
	overlap: 5120 MB

*克隆镜像很多数据依赖于源快照
*如果希望克隆镜像可以独立工作，需要将父快照中的数据全部拷贝一份，但比较耗时间
[root@node1 ~]# rbd flatten image2-clone
[root@node1 ~]# rbd info image2-clone		//父镜像快照项消失
rbd image 'image2-clone':
	size 5120 MB in 1280 objects
	order 22 (4096 kB objects)
	block_name_prefix: rbd_data.1063238e1f29
	format: 2
	features: layering
	flags: 


#客户端撤销镜像映射
取消挂载
[root@client ~]# umount /mnt/
取消RBD磁盘映射
[root@client ~]# rbd showmapped
id pool image  snap device    
0  rbd  image2 -    /dev/rbd0 
[root@client ~]# rbd unmap /dev/rbd/rbd/image2	#/dev/rbd/存储池名称/快照名称
[root@client ~]# rbd showmapped
在管理主机node1上删除快照(确保快照未被保护)
[root@node1 ~]# rbd snap rm image2 --snap image2-snap1
rbd: snapshot 'image2-snap1' is protected from removal.
2018-10-11 17:19:41.905011 7f92d80 -1 librbd::Operations: snapshot is protected
[root@node1 ~]# rbd snap unprotect image2 --snap image2-snap1	//取消保护
[root@node1 ~]# rbd snap rm image2 --snap image2-snap1		//删除快照
删除镜像
[root@node1 ~]# rbd list
image1
image2
image2-clone
[root@node1 ~]# rbd rm image2
[root@node1 ~]# rbd list	//删除成功，空间再次被释放出来
image1
image2-clone

=================================================================================
		         07.Cluster-day05
=================================================================================
#块存储应用

准备实验环境:

在管理机node1上创建安装虚拟机的磁盘镜像
[root@node1 ~]# rbd create vm1-image --image-feature layering --size 10G
查看镜像
[root@node1 ~]# rbd list 
[root@node1 ~]# rbd info vm1-image
[root@node1 ~]# qemu-img info rbd:rbd/vm1-image
image: rbd:rbd/vm1-image
file format: raw
virtual size: 10G (10737418240 bytes)
disk size: unavailable

1.Ceph认证账户
Ceph默认开启用户认证，客户端需要账户才可以访问
可以使用ceph auth添加新账户
[root@node1 ~]# cat /etc/ceph/ceph.conf 	//配置文件
mon_initial_members = node1, node2, node3
mon_host = 192.168.4.51,192.168.4.52,192.168.4.53
auth_cluster_required = cephx			//开启认证
auth_service_required = cephx			//开启认证
auth_client_required = cephx			//开启认证
[root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring	//账户文件
[client.admin]						//默认账户名:client.admin
	key = AQB6u75bAhDsFxAAzRJrkxaw2/3ddeHd4LTnVA==	//key是账户的密钥

2.部署客户端环境
注意:这里使用真机当客户端！！！
客户端配置ceph的yum源
2.1从管理机node1上拷贝yum源配置文件到真机
[root@node1 ~]# scp /etc/yum.repos.d/ceph.repo 192.168.4.254:/etc/yum.repos.d/

2.2真机上安装ceph客户端软件包
[root@June ~]# yum -y install ceph-common
[root@June ~]# ls /etc/ceph/

2.3将ceph配置文件和认证密钥拷贝到真机
[root@node1 ~]# scp /etc/ceph/ceph.conf /etc/ceph/ceph.client.admin.keyring 192.168.4.254:/etc/ceph/
[root@June ~]# ls /etc/ceph/

2.4创建初始化虚拟机(不安装操作系统)
真机上vir-manager图形界面创建，创建好后直接关机，不需要安装操作系统

2.5配置libvirt secret
编写账户信息文件
[root@June ~]# vim /root/secret.xml	//新建临时文件，内容如下
<secret ephemeral='no' private='no'>
        <usage type='ceph'>
<name>client.admin.secret</name>
</usage>
</secret>
创建UUID
[root@June ~]# virsh --help | grep secret	//查看help帮助
 Secret (help keyword 'secret')
    secret-define                  define or modify a secret from an XML file
    secret-dumpxml                 secret attributes in XML
    secret-event                   Secret Events
    secret-get-value               Output a secret value
    secret-list                    list secrets	//查看uuid，后面会用到
    secret-set-value               set a secret value
    secret-undefine                undefine a secret	//删除uuid
[root@June ~]# virsh secret-define --file secret.xml
Secret 5629ce9a-56cc-4e94-9e7b-7d20fb034be2 created
//随机的UUID，这个UUID对应账户信息
删除UUID
[root@June ~]# virsh secret-undefine 5629ce9a-56cc-4e94-9e7b-7d20fb034be2
获取client.admin的key
[root@June ~]# ceph auth get-key client.admin
AQB6u75bAhDsFxAAzRJrkxaw2/3ddeHd4LTnVA==
或直接查看密钥文件
[root@June ~]# cat /etc/ceph/ceph.client.admin.keyring 
[client.admin]
	key = AQB6u75bAhDsFxAAzRJrkxaw2/3ddeHd4LTnVA==
设置secret，添加账户的密钥
[root@June ~]# virsh secret-set-value --secret 5629ce9a-56cc-4e94-9e7b-7d20fb034be2 --base64 AQB6u75bAhDsFxAAzRJrkxaw2/3ddeHd4LTnVA==
Secret value set
//--secret后面是secret的UUID，--base64后面时client.admin账户的密码

2.6修改虚拟机的硬件信息XML配置文件
查看前面新建的虚拟机avpc的硬件信息XML文件
[root@June ~]# ls /etc/libvirt/qemu/avpc.xml 
/etc/libvirt/qemu/avpc.xml
用avpc的xml文件创建新的xml文件
方法一:
[root@June ~]# cat /etc/libvirt/qemu/avpc.xml > /tmp/avpc1.xml
方法二:
[root@June ~]# virsh dumpxml avpc > /tmp/avpc1.xml 
修改该虚拟机配置文件
[root@June ~]# vim /tmp/avpc1.xml
<name>avpc</name>	--><name>avpc1</name>				
<uuid>131eb918-bb2e-4b07-a632-f0cd82319adf</uuid>	//dd删除该行
//跳到device=disk这个部分
<disk type='file' device='disk'>    --><disk type='network' device='disk'>
<driver name='qemu' type='qcow2'/>  --><driver name='qemu' type='raw'/> //raw:读写
<source file='/var/lib/libvirt/images/avpc.qcow2'/>	//dd删除这行替换成这6行	
---------------------------------------------------------------------------------
<auth username='admin'>
<secret type='ceph' uuid='5629ce9a-56cc-4e94-9e7b-7d20fb034be2'/>
#这里的uuid时secret的uuid，里面已经绑定了client.admin的账户和密钥信息
</auth>
<source protocol='rbd' name='rbd/vm1-image'>
 <host name='192.168.4.51' prot='6789'/>	//ceph-mon的端口号为6789
</source>																		       
#这里说明使用账户连接哪台ceph主机和端口，访问哪个池和镜像				
--------------------------------------------------------------------------------
<target dev='vda' bus='virtio'/>						
#这里说明，将获取的镜像，设置为虚拟机的vda磁盘					
<address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>	
</disk>										
										
[root@node1 ~]# netstat -nultp | grep :6789  	//查看一下6789端口是否开启
tcp        0      0 192.168.4.51:6789       0.0.0.0:*	LISTEN      1035/ceph-mon

使用编辑好的虚拟机配置文件/tmp/avpc1.xml创建虚拟机
[root@June ~]# virsh define /tmp/avpc1.xml
Domain avpc1 defined from /tmp/avpc1.xml
[root@June ~]# virsh list --all
 Id    Name                           State
----------------------------------------------------
 -     avpc1                          shut off



#分布式文件系统CephFS存储
环境准备
新建虚拟机node4:192.168.4.54作为元数据服务器
#################################################################################
文件系统中的数据由数据和元数据组成
数据：普通文件中的实际数据
元数据：描述一个文件特征的系统数据，如访问权限,文件权属关系,文件数据块的分布信息inode等
#################################################################################
node1允许无密码远程node4
配置yum源（rhel，ceph源）
与Client主机同步时间
修改node1的/etc/hosts,并同步到所有主机

部署元数据服务器
到node4安装ceph-mds软件包
[root@node4 ~]# yum -y install ceph-mds
[root@node4 ~]# ls /etc/ceph/
rbdmap
到node1部署节点操作
[root@node1 ~]# cd /root/ceph-cluster/
启动mds服务，给node4拷贝配置文件指定node4为mds服务器
[root@node1 ceph-cluster]# ceph-deploy mds create node4
到node4查看配置文件
[root@node4 ~]# ls /etc/ceph/
ceph.conf  rbdmap  tmpLRifAl
同步配置文件和key
[root@node1 ceph-cluster]# ceph-deploy admin node4
再次到node4查看配置文件
[root@node4 ~]# ls /etc/ceph/
ceph.client.admin.keyring  ceph.conf  rbdmap  tmpLRifAl

创建存储池
文件系统需要至少2个存储池
[root@node4 ~]# ceph osd pool create cephfs_data 128	  //一个用于存储数据	
//创建存储池，对于128个PG（PG不是容量大小，是类似128个文件夹）
[root@node4 ~]# ceph osd pool create cephfs_metadata 128  //一个用于存储元数据

创建Ceph文件系统：使用前面创建的池，创建文件系统
查看mds状态
[root@node4 ~]# ceph mds stat
e2:, 1 up:standby
创建ceph文件系统
[root@node4 ~]# ceph fs new myfs1 cephfs_metadata cephfs_data
//注意，先写metadata池再写data池
//默认只能创建1个文件系统，多余的会报错
查看ceph文件系统
[root@node4 ~]# ceph fs ls
name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
再查看mds状态
[root@node4 ~]# ceph mds stat
e5: 1/1/1 up {0=node4=up:active}

客户端挂载
[root@client ~]# mkdir /mnt/cephfs
[root@client ~]# cat /etc/ceph/ceph.client.admin.keyring 
[client.admin]
	key = AQB6u75bAhDsFxAAzRJrkxaw2/3ddeHd4LTnVA==
[root@client ~]# mount -t ceph 192.168.4.51:6789:/ /mnt/cephfs/ -o name=admin,secret=AQB6u75bAhDsFxAAzRJrkxaw2/3ddeHd4LTnVA==
//-t ceph指定文件系统类型为ceph
//192.168.4.51时mon节点管理机的IP(不是MDS节点)
//admin时用户名，secret时密钥
[root@client ~]# mount | grep cephfs
4.51:6789:/ on /mnt/cephfs type ceph (rw,relatime,name=admin,secret=<hidden>,acl)
[root@client ~]# umount /mnt/cephfs/
[root@client ~]# mount | grep cephfs

#Ceph对象存储
RGW:RadosGateway:Ceph对象存储网关,用于向客户端应用呈现存储界面,提供RESTful API访问接口
环境准备
新建虚拟机node5:192.168.4.55作为RGW服务器
node1允许无密码远程node5
配置yum源（rhel，ceph源）
与Client主机同步时间
修改node1的/etc/hosts,并同步到所有主机

部署对象存储服务器
用户需要通过RGW访问存储集群
通过node1安装ceph-radosgw软件包
[root@node1 ceph-cluster]# ceph-deploy install --rgw node5
同步配置文件与密钥到node5
[root@node1 ceph-cluster]# ceph-deploy admin node5
在管理主机node1上启动node5上的rgw服务
[root@node1 ceph-cluster]# ceph-deploy rgw create node5
查看node5上的rgw服务是否启动
[root@node5 ~]# ps aux | grep radosgw
[root@node5 ~]# systemctl status ceph-radosgw.target 

修改服务端口
RGW默认服务端口为7480，修改为80更方便客户端记忆和使用
[root@node5 ~]# vim /etc/ceph/ceph.conf 	//追加写入以下内容
[client.rgw.node5]				
host=node5
rgw_frontends='civetweb port=80'       //civetweb是RGW内置的web服务，默认端口是7480
[root@node5 ~]# systemctl restart ceph-radosgw@\*	//重启服务
[root@node5 ~]# ss -nultp | grep :80			//确认80端口已打开

客户端测试
*这里仅测试RGW是否正常工作，上传，下载数据还需要调用API接口
[root@client ~]# curl http://192.168.4.55
<?xml version="1.0" encoding="UTF-8"?><ListAllMyBucketsResult xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><Owner><ID>anonymous</ID><DisplayName></DisplayName></Owner><Buckets></Buckets></ListAllMyBucketsResult>

使用第三方软件访问
在node5创建客户端连接时用的用户名和密码
[root@node5 ~]# radosgw-admin user create --uid="user1" --display-name="1st user"
//--uid：用户名，--display-name：描述信息
创建成功后会输出账户访问密钥
"keys": [
        {
            "user": "user1",
            "access_key": "EFL3HD6AYRP3WA5W42TV",
            "secret_key": "jq6qUgWqbAK8cksZ4fPBMbyC0U7AGxflY3kQMWgO"
        }
    ],
查看创建的用户信息
[root@node5 ~]# radosgw-admin user info --uid=user1

客户端安装访问工具软件
客户端安装s3cmd-2.0.1-1.el7.noarch.rpm软件包
[root@client ~]# yum -y install /root/s3cmd-2.0.1-1.el7.noarch.rpm 
配置软件
[root@client ~]# s3cmd --configure
Access Key: EFL3HD6AYRP3WA5W42TV
Secret Key: jq6qUgWqbAK8cksZ4fPBMbyC0U7AGxflY3kQMWgO
[s3.amazonaws.com]: 192.168.4.55:80
[%(bucket)s.s3.amazonaws.com]: %(bucket)s.192.168.4.55:80
Use HTTPS protocol [Yes]: No
Save settings? [y/N] y
//注意：其他提示都默认回车
Configuration saved to '/root/.s3cfg'		//提示配置保存到/root/.s3cfg


客户端测试:上传下载文件
查看存储目录
[root@client ~]# s3cmd ls
创建存储数据的bucket(类似于存储数据的目录)
[root@client ~]# s3cmd mb s3://my_bucket	#s3://是协议
[root@client ~]# s3cmd ls
2018-10-12 09:48  s3://my_bucket
上传文件
[root@client ~]# s3cmd put /var/log/messages s3://my_bucket/log/
upload: '/var/log/messages' -> 's3://my_bucket/log/messages'  [1 of 1]
 748356 of 748356   100% in    3s   216.73 kB/s  done
查看存储目录
[root@client ~]# s3cmd ls s3://my_bucket
DIR   s3://my_bucket/log/
查看log下的文档
[root@client ~]# s3cmd ls s3://my_bucket/log/
2018-10-12 09:51    748356   s3://my_bucket/log/messages
下载文件
[root@client ~]# s3cmd get s3://my_bucket/log/messages /tmp/
删除文件
[root@client ~]# s3cmd del s3://my_bucket/log/messages
delete: 's3://my_bucket/log/messages'

=================================================================================
		         07.Cluster-day06
=================================================================================
项目练习:拓扑结构

	client50
	   |
	haproxy51
	   |	
web52 web53 web54 web55 (LAMP)


部署LAMP环境
[web52-55]yum -y install mariade mariadb-server php php-mysql httpd
[web52-55]systemctl restart httpd
[web52-55]systemctl enable httpd
[web52-55]systemctl restart mariadb
编写静态测试页面和动态测试页面
[web52-55]echo web52 > /var/www/html/test.html
[web52-55]vim /var/www/html/test.php
<?php
echo php52;
?>
客户端测试页面访问
[client50]# for i in 52 53 54 55
> do
> curl 192.168.4.$i/test.html
> curl 192.168.4.$i/test.php
> echo
> done
测试数据库服务
[web52-55]mysql -uroot
编写php连接数据库页面
[web52-55]vim /var/www/html/dbtest.php
<?php
$link=mysql_connect('localhost','root','');
if($link) echo "Success !!";         
else echo "Failure !!";    
mysql_close();    
?>
客户端访问测试页面
[client50]# for i in 52 53 54 55
> do
> curl 192.168.4.$i/dbtest.php
> echo
> done
配置haproxy-LB集群
#################################################################################
基于端口的haproxy-LB集群
[haproxy51]yum -y install haproxy
[haproxy51]systemctl status haproxy
● haproxy.service - HAProxy Load Balancer
   Loaded: loaded (/usr/lib/systemd/system/haproxy.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
[haproxy51]cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak
[haproxy51]vim /etc/haproxy/haproxy.cfg
#################################################################################
基于应用层的haproxy-LB集群
[haproxy51]cp /etc/haproxy/haproxy.cfg.bak /etc/haproxy/haproxy.cfg
[haproxy51]systemctl stop haproxy.service 
[haproxy51]vim /etc/haproxy/haproxy.cfg
#---------------------------------------------------------------------
# common defaults that all the 'listen' and 'backend' sections will
# use if not designated in their block
#---------------------------------------------------------------------
defaults
...
stats uri /admin		//在defaults里添加这行
#---------------------------------------------------------------------
# main frontend which proxys to the backends
#---------------------------------------------------------------------
frontend  main *:5000	-->frontend  weblb 192.168.4.51:80
#acl url_static path_beg -i /static /images /javascript /stylesheets  //注释这行
#acl url_static       path_end       -i .jpg .gif .png .css .js	      //注释这行
    acl url_html      path_end       -i .html		//添加这行
    acl url_php       path_end       -i .php		//添加这行
   # use_backend static          if url_static		//注释这行
    use_backend htmlgrp          if url_html		//添加这行
    use_backend phpgrp           if url_php		//添加这行
    default_backend   app	-->default_backend   htmlgrp
//acl定义：url_html对应.html网页文件后缀;url_php对应.php网页文件后缀
//指定url_html对应html组，url_php对应php组
//当没有指定时网页文件路径时，默认为html组的index.html主页文件
//若没有创建index.html默认主页,访问时则出现Apache默认主页
//若指定了网页文件，但是不属于htmlgrp及phpgrp则也匹配默认服务器组htmlgrp
#---------------------------------------------------------------------
# static backend for serving up images, stylesheets and such
#---------------------------------------------------------------------
#backend static						//注释这行
 #   balance     roundrobin				//注释这行
 #   server      static 127.0.0.1:4331 check		//注释这行
backend htmlgrp						//添加这行
   balance     roundrobin				//添加这行
   server      web55 192.168.4.55:80 check		//添加这行
   server      web54 192.168.4.54:80 check		//添加这行
backend phpgrp						//添加这行
   balance     roundrobin				//添加这行
   server      web53 192.168.4.53:80 check		//添加这行
   server      web52 192.168.4.52:80 check		//添加这行
//指定html组对应web55,web54两台主机;指定php组对应web53,web52两台主机
----------------------------------------------------------------------------------
//剩余配置全部dd删除
[haproxy51]systemctl restart haproxy.service 
[haproxy51]systemctl enable haproxy.service

####################################################################
可以搭建LB负载均衡集群的软件:
LVS:可以设置权重值，不可以做健康性检查但是可搭配keepalived进行健康性检查
Haproxy:不可以设置权重值
Nginx：无法做健康性检查，可以设置权重值
####################################################################


=================================================================================
		         08.Dba1-day01
=================================================================================
Relational Database Management System(RDBMS):关系型数据库管理系统

#搭建数据库服务器
提供数据库服务的软件:MYSQL MARIADB ORACLE DB2 SQL-SERVER 
在host50上部署mysql数据库服务器
1.安装软件包
[root@host50 ~]# tar -xvf mysql-5.7.17.tar 
[root@host50 ~]# ls *.rpm
mysql-community-client-5.7.17-1.el7.x86_64.rpm	//客户端应用程序
mysql-community-common-5.7.17-1.el7.x86_64.rpm	//数据库和客户端库共享文件
mysql-community-devel-5.7.17-1.el7.x86_64.rpm	//客户端应用程序的库和头文件
mysql-community-embedded-5.7.17-1.el7.x86_64.rpm	//嵌入式函数库
mysql-community-embedded-compat-5.7.17-1.el7.x86_64.rpm	//嵌入式兼容函数库
mysql-community-embedded-devel.rpm	//头文件和库文件作为Mysql嵌入式库文件
mysql-community-libs-5.7.17-1.el7.x86_64.rpm	//mysql数据库客户端应用程序的共享库
mysql-community-libs-compat-5.7.17-1.el7.x86_64.rpm	//客户端应用程序的共享兼容库
mysql-community-minimal-debuginfo-5.7.17-1.el7.x86_64.rpm
mysql-community-server-5.7.17-1.el7.x86_64.rpm
mysql-community-test-5.7.17-1.el7.x86_64.rpm
[root@host50 ~]# rpm -Uvh mysql-community-*.rpm	//-U升级安装，可替换冲突文件
warning: mysql-community-client-5.7.17-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY
error: Failed dependencies:		//弹出报错，需要装依赖包perl(JSON)
perl(JSON) is needed by mysql-community-test-5.7.17-1.el7.x86_64
[root@host50 ~]# yum list | grep -i json | grep -i perl	      //查询perl(JSON)包名
perl-JSON.noarch                    2.59-2.el7               192.168.4.254_rhel7
perl-JSON-PP.noarch                 2.27202-2.el7            192.168.4.254_rhel7
[root@host50 ~]# yum -y install perl-JSON	//安装依赖包解决依赖关系
[root@host50 ~]# rpm -Uvh mysql-community-*.rpm	//再次安装软件包


2.修改配置
数据库目录:/var/lib/mysql
[root@host50 ~]# systemctl start mysqld		//启动数据库服务
[root@host50 ~]# systemctl enable mysqld	//设置开机自启
[root@host50 ~]# ss -nultp | grep :3306		//查看端口（数据库服务默认端口3306）
tcp	LISTEN	0	80	:::3306	:::*	users:(("mysqld",pid=2325,fd=22))
[root@host50 ~]# ps -C mysqld			//查看进程
修改配置文件（mysql,mariadb默认配置文件路径:/etc/my.cnf）
[root@host50 ~]# vim /etc/my.cnf
datadir=/var/lib/mysql			//数据库目录
socket=/var/lib/mysql/mysql.sock	//socket文件,随服务启动产生,服务停止文件消失
log-error=/var/log/mysqld.log		//服务日志文件
pid-file=/var/run/mysqld/mysqld.pid	//服务pid号文件


3.重启mysqld服务
[root@host50 ~]# systemctl restart mysqld


4.查看服务运行状态
[root@host50 ~]# systemctl status mysqld
● mysqld.service - MySQL Server
   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)
   Active: active (running) since Mon 2018-10-15 10:19:26 CST; 24min ago
     Docs: man:mysqld(8)
           http://dev.mysql.com/doc/refman/en/using-systemd.html
 Main PID: 2325 (mysqld)
CGroup: /system.slice/mysqld.service
     └─2325 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pi...
Oct 15 10:18:56 host50 systemd[1]: Starting MySQL Server...
Oct 15 10:19:26 host50 systemd[1]: Started MySQL Server.
数据库目录所有者，所属组都是mysql
[root@host50 ~]# ls -ld /var/lib/mysql
drwxr-x--x. 5 mysql mysql 4096 Oct 15 10:19 /var/lib/mysql
[root@host50 ~]# ls -l /var/lib/mysql
-rw-r-----. 1 mysql mysql       56 Oct 15 10:19 auto.cnf
-rw-------. 1 mysql mysql     1679 Oct 15 10:19 ca-key.pem
-rw-r--r--. 1 mysql mysql     1074 Oct 15 10:19 ca.pem
......
-rw-r--r--. 1 mysql mysql     1078 Oct 15 10:19 server-cert.pem
-rw-------. 1 mysql mysql     1675 Oct 15 10:19 server-key.pem
drwxr-x---. 2 mysql mysql     8192 Oct 15 10:19 sys
启动服务进程的用户是mysql
[root@host50 ~]# ps aux | grep mysqld
mysql 2325 0.0 16.9 1119216 171820 ? Sl 10:19 0:00 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid


5.客户端访问服务
默认数据库管理帐号root,默认仅允许在localhost访问
首次登录密码在安装时随即生成.存放在日志文件里
[root@host50 ~]# grep password /var/log/mysqld.log 
2018-10-15T02:19:06.213247Z 1 [Note] A temporary password is generated for root@localhost: OHuk9eJ3d_kl-->随机生成的默认管理密码
              ¯¯¯¯¯¯¯¯¯¯¯¯¯
连接数据库
[root@host50 ~]# mysql -hlocalhost -uroot -p'OHuk9eJ3d_kl'
mysql> show databases;	//会报错，第一次执行命令之前要修改管理密码
ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.
设置密码:根据提示要用ALTER USER(SQL命令:结构化查询语言)
########################
SQL命令的使用规则
命令要以;结尾
\c取消命令
命令不区分大小写
默认情况下不支持tab
########################
mysql> alter user root@localhost identified by "123qqq...A";	
//密码要求必须有数字,大小写字母及符号
mysql> show databases;						//再次执行命令成功
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)
mysql> quit							//退出数据库
[root@host50 ~]# mysql -hlocalhost -uroot -p123qqq...A		//用新密码重新登录
修改数据库服务密码策略
临时设置
mysql> show variables like "%password%";	//查找包含password的变量，%是通配符
mysql> set validate_password_policy=0		//将密码策略复杂度改成0
ERROR 1229 (HY000): Variable 'validate_password_policy' is a GLOBAL variable and should be set with SET GLOBAL			//报错提示这是全局变量要用set global
mysql> set global validate_password_policy=0;	//0代表复杂度可以仅数字
mysql> set global validate_password_length=6;	//修改密码长度为6
mysql> alter user root@localhost identified by '123456';	//再次修改密码
[root@host50 ~]# mysql -hlocalhost -uroot -p123456	//测试再次登录
永久设置
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
validate_password_policy=0
validate_password_length=6
[root@host50 ~]# systemctl restart mysqld


#数据库服务的基本使用:
库和表的基本管理
1.客户端连接数据库服务器
[root@host50 ~]# mysql -hlocalhost -uroot -p123456
2.创建数据库
mysql> create database gamedb;
mysql> create database bbsdb;
//数据库命名规则:数字,英文字母和下划线,不可以纯数字,区分大小写,具有唯一性
		不可以出现命令关键字,如:create,select...
###############################################################
[root@host50 ~]# mkdir /var/lib/mysql/teadb2	
[root@host50 ~]# ls -ld /var/lib/mysql/teadb2
drwxr-xr-x. 2 root root 6 Oct 15 15:24 /var/lib/mysql/teadb2
[root@host50 ~]# chown mysql:mysql /var/lib/mysql/teadb2
[root@host50 ~]# ls -ld /var/lib/mysql/teadb2
drwxr-xr-x. 2 mysql mysql 6 Oct 15 15:24 /var/lib/mysql/teadb2
//也可以在系统下数据库目录创建文件夹,但是必须修改属主属组关系
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| bbsdb              |
| gamedb             |
| mysql              |
| performance_schema |
| studb              |
| sys                |
| teadb2             |
+--------------------+
###############################################################
3.获取当前所在数据库库名
mysql> select database();
+------------+
| database() |
+------------+
| NULL       |		//显示为空，即未进入库在数据库目录/var/lib/mysql
+------------+
1 row in set (0.00 sec)
4.显示已有的库
mysql> show databases;
5.切换库
mysql> use gamedb;
mysql> use bbsdb;
6.显示已有的表
mysql> show tables;
7.删除库
mysql> drop database bbsdb;
8.退出数据库
mysql> quit	或	mysql> exit
9.新建表
create table 库名.表名(
字段名1 字段类型(宽度) 约束条件，
字段名2 字段类型(宽度) 约束条件，
...
字段名N 字段类型(宽度) 约束条件		//最后一个不需要逗号
);
mysql> create database teadb;
mysql> use teadb;
mysql> create table teadb.stuinfo(
    -> name char(20),
    -> age int,
    -> homeaddr char(50)
    -> );
mysql> show tables;
+-----------------+
| Tables_in_teadb |
+-----------------+
| stuinfo         |
+-----------------+
1 row in set (0.00 sec)
mysql> select * from stuinfo;
10.查看表结构
mysql> desc 表名;
11.删除表
mysql> drop table 表名;
12.插入表记录
mysql> insert into teadb.stuinfo 
    -> values
    -> ("bob","19","shenzhen"),
    -> ("tom","21","guangzhou");
或(省略into)
mysql> insert teadb.stuinfo 
    -> values
    -> ("bob","19","shenzhen"),
    -> ("tom","21","guangzhou");
mysql> select * from stuinfo;
+------+------+-----------+
| name | age  | homeaddr  |
+------+------+-----------+
| bob  |   19 | shenzhen  |
| tom  |   21 | guangzhou |
+------+------+-----------+
2 rows in set (0.00 sec)
13.修改表记录update 表名 set 字段=值 约束条件;
mysql> update teadb.stuinfo set age=18 where name='bob';
14.删除表记录
mysql> delete from stuinfo where name='bob';
mysql> delete from stuinfo;		//清空所有表数据
15.指定表字段的字符集
mysql> create table 学生表(姓名 char(20),性别 char(6))DEFAULT CHARSET=utf8;
mysql> create table t2(name char(10));
mysql> show create table t2;	//查看SQL命令
+-------+-------------------------------------------------------------------------------------------+
| Table | Create Table|
+-------+-------------------------------------------------------------------------------------------+
| t2    | CREATE TABLE `t2` (`name` char(10) DEFAULT NULL) ENGINE=InnoDB 
DEFAULT CHARSET=latin1 |
+-------+-------------------------------------------------------------------------------------------+
//没有写约束条件，系统会自动补充默认值；如字符集默认值CHARSET=latin1
创建表时指定字符集为utf8



MySQL数据类型
数值类型
常用数值类型:
整形int
单精度浮点型float
双精度浮点型double
mysql> use teadb;
Database changed
mysql> create table t3(
    -> age tinyint unsigned,	//unsigned代表禁止负数
    -> pay float(7,2)		//最多7位，小数点后取两位
    -> );
Query OK, 0 rows affected (0.22 sec)
mysql> insert into t3 values(200,999999.99);
ERROR 1264 (22003): Out of range value for column 'pay' at row 1     //数值超出范围
mysql> insert into t3 values(200,99999.99);
Query OK, 1 row affected (0.04 sec)
mysql> insert into t3 values(100,-99999.99);
Query OK, 1 row affected (0.02 sec)
mysql> insert into t3 values(9.33,20000);//插入字符类型不匹配则四舍五入按预设类型记录
mysql> select * from t3;
+------+-----------+
| age  | pay       |
+------+-----------+
|  200 |  99999.99 |
|  100 | -99999.99 |
+------+-----------+
2 rows in set (0.00 sec)

字符类型
常用字符类型:
定长char[不指定宽度默认1]
变长varchar[不指定宽度报错,按数据实际大小配存储空间]
mysql> create table t4(
    -> name char,
    -> homedir varchar
    -> );
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ')' at line 4		//不指定char宽度不报错;不指定varchar宽度报错

mysql> create table t4( name char(4), homedir varchar(6) );
Query OK, 0 rows affected (0.20 sec)
mysql> desc t4;
+---------+------------+------+-----+---------+-------+
| Field   | Type       | Null | Key | Default | Extra |
+---------+------------+------+-----+---------+-------+
| name    | char(4)    | YES  |     | NULL    |       |
| homedir | varchar(6) | YES  |     | NULL    |       |
+---------+------------+------+-----+---------+-------+
mysql> insert into t4 values("jack","cn");
Query OK, 1 row affected (0.04 sec)
mysql> insert into t4 values("rookie","kr");	//超过长度，则报错
ERROR 1406 (22001): Data too long for column 'name' at row 1

日期时间类型
常用日期时间类型:
datetime:占用8个字节，范围:1000-01-01 00:00:00.000000～9999-12-31 23：59：59.999999
//未给datetime字段赋值时，datetime默认为NULL
timestamp:占用8个字节，范围:1970-01-01 00:00:00.000000～2038-01-19 03：14：07.999999
//未给timestamp字段赋值时，timestamp自动用当前系统时间赋值
data:占用4个字节，范围:0001-01-01～9999-12-31
year:占用1个字节，范围:1901～2155
//year默认用4位数字表示,当只用2位数字时,01-69代表2001-2069；70-99代表1970-1999
time:占用3个字节，格式:HH:MM:SS
mysql> create table t5(
    -> name char(10),
    -> birthday date,
    -> start year,
    -> uptime time,
    -> party datetime
    -> );
Query OK, 0 rows affected (0.21 sec)
mysql> insert into t5 values("tom","19950503","2018","083000","201810012030"); 
Query OK, 1 row affected (0.02 sec)

mysql> select * from t5;
+------+------------+-------+----------+---------------------+
| name | birthday   | start | uptime   | party               |
+------+------------+-------+----------+---------------------+
| tom  | 1995-05-03 |  2018 | 08:30:00 | 2018-10-01 20:30:00 |
+------+------------+-------+----------+---------------------+
1 row in set (0.00 sec)

使用时间函数给日期时间字段赋值
now()获取当前系统的日期和时间
mysql> select now();
+---------------------+
| now()               |
+---------------------+
| 2018-10-16 09:08:45 |
+---------------------+
1 row in set (0.00 sec)

year()获取指定时间中的年份
mysql> select year(20080808);
+----------------+
| year(20080808) |
+----------------+
|           2008 |
+----------------+
1 row in set (0.01 sec)

day()获取指定时间中的日期
mysql> select day(20080808);
+---------------+
| day(20080808) |
+---------------+
|             8 |
+---------------+
1 row in set (0.00 sec)
slep(N)休眠N秒
curdate()获取当前的系统日期
curtime()获取当前的系统时刻
month()获取指定时间中的月份
date()获取指定时间中的日期
time()获取指定时间中的时刻

int补充:
mysql> create table t8(
    -> name char(3),
    -> level int(3) zerofill	//zerofill代表不满指定宽度的用0补充(默认空格补充)
    -> );			//int若不指定宽度默认宽度11位

mysql> insert into t8 values("tom",13);
Query OK, 1 row affected (0.04 sec)

mysql> insert into t8 values("tom",29);
Query OK, 1 row affected (0.02 sec)

mysql> insert into t8 values("tom",129);
Query OK, 1 row affected (0.02 sec)

mysql> insert into t8 values("tom",1129);
Query OK, 1 row affected (0.03 sec)

mysql> select * from t8;
+------+-------+
| name | level |
+------+-------+
| tom  |   013 |
| tom  |   029 |
| tom  |   129 |
| tom  |  1129 |	//超过宽度但是还在int范围内也可以存储
+------+-------+	//int型宽度超过3还是可以存，宽度3仅代表不足宽度3用空格补充到3位
4 rows in set (0.00 sec)
mysql> insert into t8(name) values("tomy");//但是char类型超过指定宽度则存不进去
ERROR 1406 (22001): Data too long for column 'name' at row 1


枚举类型
从给定值集合中选择单个值,enum
定义格式:enum(值1，值2，...)

从给定值集合中选择一个或多个值,set
定义格式:set(值1，值2，...)

mysql> create table t6(
    -> name varchar(4),
    -> hobbies set("eat","sleep","game","film"),
    -> sex enum("male","female","secret")
    -> );
mysql> insert into t6 values("tom","game","male");
Query OK, 1 row affected (0.02 sec)
mysql> select * from t6;
+------+---------+------+
| name | hobbies | sex  |
+------+---------+------+
| tom  | game    | male |
+------+---------+------+
1 row in set (0.00 sec)

mysql> insert into t6 values("tom","woman","male");
ERROR 1265 (01000): Data truncated for column 'hobbies' at row 1
//若插入时，指定没有的选项，会报错


=================================================================================
		         08.Dba1-day02
=================================================================================
#字段约束条件:控制给字段赋值
desc查看表结构命令对应字段含义：
+----------+----------+----------+-----+-------------------+-------+
| Field    | Type     |   Null   | Key |      Default      | Extra |
+----------+----------+----------+-----+-------------------+-------+
  字段	     数据类型  是否允许空值 键值  字段不赋值时的默认值  额外设置

mysql> create table t9 (
    -> name char(10) not null,
    -> age tinyint(2) unsigned default 18,
    -> hobby set("eat","sleep","game","sport") not null default "eat,sleep"
    -> );

mysql> insert into t9(name)values("bob");
Query OK, 1 row affected (0.03 sec)
mysql> select * from t9 where name="bob";
+------+------+-----------+
| name | age  | hobby     |
+------+------+-----------+
| bob  |   18 | eat,sleep |
+------+------+-----------+
1 row in set (0.00 sec)

mysql> insert into t9 values("",21,"game,eat");
Query OK, 1 row affected (0.05 sec)
mysql> select * from t9 where name="";
+------+------+----------+
| name | age  | hobby    |
+------+------+----------+
|      |   21 | eat,game |
+------+------+----------+
1 row in set (0.00 sec)


mysql> insert into t9(age,hobby) values(21,"game,eat");
ERROR 1364 (HY000): Field 'name' doesn't have a default value

mysql> insert into t9 values(NULL,21,"game,eat");	//NULL不加""代表空值
ERROR 1048 (23000): Column 'name' cannot be null

mysql> insert into t9 values("NULL",21,"game,eat");	//NULL加了""代表普通字符
Query OK, 1 row affected (0.05 sec)
mysql> select * from t9 where name="NULL";
+------+------+----------+
| name | age  | hobby    |
+------+------+----------+
| NULL |   21 | eat,game |
+------+------+----------+
1 row in set (0.01 sec)


#修改表结构
alter table 表名 执行动作
		    ↓
		add	添加字段
		modify	修改字段类型
		change	修改字段名
		drop	删除字段
		rename	修改表名

add,modify可以加after 字段名 或first


#索引
概念:对记录集的多个字段进行排序的方法(类似书的目录)
类型:Btree,B+tree,hash

优点:
通过创建唯一性索引，可以保证数据库中每一行数据的唯一性
可以加快数据的检索速度

缺点:
当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，降低数据维护的速度
索引需要占物理空间

查看表字段的索引
mysql> show index from t4;






#键值
键值类型
INDEX		:普通索引
UNIQUE		:唯一索引
FULLTEXT	:全文索引
PRIMARY KEY	:主键
FOREIGN KEY	:外键


#INDEX普通索引
一个表中可以有多个INDEX字段
字段的值允许有重复，且可以赋NULL值
把经常做查询条件的字段设置为INDEX字段
INDEX字段的Key标志是MUL
mysql> desc t4;
Key=MUL			

建表时指定索引字段
index(字段1),index(字段2)...
mysql> create table t21(
    -> name char(10),
    -> sex enum("male","female"),
    -> class char(7),
    -> age int(2),
    -> index(name),
    -> index(sex)
    -> );
Query OK, 0 rows affected (0.27 sec)

mysql> desc t21;
+-------+-----------------------+------+-----+---------+-------+
| Field | Type                  | Null | Key | Default | Extra |
+-------+-----------------------+------+-----+---------+-------+
| name  | char(10)              | YES  | MUL | NULL    |       |
| sex   | enum('male','female') | YES  | MUL | NULL    |       |
| class | char(7)               | YES  |     | NULL    |       |
| age   | int(2)                | YES  |     | NULL    |       |
+-------+-----------------------+------+-----+---------+-------+
4 rows in set (0.00 sec)


查看索引详细信息
mysql> show index from t21\G	//\G是分行显示
*************************** 1. row ***************************
        Table: t21
   Non_unique: 1
     Key_name: name
 Seq_in_index: 1
  Column_name: name
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
*************************** 2. row ***************************
        Table: t21
   Non_unique: 1
     Key_name: sex
 Seq_in_index: 1
  Column_name: sex
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
2 rows in set (0.00 sec)

删除索引
mysql> drop index name on t21;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> desc t21;
mysql> show index from t21\G;

在已有表里设置索引字段
mysql> create index name on t21(name);
                     ↑		  ↑
		    索引名	字段名
mysql> desc t21;
mysql> show index from t21\G;



#primary key主键
一个表中只能有一个primary key字段
对应的字段值不允许有重复，且不允许赋NULL值
如果有多个字段都作为primary key，称为复合主键，必须一起创建
主键字段的KEY标志是PRI
通常与AUTO_INCREMENT(自动增长)连用
经常把表中能够唯一标识记录的字段设置主键字段[记录编号字段]

建表时创建主键格式：
mysql> create table t22(
    -> name char(10),
    -> stu_num char(9),
    -> primary key(stu_num)
    -> );
或
mysql> create table t23(
    -> name char(10) primary key,
    -> stu_num char(9)
    -> );

建表时创建复合主键
mysql> create table t24(
    -> client_ip char(15),
    -> port smallint(2),
    -> status enum("deny","allow"),
    -> primary key(client_ip,port)
    -> );

删除主键
mysql> alter table t24 drop primary key;

在已有表里创建主键
mysql> alter table t24 add primary key(client_ip,port);
//若表中这两个字段原有数据不满足主键的规则则需要先删除表中数据
mysql> delete from t24;
mysql> alter table t24 add primary key(client_ip,port);

primary key 与 AUTO_INCREMENT连用
mysql> create table t25(
    -> stu_id int(2) primary key auto_increment,
    -> name char(5),
    -> age tinyint(2) unsigned
    -> );
Query OK, 0 rows affected (0.20 sec)

mysql> insert into t25(name,age)values("bob",19);
Query OK, 1 row affected (0.02 sec)

mysql> insert into t25(name,age)values("tom",17);
Query OK, 1 row affected (0.02 sec)

mysql> select * from t25;
+--------+------+------+
| stu_id | name | age  |
+--------+------+------+
|      1 | bob  |   19 |
|      2 | tom  |   17 |
+--------+------+------+
2 rows in set (0.00 sec)

修改已有表为primary key 与 AUTO_INCREMENT连用
mysql> alter table stuinfo add id int(2) zerofill 
    -> primary key 
    -> auto_increment 
    -> first;
Query OK, 0 rows affected (0.40 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> select * from stuinfo;
+----+------+------+-----------+
| id | name | age  | hobby     |
+----+------+------+-----------+
| 01 | bob  |   18 | eat,sleep |
| 02 | tom  |   21 | eat,game  |
+----+------+------+-----------+

当设置了自动增长之后，不能直接删除主键
mysql> alter table t25 drop primary key;
ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key

要先删除自动增长
mysql> alter table t25 modify stu_id int(2) not null;
Query OK, 2 rows affected (0.57 sec)
Records: 2  Duplicates: 0  Warnings: 0
mysql> desc t25;
+-------+
| Extra |
+-------+
|       |
|       |
|       |
+-------+
再删除主键
mysql> alter table t25 drop primary key;


#外键foreign key
概念:让当前表字段的值在另一个表中字段值的范围内选择
优点:保持数据的一致性

使用外键的条件
表的存储引擎必须是innodb-->仅有innodb才支持外键
字段类型要一致（数据类型，宽度都要一样）
被参照字段必须要是索引类型的一种(通常是primary key)

创建员工表
mysql> create table ygtab(
    -> yg_id int(2) primary key auto_increment,
    -> name char(10)
    -> )engine=innodb;			//指定存储引擎为innodb

mysql> insert into ygtab(name)values("bob");
Query OK, 1 row affected (0.03 sec)
mysql> insert into ygtab(name)values("tom");
Query OK, 1 row affected (0.01 sec)

mysql> select * from ygtab;
+-------+------+
| yg_id | name |
+-------+------+
|     1 | bob  |
|     2 | tom  |
+-------+------+
2 rows in set (0.00 sec)

创建工资表
mysql> create table gztab(
    -> gz_id int(2),
    -> pay float(7,2),
    -> foreign key(gz_id) references ygtab(yg_id)
       //外键为gz_id，参考ygtab表的yg_id字段
    -> on update cascade on delete cascade	//实时同步
    -> )engine=innodb;
Query OK, 0 rows affected (0.20 sec)
mysql> show create table gztab;			//查看表是否有外键

在工资表插入gz_id为3的时候，由于ygtab里没有这个yg_id，则会报错
mysql> insert into gztab values(3,30000);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`teadb`.`gztab`, CONSTRAINT `gztab_ibfk_1` FOREIGN KEY (`gz_id`) REFERENCES `ygtab` (`yg_id`) ON DELETE CASCADE ON UPDATE CASCADE)
工资表插入数据
mysql> insert into gztab values(1,28000);
Query OK, 1 row affected (0.02 sec)
mysql> insert into gztab values(2,38000);
Query OK, 1 row affected (0.02 sec)
mysql> select * from gztab;
+-------+----------+
| gz_id | pay      |
+-------+----------+
|     1 | 28000.00 |
|     2 | 38000.00 |
+-------+----------+
2 rows in set (0.00 sec)

更新员工表
mysql> update ygtab set yg_id=8 where yg_id=2;
mysql> select * from ygtab;
+-------+------+
| yg_id | name |
+-------+------+
|     1 | bob  |
|     8 | tom  |
+-------+------+
再查看一下工资表，发现同步更新了
mysql> select * from gztab;
+-------+----------+
| gz_id | pay      |
+-------+----------+
|     1 | 28000.00 |
|     8 | 38000.00 |
+-------+----------+

删除员工id为8的员工
mysql> delete from ygtab where yg_id=8;
mysql> select * from ygtab;
+-------+------+
| yg_id | name |
+-------+------+
|     1 | bob  |
+-------+------+
再查看一下工资表，同步更新
mysql> select * from gztab;
+-------+----------+
| gz_id | pay      |
+-------+----------+
|     1 | 28000.00 |
+-------+----------+

存在问题：
可以无限添加相同id
mysql> insert into gztab values(1,30000);
Query OK, 1 row affected (0.01 sec)
mysql> insert into gztab values(1,30000);
Query OK, 1 row affected (0.07 sec)
还可以添加空值，因为空值与外键参考的员工表yg_id不冲突
mysql> insert into gztab values(null,32000);
Query OK, 1 row affected (0.02 sec)

解决方法:
mysql> delete from gztab;		//有重复数据，需要清楚表记录
Query OK, 1 row affected (0.02 sec)


=================================================================================
		         08.Dba1-day03
=================================================================================
##mysql存储引擎

MySQL体系结构:连接池 sql接口 分析器 优化器 查询缓存 存储引擎 文件系统 管理工具

查看表的存储引擎
mysql> show create table 表名；

常用存储引擎:
mysql5.5以上的默认存储引擎是innodb
mysql5.0-5.5默认存储引擎是myisam

查看系统可用存储引擎
mysql> show engines;

修改默认存储引擎
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
default-storage-engine=myisam
[root@host50 ~]# systemctl restart mysqld
查看一下默认引擎
mysql> show engines;


#存储引擎的特点

Myisam存储引擎
主要特点：
支持表级锁
不支持事务，事务回滚，外键
相关表文件:xxx.frm,xxx.MYI,xxx.MYD


InnoDB存储引擎
主要特点：
支持行级锁
支持事务，事务回滚，支持外键
相关表文件:xxx.frm,xxx.ibd
事务文件:ibdata1,ib_logfile0,ib_logfile1        //事务文件:连接mysql时执行的命令记录

锁粒级(访问的时候才会加锁)
表级锁:一次直接对整张表进行加锁
行级锁:只锁定某一行
页级锁:对整个页面(mysql管理数据的本存储单位)进行加锁

锁类型
读锁(共享锁):支持并发读
写锁(互斥锁,排它锁):独占锁，上锁期间其他线程不能读表或写表

查看当前的锁状态
mysql> show status like "%Table_lock%";
+-----------------------------------------+-------+
| Variable_name                           | Value |
+-----------------------------------------+-------+
| Performance_schema_table_lock_stat_lost | 0     |
| Table_locks_immediate                   | 102   |
| Table_locks_waited                      | 0     |
+-----------------------------------------+-------+
3 rows in set (0.00 sec)

事务特性(ACID)
Atomic:原子性
事务的整个操作是一个整体，不可分割，要么全部成功，要么全部失败
Consistency:一致性
事务操作的前后，表中的记录没有变化
Isolation:隔离性
事务操作提交之前是相互隔离不受影响的(客户端AB同时访问数据库，彼此不知道对方在访问)
Durability:持久性
数据一旦提交，不可改变，永久改变表数据

mysql> show variables  like "autocommit"; //查看提交状态
mysql> set autocommit=off;  //关闭自动提交
Query OK, 0 rows affected (0.00 sec)

mysql> create table t4(id int)engine=innodb;
Query OK, 0 rows affected (0.13 sec)

mysql> insert into db3.t4 values(666);
mysql> commit;    //提交数据
Query OK, 0 rows affected (0.00 sec)

mysql> delete from db3.t4;
Query OK, 1 row affected (0.00 sec)
mysql> select * from t4;
Empty set (0.00 sec)
mysql> rollback； //数据回滚

mysql> select * from t4;
+------+
| id   |
+------+
|  666 |
+------+
1 row in set (0.00 sec)
mysql> commit;
Query OK, 0 rows affected (0.00 sec)


查询操作多的表适合使用myisam存储引擎,可以节省资源
写操操作多的表适合使用innodb存储引擎,可以加大并发访问量


#数据导入导出
导入导出默认目录(需要把要导入的文件放到该目录)
mysql> show variables like "secure_file_priv";
+---------------------------+-----------------------+
| Variable_name             | Value                 |
+---------------------------+-----------------------+
| secure_file_priv          | /var/lib/mysql-files/ |
+---------------------------+-----------------------+
[root@host50 ~]#  ls -ld /var/lib/mysql-files/
drwxr-x---. 2 mysql mysql 31 4月19 1 4: 15 /var/lib/mysql-files

数据导入
基本用法
LOAD DATA INFILE "录名/文件名"
INTO TABLE  表名
FIELDS TERMINATED BY "分隔符"	//字段之间的分隔符
LINES TERMINATED BY "\n ";	//行之间的分隔符,一般是\n(换行）	
注意事项
–字段分隔符要与文件的一致
–指定导入文件的绝对路径
–导入数据的表字段类型要与文件字段匹配
–禁用SElinux


先创建一个表
mysql> create table userinfo(
    -> username char(50),
    -> password char(1),
    -> uid int(1),
    -> gid int(1),
    -> comment varchar(150),
    -> homedir varchar(100),
    -> shell char(30)
    -> );
Query OK, 0 rows affected (0.03 sec)

############################
在mysql登录状态下执行系统命令:
在命令前加system
############################

把文件复制到默认末路下
mysql> system cp /etc/passwd /var/lib/mysql-files/
mysql> system ls /var/lib/mysql-files/
passwd

数据导入操作
mysql> load data infile "/var/lib/mysql-files/passwd"
    -> into table db3.userinfo
    -> fields terminated by ":"
    -> lines terminated by "\n";
Query OK, 41 rows affected (0.00 sec)
Records: 41  Deleted: 0  Skipped: 0  Warnings: 0

为了方便查看，可以插入一个新字段id并设置为主键
mysql> alter table userinfo 
    -> add id int(2) 
    -> primary key auto_increment first;
Query OK, 41 rows affected (0.04 sec)
Records: 41  Duplicates: 0  Warnings: 0

修改导入导出默认目录
mysql> system mkdir /mydir
mysql> system chown mysql:mysql /mydir
mysql> system ls -ld /mydir
mysql> system sed -i "4a secure_file_priv=/mydir" /etc/my.cnf
mysql> system head -5 /etc/my.cnf
mysql> system systemctl restart mysqld

数据导出
基本用法
SELECT * FROM 表名
INTO UTFILE "目录名/文件名"
FIELDS TERMINATED BY "分隔符"
LINES TERMINATED BY "\n ";


数据导出操作
mysql> select * from teadb.t3 into outfile "/mydir/a.txt";
Query OK, 4 rows affected (0.01 sec)
mysql> system cat /mydir/a.txt
200	99999.99
100	-99999.99
9	20000.00
20	99.90
//若不指定字段分隔符默认是\t制表符,若不指定行分割默认是\n换行

mysql> select * from teadb.t3 into outfile "/mydir/b.txt"
    -> fields terminated by "##"
    -> lines terminated by "!!!";
Query OK, 4 rows affected (0.00 sec)
mysql> system cat /mydir/b.txt
200##99999.99!!!100##-99999.99!!!9##20000.00!!!20##99.90!!!


#管理表记录


1.增加表记录
语法格式
格式1：给所有字段赋值
INSERT INTO 表名 
VALUES 
(字段1值，...，字段N值)，	//这里每个括号代表插入一行表记录
(字段1值，...，字段N值)，
(字段1值，...，字段N值)，
...
;
mysql> insert into userinfo
    -> values
    -> (42,"bob","x","3003","3003","test user","/root/bob","/sbin/nologin");
Query OK, 1 row affected (0.00 sec)

格式2：给指定字段赋值
INSERT INTO 表名 (字段1,... ,字段N)
VALUES 
(字段1值，...，字段N值)，
(字段1值，...，字段N值)，
(字段1值，...，字段N值)，
... 
;
mysql> insert into userinfo(username,uid,shell)
    -> values
    -> ("tom","3004","/shell/bash");
Query OK, 1 row affected (0.00 sec)

●注意事项
–字段值要与字段类型相匹配
–对于字符类型的字段，要用双或单引号括起来
–依次给所有字段赋值时，字段名可以省略
–只给一部分字段赋值时，必须明确写出对应的字段名称


2.查询表记录
语法格式
格式1
SELECT 字段1,...,字段N FROM 表名;
格式2
mysql> select username,shell,homedir from userinfo;

SELECT 字段1,...,字段N FROM 表名 
WHERE 条件表达式;
mysql> select username,shell,homedir from userinfo
    -> where
    -> shell="/bin/bash"
    -> ;

●注意事项
–使用*可匹配所有字段
–指定表名时，可采用库名.表名的形式

*查询表所有表记录
mysql> select * from userinfo;

*临时自定义字段名显示对应字段
mysql> select username name,uid user_id from userinfo;
+-------+---------+
| name  | user_id |
+-------+---------+


3.更新表记录
语法格式
格式1：更新表内的所有记录
UPDATE 表名
SET
字段1=字段1值,
字段2=字段2值,
...
字段N=字段N值;
mysql> update userinfo
    -> set
    -> password="a",comment="student";


格式2：只更新符合条件的部分记录
UPDATE 表名
SET
字段1=字段1值,
字段2=字段2值,
...
字段N=字段N值
WHERE 条件表达式;
mysql> update userinfo
    -> set
    -> password="x"
    -> where username="root";
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0


●注意事项
–字段值要与字段类型相匹配
–对于字符类型的字，要用双或单引号括起来
–若不使用WHERE限定条件，会更新所有记录
–限定条件时，只更新匹配条件的记录


4.删除表记录
语法格式
格式1，仅删除合条件的记
DELETE FROM 表名 WHERE 条件表达式;
mysql> delete from userinfo where username="bob";
Query OK, 1 row affected (0.00 sec)

格式2,删除所有的表记录
DELETE FROM 表名;
mysql> delete from db3.t4;
Query OK, 1 row affected (0.05 sec)



#匹配条件
1.基本查询条件
1.1数值比较:字段类型必须数值类型
类型	用途
=	等于
>,>=	大于，大于或等于
<,<=	小于，小于或等于
!=	不等于
mysql> select username from userinfo where uid=gid;
mysql> select username from userinfo where id=3;
mysql> select username from userinfo where uid<=10;
mysql> select username from userinfo where uid<=gid;


1.2字符比较,匹配空/非空:字段类型必须字符型
类型		用途
=		相等
!=		不相等
IS NULL		匹配空
IS NOT NULL	匹配非空
mysql> select * from userinfo where username="mysql";
mysql> select username from userinfo where shell!="/bin/bash";

1.3逻辑匹配:多个判断条件时使用
类型	用途
OR 	逻辑或
AND	逻辑与
!或not	逻辑非
( )	提高优先级

mysql> select username,uid from userinfo where username="root" and uid=0;
+----------+------+
| username | uid  |
+----------+------+
| root     |    0 |
+----------+------+
mysql> select username,uid from userinfo where username="root" or uid=3;
+----------+------+
| username | uid  |
+----------+------+
| root     |    0 |
| adm      |    3 |
+----------+------+
mysql> select username,uid from userinfo where username="root" or username="bin" and uid=3;
+----------+------+
| username | uid  |
+----------+------+
| root     |    0 |
+----------+------+
mysql> select username,uid from userinfo where (username="root" or username="bin") and uid=0;
+----------+------+
| username | uid  |
+----------+------+
| root     |    0 |
+----------+------+

1.4范围内匹配/去重显示:匹配范围内的任意一个值即可
类型				用途
In (值列表) 			在...里...
Not in (值列表)			不在...里...
Between 数字1 and 数字2		在数字1和数字2之间
DISTINCT  字段名		去重显示

mysql> select username from userinfo where username in ("mysql","root");
+----------+
| username |
+----------+
| root     |
| mysql    |
+----------+
2 rows in set (0.00 sec)
mysql> select username from userinfo where username not in ("mysql","root");
mysql> select username from userinfo where uid between 0 and 4;
+----------+
| username |
+----------+
| root     |
| bin      |
| daemon   |
| adm      |
| lp       |
+----------+
5 rows in set (0.00 sec)
mysql> select distinct shell from userinfo;
//显示所有shell字段的表记录(重复的只显示一次)
+----------------+
| shell          |
+----------------+
| /bin/bash      |
| /sbin/nologin  |
| /bin/sync      |
| /sbin/shutdown |
| /sbin/halt     |
| /bin/false     |
| NULL           |
| /shell/bash    |
+----------------+
8 rows in set (0.00 sec)


2.高级查询条件
2.1模糊匹配
WHERE 字段名 LIKE '通配字串'
通配符_匹配单个字符
通配符%匹配0-N个字符

mysql> select username from userinfo where username like "___";
+----------+			//匹配username三个字符的表记录
| username |
+----------+
| bin      |
| adm      |
| ftp      |
| rpc      |
| tss      |
| gdm      |
| ntp      |
| tom      |
+----------+
8 rows in set (0.00 sec)
mysql> select username from userinfo where username like "r%t";
+----------+
| username |
+----------+
| root     |
| rtkit    |
+----------+
2 rows in set (0.00 sec)
mysql> select username from userinfo where username like "____%";
//匹配username四个字符或以上的表记录
mysql> select username from userinfo where username like "%";
//这条匹配所有0个字符或0个字符以上的表记录[即非空(包括"",但不包括NULL)]

2.2正则匹配
WHERE 字段名 REGEXP '正则表达式' 
********************************************
实验准备:插入几条username字段包含数字的表记录
mysql> insert into userinfo(username) 
    -> values
    -> ("100t"),
    -> ("sktt1"),
    -> ("1G"),
    -> ("R1G");
********************************************
mysql> select username from userinfo 
    -> where 
    -> username regexp '[0-9]';
+----------+
| username |
+----------+
| 100t     |
| sktt1    |
| 1G       |
| R1G      |
+----------+
4 rows in set (0.00 sec)

mysql> select uid from userinfo where uid regexp '...';	
//正则匹配包含三个数字的uid，即三位或三位数以上的uid
mysql> select uid from userinfo where uid regexp '^...$';
//正则匹配三位数的uid
mysql> select username from userinfo where username regexp '^a|^r';
//正则匹配以a开头或r开头的username

2.3四则运算:字段必须是数值类型
类型	用途
+	加法
-	减法
*	乘法
/	除法
%	取余(求模)
mysql> select username,uid from userinfo where id<3;
+----------+------+
| username | uid  |
+----------+------+
| root     |    0 |
| bin      |    1 |
| daemon   |    2 |
+----------+------+
3 rows in set (0.00 sec)
mysql> update userinfo set uid=uid+1 where id<=3;
mysql> select username,uid from userinfo where id<=3;
+----------+------+
| username | uid  |
+----------+------+
| root     |    1 |
| bin      |    2 |
| daemon   |    3 |
+----------+------+
3 rows in set (0.00 sec)

mysql> alter table userinfo add age int(2) unsigned default 19 after username;
mysql> select username,age,2018-age bir_year from userinfo where username='root';
+----------+------+----------+
| username | age  | bir_year |
+----------+------+----------+
| root     |   19 |     1999 |
+----------+------+----------+
1 row in set (0.00 sec)

2.4聚集函数:MySQL内置数据统计函数
avg(字段名)：	求平均值
sum(字段名)：	求和
min(字段名)：	统计最小值
max(字段名)：	统计最大值
count(字段名)：	统计个数
mysql> select avg(age) from userinfo;
+----------+
| avg(age) |
+----------+
|  19.0000 |
+----------+
1 row in set (0.00 sec)
mysql> select sum(age) from userinfo;
+----------+
| sum(age) |
+----------+
|      912 |
+----------+
1 row in set (0.00 sec)
mysql> select min(uid) from userinfo;
+----------+
| min(uid) |
+----------+
|        1 |
+----------+
1 row in set (0.00 sec)
mysql> select max(uid) from userinfo;
+----------+
| max(uid) |
+----------+
|    65534 |
+----------+
1 row in set (0.00 sec)
mysql> select count(uid) from userinfo;
+------------+
| count(uid) |
+------------+
|         42 |
+------------+
1 row in set (0.00 sec)
//不统计空值NULL

3.操作查询结果
3.1查询结果排序:通常是数值类型字段
SELECT 字段名 FROM 表名 ORDER BY 字段名 asc或desc
mysql> select username,uid from userinfo order by uid;	//不指定默认升序(从小到大)
mysql> select username,uid from userinfo order by uid asc;	//升序
mysql> select username,uid from userinfo order by uid desc;	//降序

3.2查询结果分组
SELECT 字段名 FROM 表名 GROUP BY 字段名  //前后字段名要一致
mysql> select shell from userinfo group by shell;
+----------------+
| shell          |
+----------------+
| NULL           |
| /bin/bash      |
| /bin/false     |
| /bin/sync      |
| /sbin/halt     |
| /sbin/nologin  |
| /sbin/shutdown |
| /shell/bash    |
+----------------+
8 rows in set (0.00 sec)

3.3查询结果过滤
SELECT 字段名 FROM 表名 HAVING 条件表达式；
SELECT 字段名 FROM 表名 WHERE 条件 HAVING 条件表达式；
SELECT 字段名 FROM 表名 GROUP BY 字段名 HAVING 条件表达式或内置函数(如count(*)>4)；

3.4限制查询结果显示行数
SELECT 字段名 FROM 表名 LIMIT N;			//显示查询结果前N条记录
SELECT 字段名 FROM 表名 LIMIT N,M；			//显示指定范围内的查询记录
SELECT 字段名 FROM 表名 WHERE 条件查询 LIMIT N；		//显示查询结果前N条记录
SELECT 字段名 FROM 表名 WHERE 条件查询 LIMIT N,M；	//显示指定范围内的查询记录
//limit n:  从第一条开始显示n条
//limit n,m:从第n条后的一条开始，显示m条(第n条不会显示)
mysql> select username from userinfo;
+---------------------+
| username            |
+---------------------+
| root                |
| bin                 |
| daemon              |
| adm                 |
| lp                  |

mysql> select username from userinfo limit 1;
+----------+
| username |
+----------+
| root     |
+----------+
1 row in set (0.00 sec)

mysql> select username from userinfo limit 2,3;
+----------+
| username |
+----------+
| daemon   |
| adm      |
| lp       |
+----------+
3 rows in set (0.00 sec)


*补充：
select top n from 表名 可以仅显示前n条结果
=================================================================================
		         08.Dba1-day04
=================================================================================
#多表查询

1.复制表:赋值表Key属性不会被复制，需要自己重新建立键值
作用:备份表，快速建表
语法格式:create table 新表名 select * from 旧表名

a.备份表
mysql> create table t1 select * from db3.userinfo;
b.快速建表
mysql> create table db4.t2
    -> select * from db3.userinfo
    -> where 1=2;		//条件不可能成立，则仅复制表结构不复制表记录


2.多表查询
<方法1>
格式1
select 字段名列表  from  表a,表b...；
格式2
select 字段名列表  from  表a,表b...  where 条件;

以上格式的查询结果叫笛卡尔集,查询结果的总条目数=表a的纪录数Ｘ表b的纪录数

<方法2>
*****************************实验准备*********************************************
mysql> create table t4 select username,uid,shell from db3.userinfo limit 3;
mysql> create table t5 select username,uid,comment,homedir from db3.userinfo limit 3;
*********************************************************************************


嵌套查询
where子查询：把内层查询结果作为外层查询的查询条件
格式1
select 字段名列表 from 表A where 条件 (select 字段名列表 from 表A或表B )；
格式2
select 字段名列表 from 表A where 条件 (select 字段名列表 from 表A或表B where 条件)；

用法示例：
输出年龄小于平均年龄的学生的名字和年龄
select name,age from student where age < (select avg(age) from student)

单表where嵌套查询
mysql> update db3.userinfo set age=88 where id<=10;
mysql> select username,age from db3.userinfo where age > 
    -> (select avg(age) from db3.userinfo)；
+----------+------+
| username | age  |
+----------+------+
| root     |   88 |
| bin      |   88 |
| daemon   |   88 |
| adm      |   88 |
| lp       |   88 |
| sync     |   88 |
| shutdown |   88 |
| halt     |   88 |
| mail     |   88 |
| operator |   88 |
+----------+------+

多表where嵌套查询
mysql> select username from db3.userinfo where username in (select username from db4.t4);
+----------+
| username |
+----------+
| root     |
| bin      |
| daemon   |
+----------+
3 rows in set (0.00 sec)


连接查询

*****************************实验准备****************************************
mysql> create table t6 select username,uid,shell from db3.userinfo limit 4;
mysql> create table t7 select username,uid,shell from db3.userinfo limit 6;
****************************************************************************

<方法3>左连接:以左边的表为主查询，相同的记录匹配显示出来，不相同的以空显示
语法格式
select 字段名列表 from 表a LEFT JOIN 表b ON 条件表达式；


<方法4>右连接:以右边的表为主查询，相同的记录匹配显示出来，不相同的以空显示
语法格式
select 字段名列表 from 表a RIGHT JOIN 表b ON 条件表达式；

mysql> select * from t6 left join t7 on t6.uid=t7.uid;
+----------+------+---------------+----------+------+---------------+
| username | uid  | shell         | username | uid  | shell         |
+----------+------+---------------+----------+------+---------------+
| root     |    1 | /bin/bash     | root     |    1 | /bin/bash     |
| bin      |    2 | /sbin/nologin | bin      |    2 | /sbin/nologin |
| daemon   |    3 | /sbin/nologin | daemon   |    3 | /sbin/nologin |
| adm      |    4 | /sbin/nologin | adm      |    4 | /sbin/nologin |
+----------+------+---------------+----------+------+---------------+
4 rows in set (0.00 sec)

mysql> select * from t6 right join t7 on t6.uid=t7.uid;
+----------+------+---------------+----------+------+---------------+
| username | uid  | shell         | username | uid  | shell         |
+----------+------+---------------+----------+------+---------------+
| root     |    1 | /bin/bash     | root     |    1 | /bin/bash     |
| bin      |    2 | /sbin/nologin | bin      |    2 | /sbin/nologin |
| daemon   |    3 | /sbin/nologin | daemon   |    3 | /sbin/nologin |
| adm      |    4 | /sbin/nologin | adm      |    4 | /sbin/nologin |
| NULL     | NULL | NULL          | lp       |    5 | /sbin/nologin |
| NULL     | NULL | NULL          | sync     |    6 | /bin/sync     |
+----------+------+---------------+----------+------+---------------+
6 rows in set (0.00 sec)


#mysql管理工具

常见的管理工具
类型			界面	操作系统		说明
mysql			命令行	跨平台			MySQL官方bundle包自带
MySQL-Workbench		图形	跨平台			MySQL官方提供
MySQL-Front		图形	Windows			开源，轻量级客户端软件
phpMyAdmin		浏览器	跨平台			开源，需LAMP平台
Navicat			图形	Windows			专业、功能强大，商业版


部署数据库图形管理工具hpMyAdmin
########################################
基本思路
1.安装httpd、mysql、php-mysql及相关包
2.启动httpd服务程序
3.解压phpMyAdmin包，部署到网站目录
4.配置config.inc.php，指定MySQL主机地址
5.创建授权用户
6.浏览器访问、登录使用
########################################

准备软件包
[root@June ~]# scp 'phpMyAdmin-2.11.11-all-languages.tar.gz' 192.168.4.50:/root
phpMyAdmin-2.11.11-all-languages.tar.gz            100% 4218KB  73.3MB/s   00:00 
安装httpd,php,php-mysql
[root@host50 ~]# yum -y install httpd php php-mysql
重启httpd服务并设置开机自启
[root@host50 ~]# systemctl restart httpd
[root@host50 ~]# systemctl enable httpd
解压软件包到/var/www/html
[root@host50 ~]# tar -xf phpMyAdmin-2.11.11-all-languages.tar.gz -C /var/www/html
[root@host50 ~]# cd /var/www/html/
[root@host50 html]# mv phpMyAdmin-2.11.11-all-languages/ phpmyadmin
[root@host50 html]# chown -R apache:apache phpmyadmin/
[root@host50 html]# cd phpmyadmin/
[root@host50 phpmyadmin]# cp config.sample.inc.php config.inc.php
[root@host50 phpmyadmin]# vim config.inc.php 
$cfg['blowfish_secret'] = ''; -->$cfg['blowfish_secret'] = 'abcdefg'
//这里随便写一点东西就可以了
$cfg['Servers'][$i]['host'] = 'localhost';	
//本地连接这一行就不用修改若是远程连接数据库这一行也要改
真机访问测试
[root@June ~]# google-chrome 192.168.4.50/phpmyadmin
用户名:root
密码:123456


#用户授权及权限撤销
1.修改数据库管理员本机登录密码
[root@host50 ~]# mysqladmin -uroot -p123456 password "654321"

2.恢复管理员密码
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
#validate_password_policy=0
#validate_password_length=6:
skip_grant_tables
[root@host50 ~]# systemctl restart mysqld
[root@host50 ~]# mysql
mysql> select host,user,authentication_string from mysql.user;
+-----------+-----------+-------------------------------------------+
| host      | user      | authentication_string                     |
+-----------+-----------+-------------------------------------------+
| localhost | root      | *2A032F7C5BA932872F0F045E0CF6B53CF702F2C5 |
| localhost | mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
+-----------+-----------+-------------------------------------------+
mysql> update mysql.user
    -> set
    -> authentication_string=password("123456")
    -> where
    -> host="localhost" and user="root";
Query OK, 1 row affected, 1 warning (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 1

mysql> flush privileges;		
//若不执行这一步，则需要重启mysqld服务
mysql> quit

[root@host50 ~]# vim /etc/my.cnf
[mysqld]
validate_password_policy=0
validate_password_length=6
#skip_grant_tables
[root@host50 ~]# systemctl restart mysqld	
//若已经执行了mysql> flush privileges;则不需要再重启服务
[root@host50 ~]# mysql -uroot -p123456


#用户权限
1.权限存储位置：授权库（存储在mysql库里）
mysql> desc mysql.user; 用户
mysql> desc mysql.db;库
mysql> desc mysql.tables_priv;表
mysql> desc mysql.clomuns_priv; 字段

2.用户授权
mysql> grant all  on *.* 
    -> to
    -> mydba@"%"
    -> identified by "123456"
    -> with grant option;

查看权限（查看表记录方式）
select  *  from  mysql.user where user="mydba"\G;
select host,user from  mysql.user;

show  grants for mydba@"%"; （sql命令查看）

在任意客户端使用授权用户连接50主机，并验证授权权限
[root@host50 ~]# yum -y  install mariadb
[root@June ~]# which  mysql
/bin/mysql

[root@June ~]# mysql  -h192.168.4.50 -umydba  -p123456
MySQL [(none)]> select  user();
MySQL [(none)]> select @@hostname;	//查看当前连接的数据库服务器的主机名
MySQL [(none)]> show grants;

授权用户连接后修改登录密码，并使用修改的密码登录
[root@June ~]# mysql  -h192.168.4.50 -umydba  -p123456
MySQL [(none)]> set password = password("123abc");
Query OK, 0 rows affected, 1 warning (0.00 sec)
MySQL [(none)]>quit；
 
[root@room9pc17 ~]# mysql  -h192.168.4.50 -umydba  -p123abc
MySQL [(none)]>

数据库管理员，修改授权用户的连接密码
mysql> set password  for  mydba@"%"=password("123456");

在客户端，使用修改后的密码连接50数据库服务器
[root@June ~]# mysql  -h192.168.4.50 -umydba  -p123456
MySQL [(none)]>

测试mydba用户授权权限：创建新库 新表 对表记录的增删改查权限
                       及授权权限

MySQL [db4]> grant all on gamedb.* to test1@"localhost"
    -> identified by "123456";
Query OK, 0 rows affected, 1 warning (0.00 sec)


验证有授权权限添加的连接用户test1 :在数据库服务器50本机 ，
是否有test1用户
]# mysql  -uroot -p123456
mysql> select host,user from mysql.user;
mysql> show grants for test1@"localhost";
mysql> select  * from  mysql.db where db="gamedb"\G;
mysql> quit;

在数据库服务器50本机使用test1用户登录，测试对gamedb库的权限：
创建库表 记录增删改查 删除库表 都可以。
]# mysql  -utest1 -p123456
mysql> show databases;
mysql> create database  gamedb;


#revoke 权限撤销

撤销mydba用户的"授权权限"。
client50 ~]# mysql -uroot -p123456
mysql> revoke grant option on *.* from  mydba@"%";

撤销mydba用户的对"库和表的删除权限"（delete, drop）。
mysql> revoke delete,drop on  *.* from mydba@"%";

撤销mydba用户的"所有权限"
mysql> revoke all on  *.*  from  mydba@"%";

删除授权用户"mydba"
mysql> drop user  mydba@"%";


扩展知识1：
在50主机添加数据库连接用户 ：要求如下
用户名 admin
客户端地址 网络中的所有主机
权限 只对db3库有完全权限且有授权权限
登录密码 123456

mysql> grant all on  db3.* to admin@"%" identified by "123456"
with grant option;

mysql> grant insert on mysql.* to admin@"%";

mysql> show  grants for admin@"%";

测试授权用户admin：
在客户端使用admin用户连接数据服务器50 对库的访问权限及授权权限。

测试授权权限：添加授权用户admin2  密码123456。
                             权限和自己的权限一样。
MySQL [(none)]> grant all on  db3.* to admin2@"%"  
identified by "123456";

扩展知识2：
在50主机 授权如下：
mysql>grant all  on  *.*  to  root@"192.168.4.254" 
identified by "123456";


执行如下撤销权限命令能否成功？
不能成功：撤销权限时，库名的表示方式要和授权时一样
mysql>reovek  delete  on db44.* from  root@"192.168.4.254"；



权限的关键字：
SELECT,DELETE,DROP, INSERT, UPDATE, CREATE, 
RELOAD, SHUTDOWN, PROCESS, FILE, 
REFERENCES, INDEX, ALTER, SHOW DATABASES, 
SUPER, CREATE TEMPORARY TABLES, 
LOCK TABLES, EXECUTE, 
REPLICATION SLAVE, REPLICATION CLIENT, 
CREATE VIEW, SHOW VIEW, CREATE ROUTINE, 
ALTER ROUTINE, CREATE USER, EVENT, 
TRIGGER, CREATE TABLESPACE 


=================================================================================
		         08.Dba1-day05
=================================================================================
#数据备份/恢复

数据备份方式

物理备份:cp,tar...
备份
[root@host50 ~]# mkdir /datadir
[root@host50 ~]# cp -r /var/lib/mysql /datadir/mysql.bak
[root@host50 ~]# scp -r /datadir/mysql.bak/ 192.168.4.51:/root/
恢复
[root@mysql51 ~]# rm -rf /var/lib/mysql
[root@mysql51 ~]# systemctl stop mysqld
[root@mysql51 ~]# cp -r /root/mysql.bak/ /var/lib/mysql
[root@mysql51 ~]# chown -R mysql:mysql /var/lib/mysql
[root@mysql51 ~]# systemctl start mysqld
[root@mysql51 ~]# mysql -uroot -p123456

逻辑备份
数据备份策略：
完全备份:备份所有数据:一台服务器、一个库、一张表
增量备份:备份自上一次备份(包含完全备份、差异备份、增量备份)之后有变化的数据
差异备份:备份自上一次完全备份之后有变化的数据
//生产环境下备份方法:完全+差异或完全+增量

完全备份数据/完全恢复数据
mysqldump
mysql

备份操作
mysqldump -uroot -p 库名 > /路径/xxx.sql
恢复操作
mysql -uroot -p [库名] < /路径/xxx.sql		
//恢复单个库和单个表时才需要写库名
//恢复单个库和单个表的时候需要自己创建库，恢复多个库则会自动创建库不需要手动创建
############################################
第二种恢复方法
use db5;			//先进入库
sourse /datadir/db5_t1.sql	
############################################

库名的表示
所有库		--all-databases 或 -A 
单个库		数据库名		
单张表		数据库名 表名          
备份多个库	-B 数据库1 数据库2 

注意事项
无论备份还是恢复，都要验证用户及权限

自动备份:
配合crontab，写自动备份脚本
每周一23:30 备份数据库服务器上的所有数据到系统的/datadir目录下使用系统日期做备份文件名

缺点：
不是实时备份，在两次备份的真空期如果出现误操作，无法恢复


增量备份数据/增量恢复设备
方法1.使用binlog日志文件实现增量备份和恢复

binlog日志的使用:
binlog日志:二进制日志，记录所有除查询之外的操作(即更改数据的操作)


启用binlog日志
修改配置文件
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
log_bin
server_id=50			//一般是主机ip的主机位
binlog_format="mixed"
[root@host50 ~]# systemctl restart mysqld
binlog相关文件
[root@host50 ~]# ls /var/lib/mysql
host50-bin.index  记录已有日志文件名	//主机名-bin.index
host50-bin.000001 第1个二进制日志	//主机名-bin.000001
host50-bin.000002 第2份二进制日志	//主机名-bin.000002
查看日志文件内容
[root@host50 ~]# mysqlbinlog /var/lib/mysql/host50-bin.000001 

启用binlog日志文件时还可以指定存储位置和日志文件名
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
#log_bin		//注释一行
log_bin=/logdir/db	//添加一行
server_id=50			
binlog_format="mixed"
[root@host50 ~]# mkdir /logdir
[root@host50 ~]# chown mysql:mysql /logdir/
[root@host50 ~]# ls -ld /logdir/
[root@host50 ~]# systemctl restart mysqld
[root@host50 ~]# ls /logdir/		//可以查看到新生成的日志文件
db.000001  db.index

测试操作
在数据库服务器执行sql命令，查看日志文件是否记录查询之外的sql命令
mysql> select * from tb1;
mysql> insert into tb1 values(777);
mysql> insert into tb1 values(777);
mysql> insert into tb1 values(777);
mysql> update tb1 set user=888;
mysql> delete from tb1;
[root@host50 ~]# mysqlbinlog /logdir/db.000001 | grep -i select
[root@host50 ~]# mysqlbinlog /logdir/db.000001 | grep -i delete
[root@host50 ~]# mysqlbinlog /logdir/db.000001 | grep -i desc
//查询的均没有记录
[root@host50 ~]# mysqlbinlog /logdir/db.000001 | grep -i insert
insert into tb1 values(777,777)
insert into tb1 values(777,777)
insert into tb1 values(777,777)
[root@host50 ~]# mysqlbinlog /logdir/db.000001 | grep -i update
update tb1 set user=888


使用binlog日志恢复数据
先使用mysqlbinlog命令查看起始偏移量和结束偏移量
[root@host50 ~]# mysqlbinlog /logdir/db.000001 
# at 后面的数字是偏移量
mysqlbinlog --start-position=298 --stop-position=1285 /logdir/db.000001  | mysql -uroot -p123qqq...A
//--start-position:起始偏移量，--stop-position:结束偏移量
mysql> select * from tb1;
如果不是想恢复指定范围内的命令的话，可以不用指定起始偏移量
[root@host50 ~]# mysqlbinlog --stop-position=1382 /logdir/db.000001  | mysql -uroot -p123qqq...A


mysql> drop table tb1;
[root@host50 ~]# mysql -uroot -p dab5 < /datadir/db5.sql 
[root@host50 ~]# mysqlbinlog --start-datetime="2018-10-20 14:04:53" --stop-datetime="2018-10-20 14:05:19" /logdir/db.000001  | mysql -uroot -p123qqq...A
mysql> select * from tb1;
//--start-position:起始时间，--stop-position:结束时间

手动创建新的binlog日志(默认日志容量大于500m，才自动创建新的日志文件)

查看服务目前正在使用的日志文件和偏移量
mysql> show master status;
+-----------+----------+--------------+------------------+-------------------+
| File      | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------+----------+--------------+------------------+-------------------+
| db.000001 |    12677 |              |                  |                   |
+-----------+----------+--------------+------------------+-------------------+
刷新一下日志文件
mysql> flush logs; 或 [root@host50 ~]# mysql -uroot -p123qqq...A -e "flush logs"
//-e 代表命令行下执行mysql命令
再查看，变成了db.000002
mysql> show master status;
+-----------+----------+--------------+------------------+-------------------+
| File      | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------+----------+--------------+------------------+-------------------+
| db.000002 |      154 |              |                  |                   |
+-----------+----------+--------------+------------------+-------------------+
还可以在执行完全备份之后执行--flush-logs
[root@host50 ~]# mysqldump -uroot -p123qqq...A --flush-logs dab5 > /root/db5.sql
mysql> show master status;
+-----------+----------+--------------+------------------+-------------------+
| File      | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------+----------+--------------+------------------+-------------------+
| db.000003 |      154 |              |                  |                   |
+-----------+----------+--------------+------------------+-------------------+
重启服务也可以，但是生产环境下一般不用，重启服务会影响服务器正常运作
[root@host50 ~]# systemctl restart mysqld
mysql> show master status;
+-----------+----------+--------------+------------------+-------------------+
| File      | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-----------+----------+--------------+------------------+-------------------+
| db.000004 |      154 |              |                  |                   |
+-----------+----------+--------------+------------------+-------------------+


清理binlog日志
删除早于指定版本的binlog日志
mysql> purge  master  logs  to  "binlog文件名";
//mysql> purge master logs to "db.000003";

删除所有binlog日志，重建新日志
mysql> reset  master;


方法2.使用innobackupex命令实现增量备份和恢复
innobackupex可以实现完全备份和恢复，增量备份和恢复，恢复完全备份中的某个表
1.安装percona软件包
[root@host50 ~]# rpm -ivh /root/libev-4.15-1.el6.rf.x86_64.rpm	//装依赖包
[root@host50 ~]# yum -y install /root/percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm //yum安装可以解决依赖关系
2.查看命令帮助手册
[root@host50 ~]# man innobackupex
[root@host50 ~]# man xtrabackup 


先把数据库存储引擎默认修改为innodb
[root@host50 ~]# vim /etc/my.cnf
[mysqld]
#default-storage-engine=myisam
[root@host50 ~]# systemctl restart mysqld
新建库与表
mysql> create database db5;
mysql> create table db5.a(id int);
mysql> insert into db5.a values(110);
mysql> insert into db5.a values(110);
mysql> insert into db5.a values(110);
mysql> select * from db5.a;
+------+
| id   |
+------+
|  110 |
|  110 |
|  110 |
+------+
#############################################################################
innobackupex基本选项备份数据
常用选项			含义
--host				主机名
--user				用户名
--port				端口号
--password			密码
--databases			数据库名
********************************
//关于--databases选项
--databases="库名"	//单个库
--databases="库1 库2"	//多个库
--databases="库.表"	//单个表	
********************************
--no-timestamp			不用日期命名备份文件存储的子目录名
--redo-only			日志合并
--apply-log			准备还原(回滚日志)
--copy-back			恢复数据
--incremental			目录名增量备份
--incremental--basedir=目录名	增量备份时，指定上一次备份数据存储的目录名
--incremental-dir=目录名	准备恢复数据时，指定增量备份数据存储的目录名
--export			导出表信息
--import			导入表空间
#############################################################################
完全备份

[root@host50 ~]# innobackupex --host localhost --user root --password 123qqq...A /allbak --no-timestamp
[root@host50 ~]# ls /allbak	查看备份目录


完全恢复数据

[root@host50 ~]# systemctl stop mysqld
[root@host50 ~]# rm -rf  /var/lib/mysql/*  //恢复时要求空的库目录
[root@host50 ~]# innobackupex  --apply-log /allbak	//准备恢复数据:同步日志
[root@host50 ~]# innobackupex  --copy-back /allbak	//恢复数据
[root@host50 ~]# ls /var/lib/mysql
[root@host50 ~]# chown  -R mysql:mysql /var/lib/mysql
[root@host50 ~]# systemctl  start mysqld
[root@host50 ~]# mysql  -uroot   -p123qqq...A
mysql> show  databases;
mysql> select * from db5.a;


增量备份:备份首次备份后的所有新产生的数据
完全备份
[root@host50 ~]# innobackupex --user root --password 123qqq...A /fullbak --no-timestamp
写入新数据
mysql> insert into db5.a values(120),(120),(120),(120);
增量备份（第一次）
[root@host50 ~]# innobackupex --user root --password 123qqq...A --incremental /new1 --incremental-basedir=/fullbak --no-timestamp
查看备份信息
[root@host50 ~]# ls /fullbak/
[root@host50 ~]# ls /new1/
增量备份（第二次）
[root@host50 ~]# innobackupex --user root --password 123qqq...A --incremental /new2 --incremental-basedir=/fullbak --no-timestamp
[root@host50 ~]# ls /new2/

查看备份信息
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = full-backuped		//备份类型是full-backuped
from_lsn = 0
to_lsn = 2548206
last_lsn = 2548215
compact = 0
recover_binlog_info = 0

[root@host50 ~]# cat /new1/xtrabackup_checkpoints 
backup_type = incremental
from_lsn = 2548206
to_lsn = 2548206
last_lsn = 2548215
compact = 0
recover_binlog_info = 0

[root@host50 ~]# cat /new2/xtrabackup_checkpoints 
backup_type = incremental
from_lsn = 2548206
to_lsn = 2550225
last_lsn = 2550234
compact = 0
recover_binlog_info = 0


增量恢复
准备恢复数据--apply-log
合并日志--redo-only
拷贝数据--copy-back
指定增量恢复数据的目录名 --incremental-dir
[root@host50 ~]# systemctl stop mysqld
[root@host50 ~]# rm -rf /var/lib/mysql/*
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = full-backuped
准备恢复
[root@host50 ~]# innobackupex --apply-log --redo-only /fullbak/
[root@host50 ~]# cat /fullbak/xtrabackup_checkpoints 
backup_type = log-applied		//这个字段变成log-applied
将增量备份的数据合并到完全备份文件夹
[root@host50 ~]# innobackupex --apply-log --redo-only /fullbak/ --incremental-dir=/new1/
[root@host50 ~]# innobackupex --apply-log --redo-only /fullbak/ --incremental-dir=/new2/
[root@host50 ~]# innobackupex --copy-back /fullbak/
[root@host50 ~]# ls /var/lib/mysql
[root@host50 ~]# chown -R mysql:mysql /var/lib/mysql
[root@host50 ~]# systemctl restart mysqld
[root@host50 ~]# mysql -uroot -p123qqq...A
mysql> show databases;
备份新产生的数据
mysql> insert into db5.a values(2121);
mysql> insert into db5.a values(2121);
mysql> insert into db5.a values(2121);
mysql> insert into db5.a values(2121);
[root@host50 ~]# innobackupex --user root --password 123qqq...A --incremental /dir1 --incremental-basedir=/fullbak --no-timestamp


恢复完全备份中的某个表
新建表并插入多条数据
mysql> create table db5.b(id int);
mysql> insert into db5.b values(119),(119),(119),(119);
对db5做完全备份
[root@host50 ~]# innobackupex --user root --password 123qqq...A --databases="db5" /db5bak --no-timestamp
查看备份文件夹
[root@host50 ~]# ls /db5bak/
删除db5库里的a表
mysql> drop table db5.a;
恢复前要创建一个表结构与删除前相同的空表
mysql> create table db5.a(id int);

删除表空间(相当于删除/var/lib/mysql/db5/a.ibd)
mysql> alter table db5.a discard tablespace;

导出表信息, 并拷贝到数据库目录下
[root@host50 ~]# innobackupex --user root --password 123qqq...A --databases="db5" --apply-log  --export /db5bak		//--export /db5bak 代表指定从/db5bak里导出
[root@host50 ~]# ls /db5bak/db5/
a.cfg  a.exp  a.frm  a.ibd  b.cfg  b.exp  b.frm  b.ibd  db.opt
[root@host50 ~]# cp /db5bak/db5/a.{cfg,exp,ibd} /var/lib/mysql/db5/
[root@host50 ~]# ls /var/lib/mysql/db5/a.*
/var/lib/mysql/db5/a.cfg  /var/lib/mysql/db5/a.frm
/var/lib/mysql/db5/a.exp  /var/lib/mysql/db5/a.ibd
[root@host50 ~]# chown mysql:mysql /var/lib/mysql/db5/a.*

导入表信息，并删除表信息文件
mysql> select * from db5.a;	//导入表信息前，查看a表会报错
ERROR 1814 (HY000): Tablespace has been discarded for table 'a'
mysql> alter table db5.a import tablespace;
mysql> select * from db5.a;
mysql> system rm -rf /var/lib/mysql/db5/a.{cfg,exp}
mysql> system ls /var/lib/mysql/db5
a.frm  a.ibd  b.frm  b.ibd  db.opt


=================================================================================
		         09.Dba2-day01
=================================================================================
#部署mysql主从同步(存储数据的结构)

client50 			
   ↓				
 mysql51----->mysql52 
主库服务器     从库服务器
客户端对主库所做的一切操作都会同步到从库上(即从主库上同步数据到从库)

主从同步结构模式
单向复制:主-->从
一主多从:从<--主-->从
链式复制:主-->从-->从
双向复制:主(从)<-->从(主)
放射复制:从<--主-->从
	     ↓
	     从


配置主库服务器(mysql51)
启用binlog日志
mysql> system vim /etc/my.cnf
[mysqld]
server_id=51
log_bin=mysql51
binlog_format="mixed"
mysql> system systemctl restart mysqld
用户授权
mysql> grant replication slave on *.* to repluser@"%" identified by "123qqq...A";
mysql> select host,user from mysql.user where user="repluser";
+------+----------+
| host | user     |
+------+----------+
| %    | repluser |
+------+----------+
查看当前正在使用的binlog日志及偏移量
mysql> show master status;
+----------------+----------+
| File           | Position | 
+----------------+----------+
| mysql51.000001 |      154 |
+----------------+----------+


配置从库服务器(mysql52)
指定server_id
mysql> system vim /etc/my.cnf
[mysqld]
server_id=52
mysql> system systemctl restart mysqld
指定主库信息
mysql> change master to
    -> master_host="192.168.4.51",
    -> master_user="repluser",
    -> master_password="123qqq...A",
    -> master_log_file="mysql51.000001",
    -> master_log_pos=154;
启动slave程序
mysql> start slave;
查看slave程序的状态信息
mysql> show slave status\G;
             Slave_IO_Running: Yes
             Slave_SQL_Running: Yes
######################################################
如果Slave_IO_Running: No
则检查一下主从两台机子的/var/lib/mysql/auto.cnf文件
看看uuid是否一样，如果一样
则在从库服务器执行以下操作重新获取uuid
[root@mysql52 ~]# mv /var/lib/mysql/auto.cnf{,.bak}
[root@mysql52 ~]# systemctl restart mysqld
######################################################
测试主从同步配置
在客户端50主机连接主机51对数据做访问
在主库51上添加授权用户给客户端50主机连接使用
mysql> create database db1;
mysql> create table db1.a(id int);
mysql> grant select,insert,update on db1.* to admin@"%" identified by "123qqq...A";
在客户端50主机连接主库服务器51对记录做访问
[root@host50 ~]# mysql -h192.168.4.51 -uadmin -p123qqq...A
mysql> select @@hostname;
mysql> insert into db1.a values(111),(1112),(113);
mysql> select * from db1.a;
在从库服务器52本机也能查看到同样数据为成功
mysql> select * from db1.a

#配置主多从同步结构
配置从数据库服务器53
[root@mysql53 ~]# vim /etc/my.cnf
[mysqld]
server_id=53
[root@mysql53 ~]# systemctl restart mysqld
指定主库信息
mysql> change master to
    -> master_host="192.168.4.51",
    -> master_user="repluser",
    -> master_password="123qqq...A",
    -> master_log_file="mysql51.000001",
    -> master_log_pos=154;
启动slave程序
mysql> start slave;
查看slave程序的状态信息
mysql> show slave status\G;
             Slave_IO_Running: Yes
             Slave_SQL_Running: Yes
测试：在50客户端访问51写入数据，在52和53上都能查询到就成功了

#配置从库暂时不同步主库的数据
在mysql52上停止slave程序
mysql> stop slave;
mysql> show slave status\G;
            Slave_IO_Running: No
            Slave_SQL_Running: No
在客户端访问mysql51插入数据
mysql> insert into db1.a values(7799);
在mysql52上查看新插入的数据:没有同步
mysql> select * from db1.a;
+------+
| id   |
+------+
|  111 |
| 1112 |
|  113 |
+------+
在mysql53上查看新插入的数据:同步了
mysql> select * from db1.a;
+------+
| id   |
+------+
|  111 |
| 1112 |
|  113 |
| 7799 |
+------+
在mysql52再次开启slave程序，再查看一次
mysql> start slave;
mysql> select * from db1.a;	//不需要任何操作就自动同步了
+------+
| id   |
+------+
|  111 |
| 1112 |
|  113 |
| 7799 |
+------+

#把mysql53还原为独立的数据服务器(不再是mysql51的从库服务器)
[root@mysql53 ~]# systemctl stop mysqld
[root@mysql53 ~]# rm -rf /var/lib/mysql/master.info 
[root@mysql53 ~]# rm -rf /var/lib/mysql/mysql53-relay-bin.*
[root@mysql53 ~]# rm -rf /var/lib/mysql/relay-log.info 
[root@mysql53 ~]# vim /etc/my.cnf
#server_id=53
[root@mysql53 ~]# systemctl start mysqld
[root@mysql53 ~]# mysql -uroot -p123qqq...A
mysql> show slave status\G;
Empty set (0.00 sec)


#配置主从同步结构(将mysql53配置成mysql52的从库服务器)
配置主库51:启用binlog日志,用户授权,查看日志信息-->已完成

配置从库52:
主配置文件里-->启用log_slave_updates配置
做主库的配置-->启用binlog日志,用户授权,查看日志信息
做从库的配置-->指定server_id,指定主库信息,启动slave程序,查看slave程序状态信息-->已完成
[root@mysql52 ~]# vim /etc/my.cnf
[mysqld]
log_slave_updates
server_id=52
log_bin=slave52
binlog_format="mixed"
[root@mysql52 ~]# systemctl restart mysqld
mysql> grant replication slave on *.* to repluser2@"%" identified by "123qqq...A";
mysql> show master status;
+----------------+----------+
| File           | Position |
+----------------+----------+
| slave52.000002 |      442 |
+----------------+----------+
mysql> show slave status\G;	//查看一下slave是否正常运行
            Slave_IO_Running: Yes
            Slave_SQL_Running: Yes


配置从库53:
配置准备工作-->在没有配置为从库之前要与主库数据一致
做从库的配置-->指定server_id,指定主库信息,启动slave程序,查看slave程序状态信息
[root@mysql53 ~]# vim /etc/my.cnf
[mysqld]
server_id=53
[root@mysql53 ~]# systemctl restart mysqld
mysql> change master to 
    -> master_host="192.168.4.52",
    -> master_user="repluser2",
    -> master_password="123qqq...A",
    -> master_log_file="slave52.000002",
    -> master_log_pos=442;
mysql> start slave;
mysql> show slave status\G;	
            Slave_IO_Running: Yes
            Slave_SQL_Running: Yes

客户端50测试：
访问数据库服务器mysql51
[root@host50 ~]# mysql -h192.168.4.51 -uadmin -p123qqq...A
mysql> insert into db1.a values(123);
再分别到52和53上查看
mysql> select * from db1.a;
+------+
| id   |
+------+
|  111 |
| 1112 |
|  113 |
| 7799 |
|  123 |
+------+

#主从配置常用参数
1.主库配置文件的参数(对所有从库有效)
[master]# vim /etc/my.cnf
[mysqld]
格式:选项=值
binlog_do_db=库名列表		//只允许同步库
binlog_Ignore_DB=库名列表	//只不允许同步库
[master]# sytemctl restart mysqld

2.从库配置文件的参数(仅对从库本机有效)
[slave]# vim /etc/my.cnf
[mysqld]
格式:选项=值
replicate_do_db=库名列表	//只同步的库
replicate_ignore_db=库名列表	//只不同步的库
[slave]# sytemctl restart mysqld

#mysql主从同步复制模式 
#################################################################################
异步复制:主库执行完客户端提交的事务后立即将结果返给客户端，不关心从库是否已经接收并处理
全同步复制:主库执行完一个事务，所有的从库都执行了该事务才返回给客户端
半同步复制:主库在执行完客户端提交的事务后不是立刻就返回给客户端
	  而是等待至少1个从库接收并写到relaylog才返回给客户端
*mysql默认模式是异步复制
*异步复制如果主库宕机,此时主库上已经提交的事务可能并没有传到从库上
 如果此时,强行将从库提升为主库,可能导致新主库上的数据不完整
*因为需要等待所有从库执行完该事务才能返回,所以全同步复制的性能必然会收到严重的影响
*半同步复制是介于异步复制和全同步复制之间的一种模式
*半同步复制相对于异步复制,提高了数据的安全性,同时也造成了一定程度的延迟
 这个延迟最少是一个TCP/IP往返的时间
 所以,半同步复制最好在低延时的网络中使用
#################################################################################

查看是否可以动态加载模块
mysql> show variables like  "have_dynamic_loading";
主库安装的模块
mysql> INSTALL PLUGIN rpl_semi_sync_master  SONAME 'semisync_master.so';
从库安装的模块
mysql>  INSTALL PLUGIN rpl_semi_sync_slave  SONAME 'semisync_slave.so';

查看系统库下的表，模块是否安装成功
mysql> SELECT PLUGIN_NAME,PLUGIN_STATUS 
FROM INFORMATION_SCHEMA.PLUGINS  
WHERE 
PLUGIN_NAME  LIKE   '%semi%';

启用半同步复制模式
主库
mysql> SET GLOBAL rpl_semi_sync_master_enabled = 1;
从库
mysql> SET GLOBAL rpl_semi_sync_slave_enabled = 1;
查看半同步复制模式是否启用
mysql>  show  variables  like  "rpl_semi_sync_%_enabled";


修改配置文件/etc/my.cnf让安装模块和启用的模式永久生效
主库
vim /etc/my.cnf
[mysqld]
plugin-load=rpl_semi_sync_master=semisync_master.so
rpl_semi_sync_master_enabled=1
从库
vim /etc/my.cnf
[mysqld]
plugin-load=rpl_semi_sync_slave=semisync_slave.so
rpl_semi_sync_slave_enabled=1
既做主又做从
vim /etc/my.cnf
[mysqld]
plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-master-enabled = 1
rpl-semi-sync-slave-enabled = 1


=================================================================================
		         09.Dba2-day02
=================================================================================
#mysql数据读写分离
概念:把客户端查询数据的请求和存储数据的请求分别给不同的数据库服务器处理
client50 --> select --> mysql51
client50 --> insert --> mysql52
----------------项目拓扑----------------
	 	 client
		 主机50
		   ↓
		 proxy
	      代理服务器53
	       ↙      ↘
	 INSERT		SELECT
	 主库52		从库51
---------------------------------------
-----------------环境准备-----------------
1.把51配置为52的从库
2.主机53修改主机名:proxy53,停止mysqld服务
3.准备proxy53需要的软件包
[root@proxy53 ~]# ls maxscale*.rpm 
maxscale-2.1.2-1.rhel.7.x86_64.rpm
-----------------------------------------
配置代理服务器proxy53
1.安装软件包
[root@proxy53 ~]# rpm -ivh maxscale-2.1.2-1.rhel.7.x86_64.rpm
*可实现数据读写分离的软件(中间件的一种):mycat,mysql-proxy,maxscale 
2.修改配置文件
[root@proxy53 ~]# cp /etc/maxscale.cnf /root/		//备份配置文件
[root@proxy53 ~]# vim /etc/maxscale.cnf
[maxscale]					//指定服务启动线程数量
threads=1 -->threads=auto			//根据CPU性能自动调整

//注释以下5行
#[server1]
#type=server
#address=127.0.0.1 
#port=3306
#protocol=MySQLBackend
//参考上面的模板添加[server1和server2]
[server1]					//指定第一台数据库服务器
type=server
address=192.168.4.51				//指定数据库服务器的ip地址
port=3306
protocol=MySQLBackend

[server2]					//指定第二台数据库服务器
type=server
address=192.168.4.52
port=3306
protocol=MySQLBackend

[MySQL Monitor]
type=monitor
module=mysqlmon
servers=server1 -->servers=server1,server2	//指定监视server1和server2
user=myuser -->user=scalemon			//指定监视server1和server2的数据库
passwd=mypwd -->passwd=123qqq...A		  服务及主从同步状态用的帐号和密码
monitor_interval=10000

//注释以下7行，代表不定义只读服务器
#[Read-Only Service]
#type=service
#router=readconnroute
#servers=server1
#user=myuser
#passwd=mypwd
#router_options=slave

[Read-Write Service]				//定义读写分离服务
type=service
router=readwritesplit
servers=server1 -->servers=server1,server2   //指定server1,2为读写分离数据库服务器
user=myuser -->user=maxscale			//代理服务器用于验证客户端请求访问
passwd=mypwd -->passwd=123qqq...A		  的授权信息是否正确的用户名和密码
max_slave_connections=100%

//定义管理服务，不需要修改
[MaxAdmin Service]
type=service
router=cli

//注释以下5行，不定义只读服务
#[Read-Only Listener]
#type=listener
#service=Read-Only Service
#protocol=MySQLClient
#port=4008

//指定读写分离服务的端口号:4006，不需要修改
[Read-Write Listener]
type=listener
service=Read-Write Service
protocol=MySQLClient
port=4006

[MaxAdmin Listener]
type=listener
service=MaxAdmin Service
protocol=maxscaled
socket=default -->socket=4016		//指定管理服务的端口号(可自定义)

3.根据配置文件的设置,在数据库服务器上添加对应的授权用户
-*在主库52做用户授权，主机51会自动把授权操作同步到本机
//创建监控用户
mysql> grant replication slave,replication client on *.* to scalemon@"%" identified by "123qqq...A";
//创建用于"代理服务器验证客户端授权信息是否正确"的用户
mysql> grant select on mysql.* to maxscale@"%" identified by "123qqq...A";
//创建给客户端用于登录的用户
mysql> create database db2;
mysql> create table db2.a(id int);
mysql> grant select,insert on db2.* to webuser@"%" identified by "123qqq...A";


4.启动服务并查看服务信息
[root@proxy53 ~]# maxscale -f /etc/maxscale.cnf		//无输出才是正确的
[root@proxy53 ~]# ss -nultp | grep :4006
[root@proxy53 ~]# ss -nultp | grep :4016
########################################################
//如果报错说服务已经启动,但是4006和4016端口没有同时启动
//则先杀死程序，然后再次启动服务
[root@proxy53 ~]# pkill -9 maxscale
########################################################

5.访问管理服务查看配置信息
[root@proxy53 ~]# maxadmin -uadmin -pmariadb -P4016
MaxScale> list servers
Servers.	//running代表数据库服务正在运行,slave和master代表主从同步正常
-------------------+-----------------+-------+-------------+--------------------
Server             | Address         | Port  | Connections | Status              
-------------------+-----------------+-------+-------------+--------------------
server1            | 192.168.4.51    |  3306 |           0 | Slave, Running
server2            | 192.168.4.52    |  3306 |           0 | Master, Running
-------------------+-----------------+-------+-------------+--------------------
MaxScale> exit

6.测试读写分离配置:客户端连接代理服务器,访问数据:能够实现数据读写分离功能
[root@client50 ~]# mysql -h192.168.4.53 -P4006 -uwebuser -p"123qqq...A"
测试：在从库51上写入一条数据，不会同步到主库52，就能区分从库和主库了
mysql> insert into db2.a values(666);
到客户端查询这条数据,能查到说明读写分离成功
mysql> select * from db2.a where id=666;

#mysql多实例
概念:在1台服务上运行多个数据库服务器(类似web服务器的虚拟主机)
##########################################
实验准备:
停止原有的mysql服务
[root@host50 ~]# systemctl stop mysqld
将配置文件移动到/root下备份
[root@host50 ~]# mv /etc/my.cnf /root/
准备软件包
[root@host50 ~]# ls mysql-*linux*
mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
##########################################
安装提供多实例服务的mysql软件包	//已经编译安装好，直接解压就可以
[root@host50 ~]# tar -zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz 
移动并改名
[root@host50 ~]# mv mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql
[root@host50 ~]# ls /usr/local/mysql/
bin  COPYING  docs  include  lib  man  README  share  support-files
#######################################
为了方便，也可以将程序路径指定为PATH变量值
[root@host50 ~]# tail -1 /etc/profile
export  PATH=/usr/local/mysql/bin:$PATH
[root@host50 ~]# source /etc/profile
########################################
创建主配置文件
[root@host50 ~]# vim /etc/my.cnf
[mysqld_multi]					//启用多实例
mysqld=/usr/local/mysql/bin/mysqld_safe		//指定多实例启动时调用的文件
mysqladmin=/usr/local/mysql/bin/mysqladmin	//指定管理命令路径
user=root					//指定调用进程的用户
[mysql1]					//mysqld1代表第一个数据库服务
datadir=/datadir3307				//指定数据库目录路径
socket=/datadir3307/mysql3307.sock  //客户端连接访问数据库要用socket文件传输数据信息
port=3307					//指定端口号
log-error=/datadir3307/mysqld3307.log		//指定错误日志路径
pid-file=/datadir3307/mysqld3307.pid		//指定进程pid号文件路径
[mysql2]
datadir=/datadir3308
socket=/datadir3308/mysql3308.sock
port=3308
log-error=/datadir3308/mysqld3308.log
pid-file=/datadir3308/mysqld3308.pid

创建数据库目录
[root@host50 ~]# mkdir /datadir3307
[root@host50 ~]# mkdir /datadir3308

启动多实例服务
[root@host50 ~]# /usr/local/mysql/bin/mysqld_multi start 1	//1代表mysql1
root@localhost: ueu_v%TMe8yz		//查看输出结果最后一行,自动生成初始化密码
[root@host50 ~]# ls /datadir3307/	//数据库目录自动生成数据库文件
[root@host50 ~]# /usr/local/mysql/bin/mysql -uroot -p'ueu_v%TMe8yz' -S /datadir3307/mysql3307.sock
//-S指定sock文件路径
mysql> alter user root@localhost identerfied by '123456';
mysql> quit
[root@host50 ~]# ss -nultp | grep :3307
[root@host50 ~]# /usr/local/mysql/bin/mysql -uroot -p123456 -S /datadir3307/mysql3307.sock
启动第二台数据库服务器
[root@host50 ~]# /usr/local/mysql/bin/mysqld_multi start 2	//2代表mysql2
[root@host50 ~]# /usr/local/mysql/bin/mysql -uroot -p'g*ekz%b-0dOF' -S /datadir3308/mysql3308.sock
mysql> alter user root@localhost identified by '123456';
mysql> quit
[root@host50 ~]# ss -nultp | grep :3308
[root@host50 ~]# /usr/local/mysql/bin/mysql -uroot -p123456 -S /datadir3308/mysql3308.sock

停止多实例服务
[root@host50 ~]# /usr/local/mysql/bin/mysqld_multi --user=root --password=123456 stop 1
[root@host50 ~]# ss -nultp | grep :3307
[root@host50 ~]# /usr/local/mysql/bin/mysqld_multi start 1
[root@host50 ~]# /usr/local/mysql/bin/mysqld_multi --user=root --password=123456 stop 2
[root@host50 ~]# ss -nultp | grep :3308


=================================================================================
		         09.Dba2-day03
=================================================================================
#配置mysql集群

#################################################################################
环境准备：
	    	      master51
	        	 ￤
    ---------------------------------------------
   |		|         |         |		 |
slave52    slave53   slave54     slave55      mgm56(Manager)
                                              
公共配置：在主机51-56上安装软件包
# cd  mha-soft-student
# ls  
mha4mysql-manager-0.56.tar.gz
mha4mysql-node-0.56-0.el6.noarch.rpm
perl-Config-Tiny-2.14-7.el7.noarch.rpm
perl-Email-Date-Format-1.002-15.el7.noarch.rpm
perl-Log-Dispatch-2.41-1.el7.1.noarch.rpm
perl-Mail-Sender-0.8.23-1.el7.noarch.rpm
perl-Mail-Sendmail-0.79-21.el7.art.noarch.rpm
perl-MIME-Lite-3.030-1.el7.noarch.rpm
perl-MIME-Types-1.38-2.el7.noarch.rpm
perl-Parallel-ForkManager-1.18-2.el7.noarch.rpm
# yum -y  install  perl-*.rpm
# yum -y install mha4mysql-node-0.56-0.el6.noarch.rpm

在56上安装管理工具软件包
yum -y install perl-ExtUtils-* perl-CPAN-*	//安装依赖包
# cd mha4mysql-manager-0.56
# perl Makefile.PL 
# make
# make install


1.配置所有数据库主机之间可以互相以ssh密钥对方式认证登陆

2.配置manager56主机无密码ssh登录所有数据库主机

3.配置主从同步,要求如下：
51 主库			开半同步复制
52 从库(备用主库)	开半同步复制
53 从库(备用主库)	开半同步复制
54 从库 不做备用主库所以不用开半同步复制 
55 从库 不做备用主库所以不用开半同步复制

3.1 master51配置：
vim  /etc/my.cnf
[mysqld]
plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-master-enabled = 1
rpl-semi-sync-slave-enabled = 1

server_id=51
log-bin=master51
binlog-format="mixed"

# systemctl restart mysqld

# ls /var/lib/mysql/master51.*
/var/lib/mysql/master51.000001  /var/lib/mysql/master51.index

# mysql -uroot -p123456
mysql> grant  replication slave  on  *.*  to repluser@"%" identified by "123456";
Query OK, 0 rows affected, 1 warning (10.04 sec)

mysql> set global relay_log_purge=off;		//不允许自动删除中继日志文件
Query OK, 0 rows affected (0.15 sec)

mysql> show master status;
+-------------------+----------+
| File              | Position |
+-------------------+----------+
| master51.000001   |      441 |                               
+-------------------+----------+
mysql> quit;


3.2 备用master52的配置
vim /etc/my.cnf
[mysqld]
plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-master-enabled = 1
rpl-semi-sync-slave-enabled = 1

server_id=52
log-bin=master52
binlog-format="mixed"

# systemctl restart mysqld
# ls /var/lib/mysql/master52.*
/var/lib/mysql/master52.000001  /var/lib/mysql/master52.index

# mysql  -uroot  -p123456
mysql> grant  replication slave  on  *.*  to repluser@"%" identified by "123456";
Query OK, 0 rows affected, 1 warning (10.04 sec)

mysql> set global relay_log_purge=off; 
Query OK, 0 rows affected (0.13 sec)

mysql> change master to 
    -> master_host="192.168.4.51",
    -> master_user="repluser",
    -> master_password="123456",
    -> master_log_file="master51.000001",
    -> master_log_pos=441;
Query OK, 0 rows affected, 2 warnings (0.04 sec)

mysql> start slave;
Query OK, 0 rows affected (0.01 sec)

# mysql -uroot -p123456 -e "show slave status\G"  | grep -i YES
mysql: [Warning] Using a password on the command line interface can be insecure.
            Slave_IO_Running: Yes
            Slave_SQL_Running: Yes

3.3 备用master53的配置
#  vim /etc/my.cnf
[mysqld]
plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl-semi-sync-master-enabled = 1
rpl-semi-sync-slave-enabled = 1

server_id=53
log-bin=master53
binlog-format="mixed"


# systemctl  restart mysqld
# ls /var/lib/mysql/master53.*
/var/lib/mysql/master53.000001  /var/lib/mysql/master53.index


# mysql -uroot -p123456
mysql> grant  replication slave  on  *.*  to repluser@"%" identified by "123456";
Query OK, 0 rows affected, 1 warning (10.04 sec)
mysql> set global relay_log_purge=off;
Query OK, 0 rows affected (0.14 sec)

mysql> change master  to master_host="192.168.4.51",master_user="repluser",master_password="123456",master_log_file="master51.000001",master_log_pos=441;
Query OK, 0 rows affected, 2 warnings (0.05 sec)

mysql> start slave;
Query OK, 0 rows affected (0.00 sec)


# mysql -uroot -p123456 -e "show slave status\G" | grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes
             Slave_SQL_Running: Yes



3.4 配置从服务器54
# vim /etc/my.cnf
[mysqld]
server_id=54


# systemctl  restart mysqld
# mysql -uroot -p123456
mysql> change master  to master_host="192.168.4.51",master_user="repluser",master_password="123456",master_log_file="master51.000001",master_log_pos=441;
Query OK, 0 rows affected, 2 warnings (0.09 sec)

mysql> start slave;
Query OK, 0 rows affected (0.00 sec)

mysql> quit;

# mysql -uroot -p123456 -e "show slave status\G" | grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
 


3.5 配置从服务器55
# vim /etc/my.cnf
[mysqld]
server_id=55

# systemctl  restart mysqld
# mysql -uroot -p123456
mysql> change master  to master_host="192.168.4.51",master_user="repluser",master_password="123456",master_log_file="master51.000001",master_log_pos=441;
Query OK, 0 rows affected, 2 warnings (0.09 sec)

mysql> start slave;
Query OK, 0 rows affected (0.00 sec)

mysql> quit;

# mysql -uroot -p123456 -e "show slave status\G" | grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes


3.6  在客户端测试主从同步配置
3.6.1  在主库51上添加访问数据的授权用户
[root@db107 ~]# mysql -uroot -p123456
mysql> grant all on  gamedb.* to admin@"%" identified by "123456";

3.6.2 在主库51上授权管理主机56用于监控的用户
mysql> grant all on *.* to root@"%" identified by "123qqq...A";

3.6.3  在客户端主机连接主库51 建库表记录
mysql> create database gamedb;
Query OK, 1 row affected (0.01 sec)

mysql> create table  gamedb.t1 (id int);
Query OK, 0 rows affected (0.04 sec)

mysql> insert into gamedb.t1 values(999);
Query OK, 1 row affected (0.15 sec)

mysql> insert into gamedb.t1 values(999);
Query OK, 1 row affected (0.05 sec)

mysql> select  * from gamedb.t1;
+------+
| id   |
+------+
|  999 |
|  999 |
+------+
2 rows in set (0.00 sec)

mysql> 

3.6.3  在客户端使用授权用户连接从库52-55,也能看到同样的库表及记录

# mysql -h从库IP地址 -uadmin -p123456
mysql> select  * from gamedb.t1;
+------+
| id   |
+------+
|  999 |
|  999 |
+------+
#################################################################################

1.配置MHA:
在管理主机56已经自动生成在PATH变量目录下的命令
[root@mgm56 ~]# ls /usr/local/bin/masterha*
/usr/local/bin/masterha_check_repl    /usr/local/bin/masterha_master_monitor
/usr/local/bin/masterha_check_ssh     /usr/local/bin/masterha_master_switch
/usr/local/bin/masterha_check_status  /usr/local/bin/masterha_secondary_check
/usr/local/bin/masterha_conf_host     /usr/local/bin/masterha_stop
/usr/local/bin/masterha_manager
[root@mgm56 ~]# ls /root/mha4mysql-manager-0.56/bin/
masterha_check_repl    masterha_conf_host       masterha_master_switch
masterha_check_ssh     masterha_manager         masterha_secondary_check
masterha_check_status  masterha_master_monitor  masterha_stop

2.创建主配置并编辑
[root@mgm56 ~]# mkdir /etc/mha
[root@mgm56 ~]# cp mha4mysql-manager-0.56/samples/conf/app1.cnf  /etc/mha/
[root@mgm56 ~]# vim /etc/mha/app1.cnf
[server default]
manager_workdir=/var/log/masterha/app1-->manager_workdir=/etc/mha
manager_log=/var/log/masterha/app1/manager.log-->manager_log=/etc/mha/manager.log
master_ip_failover_script=/etc/mha/master_ip_failover	//添加这一行
//指定一个脚本，用于当主库宕机之后把vip地址转移到备用主库上

//在此处添加以下配置项
ssh_user=root					//ssh服务用户名及端口
ssh_port=22

repl_user=repluser				//主从同步复制时的用户名及密码
repl_passowrd=123qqq...A

user=root					//监控数据库连接服务器的用户及密码
password=123qqq...A
//指定各种帐号密码

[server1]
hostname=host1-->hostname=192.168.4.51
candidate_master=1				//竞选当主库

[server2]
hostname=host2-->hostname=192.168.4.52
candidate_master=1

[server3]
hostname=host3-->hostname=192.168.4.53
candidate_master=1				//添加此行

[server4]
hostname=host4-->hostname=192.168.4.54		
no_master=1					//不竞选当主库

//添加以下3行
[server5]
hostname=192.168.4.55
no_master=1

创建故障却换vip脚本并编辑
[root@mgm56 ~]# cp mha-soft-student/master_ip_failover /etc/mha/
[root@mgm56 ~]# chmod +x /etc/mha/master_ip_failover 
[root@mgm56 ~]# vim /etc/mha/master_ip_failover 
my $vip = '192.168.4.60/24';-->my $vip = '192.168.4.100/24';

把脚本中指定的ip地址，手动部署在当前主库51上
[root@master51 ~]# ifconfig eth0:1 192.168.4.100/24
[root@master51 ~]# ifconfig eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.100  netmask 255.255.255.0  broadcast 192.168.4.255
        ether 52:54:00:16:50:0c  txqueuelen 1000  (Ethernet)

3.启动服务
3.1检查ssh连接
[root@mgm56 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnf
Wed Oct 24 14:52:01 2018 - [info] All SSH connection tests passed successfully.
3.2检查主从同步配置
[root@mgm56 ~]# masterha_check_repl --conf=/etc/mha/app1.cnf
MySQL Replication Health is OK.
3.3启动管理服务					//启动后会占用终端进入监控状态
[root@mgm56 ~]# masterha_manager --conf=/etc/mha/app1.cnf 
--remove_dead_master_conf --ignore_last_failover	//忽略故障切换配置
3.4查看状态
新开终端查看是否成功
[root@mgm56 ~]# masterha_check_status --conf=/etc/mha/app1.cnf
app1 (pid:17709) is running(0:PING_OK), master:192.168.4.51
停止服务			//停止服务之后再回去监控终端，发现光标回到命令行
masterha_stop --conf=/etc/mha/app1.cnf

4.测试配置
在客户端50主机上连接vip:192.168.4.100访问数据库服务
mysql> create database db3;create table db3.a(id int);
mysql> grant select,insert on db3.* to client@"%" identified by "123qqq...A";
mysql> insert into db3.a values(100);
mysql> select * from db3.a;
[root@client50 ~]# mysql -h192.168.4.100 -uroot -p123qqq...A
mysql> select * from db3.a;

5.测试高可用配置
把主库51的数据库服务停止,客户端仍然可以连接vip:192.168.4.100访问数据库服务
[root@master51 ~]# systemctl stop mysqld
//查看管理服务:会停止跳回到命令行

客户端再连接到数据库上查看主机名
[root@client50 ~]# mysql -h192.168.4.100 -uroot -p123qqq...A
mysql> select @@hostname;
+------------+
| @@hostname |
+------------+
| slave52    |
+------------+
mysql> insert into db3.a values(200);



在/etc/mha/app1.cnf文件没有了主库51的配置，53-55把主库指向新选举的主库地址
[root@mgm56 ~]# vim /etc/mha/app1.cnf 

6.把坏掉的数据库服务器51重新起服务，添加为52的从库
[root@master51 ~]# systemctl restart mysqld
mysql> change master to 
    -> master_host="192.168.4.52",
    -> master_user="repluser",
    -> master_password="123qqq...A",
    -> master_log_file="master52.000002",
    -> master_log_pos=887;
mysql> start slave;
把51重新添加回去
[root@mgm56 ~]# vim /etc/mha/app1.cnf 
[server1]
candidate_master=1
hostname=192.168.4.51
*生产环境下，51坏掉过程中，新的数据需要在51恢复之后重新添加回去:可用binlog日志恢复

再次在56上开启监控服务
[root@mgm56 ~]# masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover
查看一下监控服务的状态,master是52
[root@mgm56 ~]# masterha_check_status --conf=/etc/mha/app1.cnf
app1 (pid:25862) is running(0:PING_OK), master:192.168.4.52

7.再把52数据库服务停止
[root@slave52 ~]# systemctl stop mysqld
客户端连接vip测试
[root@client50 ~]# mysql -h192.168.4.100 -uroot -p123qqq...A;
mysql> select @@hostname;
+------------+
| @@hostname |
+------------+
| master51   |
+------------+
//51竞选成功，51变成主库
//竞选规则，与原主库最接近的当选，以binlog日志上偏移量接近程度为标准

8.此时52还没修好，如果51坏了的话,vip地址不会切换到53,所以必须保证有2个备用主是正常的

=================================================================================
		         09.Dba2-day04
=================================================================================
#环境准备:主机51
mysql> create database db9;
mysql> create table db9.user(
    -> name char(20),
    -> password char(1),
    -> uid int(2),
    -> gid int(2),
    -> comment char(150),
    -> homedir char(150),
    -> shell char(30)
    -> );
mysql> load data infile "/var/lib/mysql-files/passwd"
    -> into table db9.user
    -> fields terminated by ":"
    -> lines terminated by "\n";
mysql> alter table db9.user add id int(2) primary key auto_increment first;

#mysql视图
1.创建视图
语法：
create view 视图名称 as SQL查询；	
create view 视图名称 (字段名列表) as SQL查询；

*注意!:
在视图表中不定义字段名的话,默认使用基表中的字段名;
若定义字段名的话,视图表中的字段名个数必须和SQL查询的字段个数相等

mysql> create view v1 as select name,uid from user;
mysql> create view v2(user,userid) as select name,uid from user;

mysql> system ls /var/lib/mysql/db9	//视图只有表文件,没有表空间文件
v1.frm  v2.frm

2.查看视图
查看当前库下所有表的状态信息
show table status;
查看所有视图的状态信息
mysql> show table status where comment="view"\G
查看创建视图的具体命令
show   create  view  视图名；


3.使用视图
查询记录
Select 字段名列表 from 视图名 where 条件；
插入记录
Insert into 视图名(字段名列表) values(字段值列表)；
更新记录
Update 视图名 set 字段名=值 where 条件；
删除记录
Delete from 视图名 where 条件；

更新视图数据,就是更新基表的数据
更新基表数据,视图的数据也会跟着改变

mysql> insert into v1 values("luc","3003");
mysql> update v1 set name="admin" where uid=0;
mysql> delete from user where name="luc";

mysql> select name,uid from user where uid=0;
+-------+------+
| name  | uid  |
+-------+------+
| admin |    0 |
+-------+------+
mysql> select * from v2 where userid=0;
+-------+--------+
| user  | userid |
+-------+--------+
| admin |      0 |
+-------+--------+


4.删除视图
drop view 视图名；
mysql> drop view v1;
mysql> drop view v2;
mysql> system ls /var/lib/mysql/db9

5.设置字段别名
格式1：
mysql> Create view 视图名 
    -> as 
    -> select 表名.字段名 as 字段别名
    -> from 表名1 left join 表名2
    -> on 条件；
格式2：
mysql> create view 视图名(字段别名列表)
    -> as
    -> select * from 表名1 left join 表名2
    -> on 条件;


mysql> create table t1 
    -> select name,uid,shell from user limit 3;
mysql> create table t2
    -> select name,uid,homedir,gid from user limit 5;

mysql> create view v3(a,b,c,d,e,f,g)
    -> as
    -> select * from t1 left join t2
    -> on t1.name=t2.name and t1.uid=t2.uid;
mysql> select * from v3;
+--------+------+---------------+--------+------+-------+------+
| a      | b    | c             | d      | e    | f     | g    |
+--------+------+---------------+--------+------+-------+------+
| admin  |    0 | /bin/bash     | admin  |    0 | /root |    0 |
| bin    |    1 | /sbin/nologin | bin    |    1 | /bin  |    1 |
| daemon |    2 | /sbin/nologin | daemon |    2 | /sbin |    2 |
+--------+------+---------------+--------+------+-------+------+

mysql> create view v4 
    -> as 
    -> select t1.name as aname,
    -> t2.name as bname,
    -> t1.uid as auid,
    -> t2.uid as buid
    -> from t1 left join t2 on t1.uid=t2.uid;
mysql> select * from v4;
+--------+--------+------+------+
| aname  | bname  | auid | buid |
+--------+--------+------+------+
| admin  | admin  |    0 |    0 |
| bin    | bin    |    1 |    1 |
| daemon | daemon |    2 |    2 |
+--------+--------+------+------+

6.覆盖创建视图:创建时若视图已存在,会替换已有的视图
Create or replace view 视图名 as select 查询

7.with check option选项的使用
mysql> create table user2
    -> select name,uid,shell,homedir from user
    -> where uid>=10 and uid<=50;
mysql> select * from user2;

mysql> create view v7 
    -> as
    -> select * from user2 where uid>=25 with local check option;
//with local check option:update视图数据时,只检查视图的创建条件，不检查基表的创建条件

mysql> select * from v7;
mysql> update v7 set uid=7 where name="rpc";
ERROR 1369 (HY000): CHECK OPTION failed 'db9.v7'	//不满足视图的条件
mysql> update v7 set uid=30 where name="rpc";
Query OK, 0 rows affected (0.03 sec)

mysql> create view v8 
    -> as
    -> select name,uid,shell from user where uid>=20 and uid<=300;
mysql> create view v9 
    -> as 
    -> select * from v8 where uid>=40 with cascaded check option;
//with check option或with cascaded check option(省略local或cascaded默认cascaded):
  update视图数据时，既检查视图的创建条件，又检查基表的创建条件

mysql> update v9 set uid=39 where name="gdm";	//不满足视图的条件
ERROR 1369 (HY000): CHECK OPTION failed 'db9.v9'
mysql> update v9 set uid=309 where name="gdm";	//不满足基表的条件
ERROR 1369 (HY000): CHECK OPTION failed 'db9.v9'
mysql> update v9 set uid=200 where name="gdm";	//两者都满足
Query OK, 1 row affected (0.06 sec)

mysql> select uid from v9 where name="gdm";
+------+
| uid  |
+------+
|  200 |
+------+

mysql> select uid from v8 where name="gdm";
+------+
| uid  |
+------+
|  200 |
+------+

mysql> select uid from user where name="gdm";
+------+
| uid  |
+------+
|  200 |
+------+


#mysql存储过程:MySQL中的脚本

1.创建存储过程
##################################################################
语法格式：
delimiter //		#命令行结束符修改为//,排除功能代码中;的影响
create procedure 库名.名称()
begin
	功能代码
	......
	......
end
//
delimiter ;
##################################################################

mysql> delimiter //
mysql> create procedure db9.p1()
    -> begin
    -> select count(name) from db9.user;
    -> end
    -> //
Query OK, 0 rows affected (0.04 sec)

mysql> delimiter ;

2.查看存储过程
方法1 
mysql> show procedure status;
方法2
mysql> select db,name,type from mysql.proc where name=“存储过程名";

mysql> select db,name,type from mysql.proc where name="p1";

3.调用存储过程
Call 存储过程名();

mysql> call p1();
+-------------+
| count(name) |
+-------------+
|          41 |
+-------------+


4.删除存储过程
drop procedure 存储过程名；

mysql> drop procedure p1;

5.存储过程进阶
5.1变量类型
-------------------------------------------------------------
变量的种类	描述					
-------------------------------------------------------------
会话变量	会话变量和全局变量叫系统变量,使用set命令定义
全局变量	全局变量的修改会影响到整个服务器
		会话变量的修改,只会影响到当前的会话
-------------------------------------------------------------
用户变量	在客户端连接到数据库服务的整个过程中都有效
		当前连接断开后所有用户变量失效
		定义 set @变量名=值；
		输出 select @变量名；
-------------------------------------------------------------
局部变量	存储过程中的begin/end,其有效范围仅限于该语句块中
		语句块执行完毕后,变量失效
		declare专门用来定义局部变量
-------------------------------------------------------------
注意：局部变量和参数变量调用时变量名前不需要加@ 
-------------------------------------------------------------
查看全局变量
mysql> show global variables;	
mysql> show global variables like "connect%";
mysql> show global variables like "connect_timeout";

查看会话变量
mysql> show session variables;	
mysql> show session variables like "%connections%";
mysql> show session variables like "max_connections";

自定义变量
mysql> set @name="jim";

输出自定义变量
mysql> select @name;
+-------+
| @name |
+-------+
| jim   |
+-------+

输出没有定义的变量
mysql> select @age;
+------+
| @age |
+------+
| NULL |
+------+

自定义值是数字的
mysql> set @x=0;
mysql> select @x;
+------+
| @x   |
+------+
|    0 |
+------+

把sql命令查询结果赋值给变量
mysql> select count(name) into @x from db9.user where uid<=10;

declare定义局部变量
mysql> delimiter //
mysql> create procedure p2()
    -> begin
    -> declare x int(2) default 9;
    -> declare name char(5);
    -> set name="tom";
    -> select name;
    -> select x;
    -> end
    -> //
Query OK, 0 rows affected (0.02 sec)

mysql> delimiter ;
mysql> call p2();
+------+	+------+
| name |	| x    |
+------+	+------+
| tom  |	|    9 |
+------+	+------+

mysql> select @x;
+------+
| @x   |
+------+
|    9 |
+------+

5.2参数类型
-------------------------------------------------------------
关键字	名称		描述
-------------------------------------------------------------
in	输入参数	给存储过程传值,必须在调用存储过程时赋值
 			在存储过程中该参数的值不允许修改
			默认不指定参数类型是in
-------------------------------------------------------------
out	输出参数	该值可在存储过程内部被改变,并可返回
-------------------------------------------------------------
inout	输入/输出参数	调用时指定,并且可被改变和返回
-------------------------------------------------------------
注意：这三种类型的变量在存储过程中调用时不需要加@符号
-------------------------------------------------------------
mysql> delimiter //
mysql> create procedure p3(in username char(15))
    -> begin
    -> select name from db9.user where name=username;
    -> end
    -> //
mysql> delimiter ;
mysql> call p3();	//错误调用
ERROR : Incorrect number of arguments for PROCEDURE db9.p3; expected 1, got 0
mysql> set @x="ntp";
mysql> call p3(@x);
+------+
| name |
+------+
| ntp  |
+------+
mysql> call p3("mysql");
+-------+
| name  |
+-------+
| mysql |
+-------+
mysql> call p3(@y);
Empty set (0.00 sec)
mysql> select @y;		//因为@y是空值,user表中没有name为空值的记录
+------+
| @y   |
+------+
| NULL |
+------+

mysql> delimiter //
mysql> create procedure p4(in x int(2))
    -> begin
    -> select x;
    -> set x=9;
    -> select x;
    -> select count(name) into x from db9.user;
    -> select x;
    -> end
    -> //
mysql> delimiter ;
mysql> call p4(1);
+------+	+------+	+------+
| x    |	| x    |	| x    |
+------+	+------+	+------+
|    1 |	|    9 |	|   41 |
+------+	+------+	+------+
mysql> delimiter //
mysql> create procedure p5(out x int(2))
    -> begin
    -> select x;
    -> set x=9;
    -> select x;
    -> select count(name) into x from db9.user;
    -> select x;
    -> end
    -> //
mysql> call p5();	//报错
ERROR 1318 (42000): Incorrect number of arguments for PROCEDURE db9.p5; expected 1, got 0
mysql> call p5(1);	//报错
ERROR 1414 (42000): OUT or INOUT argument 1 for routine db9.p5 is not a variable or NEW pseudo-variable in BEFORE trigger
mysql> call p5(@yy);
+------+	+------+	+------+
| x    |	| x    |	| x    |
+------+	+------+	+------+
| NULL |	|    9 |	|   41 |
+------+	+------+	+------+

mysql> delimiter //
mysql> create procedure p6(inout username char(10))
    -> begin
    -> select username;
    -> set username="jerry";
    -> select username;
    -> select name from db9.user where name=username;
    -> select name into username from db9.user where name="bin";
    -> select username;
    -> end
    -> //
mysql> delimiter ;
mysql> call p6("bob");	//报错
ERROR 1414 (42000): OUT or INOUT argument 1 for routine db9.p6 is not a variable or NEW pseudo-variable in BEFORE trigger
mysql> set @name="bob";
mysql> call p6(@name);
+----------+	+----------+			+----------+
| username |	| username |			| username |
+----------+	+----------+	Empty set	+----------+
| bob      |	| jerry    |			| bin      |
+----------+	+----------+			+----------+

5.3算数运算
符号	描述
+	加法运算	
-	减法运算
*	乘法运算
/	除法运算
%	求模运算
DIV	取整运算

mysql> set @z=1+1;select @z;
+------+
| @z   |
+------+
|    2 |
+------+
mysql> set @x=1,@y=2;set @z=@x+@y;select @z;
+------+
| @z   |
+------+
|    3 |
+------+
mysql> set @z=10/3;select @z;
+-------------+
| @z          |
+-------------+
| 3.333333333 |
+-------------+
mysql> set @z=10 div 3;select @z;
+------+
| @z   |
+------+
|    3 |
+------+

#流程控制
1.if选择结构:
###########################
1.1单分支结构
if 条件测试 then  
	代码...
end if;
1.2双分支结构
if 条件测试 then  
	代码1...
else
	代码2...
end if;
###########################
mysql> delimiter //
mysql> create procedure p8(in linenum int(2))
    -> begin
    -> if linenum is not null then
    -> select * from db9.user where id=linenum;
    -> else
    -> select * from db9.user where id=1;
    -> end if;
    -> end
    -> //
mysql> delimiter ;
mysql> call p8(3);
mysql> select @;
+------+
| @    |
+------+
| NULL |
+------+
mysql> call p8(@);


2.循环结构:
###########################
2.1while循环
while 条件判断 do
循环体...
end while ;

2.2loop循环
loop
循环体...
end loop ;

2.3repate循环
repeat
循环体...
until 条件判断
end repeat ;

###########################

mysql> delimiter //
mysql> create procedure p9()
    -> begin
    -> declare x int(2);
    -> set x=1;
    -> while x<=10 do
    -> select x;
    -> set x=x+1;
    -> end while;
    -> end
    -> //
mysql> delimiter ;
mysql> call p9();
+------+	+------+	+------+		+------+
| x    |	| x    |	| x    |		| x    |
+------+	+------+	+------+	...	+------+
|    1 |	|    2 |	|    3 |		|   10 |
+------+	+------+	+------+		+------+

mysql> delimiter //
    -> create procedure p10() 
    -> begin 
    -> 	loop 
    -> 	select name from db9.user where id=2; 
    -> 	end loop; 
    -> end
    -> //
delimiter ;
mysql> call p10();

mysql> delimiter //
mysql> create procedure p12()
    -> begin
    -> declare x int(2);
    -> set x=10;
    -> repeat
    -> select x;
    -> set x=x-1;
    -> until x<1
    -> end repeat;
    -> end
    -> //
mysql> delimiter ;
mysql> call p12();

查询uid是偶数的用户
mysql> delimiter //
mysql> create procedure sumnum(in w int(2))
    -> begin
    -> declare x int(2);
    -> declare y int(2);
    -> declare z int(2);
    -> set z=0;
    -> set x=1;
    -> while x<=w do
    -> select uid into y from db9.user where id=x;
    -> if y%2=0 then
    -> set z=z+1;
    -> select name from db9.user where id=x;
    -> end if;
    -> set x=x+1;
    -> end while;
    -> select z;
    -> end
    -> //
mysql> delimiter ;

=================================================================================
		         09.Dba2-day05
=================================================================================
#分库分表
mycat:中间件,适合数据大量写入数据的存储需求

在主机mycat57上配置mycat服务
1.安装软件包
检查有没有安装jdk软件包
[root@mycat57 ~]# rpm -qa | grep -i jdk
[root@mycat57 ~]# java -version
[root@mycat57 ~]# tar -zxvf Mycat-server-1.4-beta-20150604171601-linux.tar.gz 
[root@mycat57 ~]# mv mycat /usr/local/
[root@mycat57 ~]# ls /usr/local/mycat/
bin  catlet  conf  lib  logs  version.txt
[root@mycat57 ~]# ls /usr/local/mycat/bin/
mycat      startup_nowrap.sh     wrapper-linux-x86-32
rehash.sh  wrapper-linux-ppc-64  wrapper-linux-x86-64

2.修改配置文件
2.1定义客户端连接mycat时使用的用户名密码和访问权限，逻辑库的名称
[root@mycat57 ~]# vim /usr/local/mycat/conf/server.xml 
 <user name="test"> →→→ <user name="admin">	//指定用户名
                <property name="password">test</property>
	     →→→
		<property name="password">123456</property>	//指定密码
                <property name="schemas">TESTDB</property>	//逻辑库的名称
        </user>
        <user name="user">
                <property name="password">user</property>
                <property name="schemas">TESTDB</property>
                <property name="readOnly">true</property>	//该用户权限是只读
        </user>
2.2定义数据分片
[root@mycat57 ~]# vim /usr/local/mycat/conf/schema.xml
//逻辑库名称要与server.xml里的一致
<schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">	


//dataNode指定的是数据库节点,本实验只有两个节点,所以把dn3删除掉
<table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />
→→→
<table name="travelrecord" dataNode="dn1,dn2" rule="auto-sharding-long" />
<table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
→→→
<table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2" />
<table name="hotnews" primaryKey="ID" dataNode="dn1,dn2,dn3"
→→→
<table name="hotnews" primaryKey="ID" dataNode="dn1,dn2,dn3"
//把dn3的相关配置注释掉
        <dataNode name="dn3" dataHost="localhost1" database="db3" />
→→→
<!--    <dataNode name="dn3" dataHost="localhost1" database="db3" />    -->
//把dn2的主机名改为localhost2
        <dataNode name="dn2" dataHost="localhost1" database="db2" />
→→→
        <dataNode name="dn2" dataHost="localhost2" database="db2" />
//注释这两行
                <writeHost host="hostS1" url="localhost:3316" user="root"
                        password="123456" />    
→→→
        <!--    <writeHost host="hostS1" url="localhost:3316" user="root"
                        password="123456" />    -->
//指定数据库服务器和连接数据库的用户名和密码
                <writeHost host="hostM1" url="localhost:3306" user="root"
                        password="123456">
→→→
                <writeHost host="hostM1" url="192.168.4.54:3306" user="root"
                        password="123qqq...A">
//再设置dn2，复制整个<dataHost></dataHost>
<dataHost name="localhost1"	→→→ <dataHost name="localhost2"
<writeHost host="hostM1" url="192.168.4.54:3306"
→→→
<writeHost host="hostM2" url="192.168.4.55:3306"


3.根据配置文件的设置做对应的配置
[root@mysql54 ~]# vim /etc/my.cnf
[mysqld]
lower_case_table_names=1
[root@mysql54 ~]# systemctl restart mysqld
mysql> create database db2;
mysql> grant all on *.* to root@"%" identified by "123qqq...A";

[root@mysql55 ~]# vim /etc/my.cnf
[mysqld]
lower_case_table_names=1
[root@mysql55 ~]# systemctl restart mysqld
mysql> create database db2;
mysql> grant all on *.* to root@"%" identified by "123qqq...A";

4.启动服务
[root@mycat57 ~]# /usr/local/mycat/bin/mycat start
Starting Mycat-server...	//出现该提示服务也不一定启动成功
##########################################################
停止服务
[root@mycat57 ~]# /usr/local/mycat/bin/mycat stop
##########################################################

5.查看服务端口	//能查看到服务端口号激活才证明服务启动成功
[root@mycat57 ~]# netstat -nultp | grep :8066
tcp6       0      0 :::8066	:::*	LISTEN      1478/java
##########################################################
如果服务没有成功起来,则查看日志文件排错
[root@mycat57 ~]# less /usr/local/mycat/logs/wrapper.log 
caused by:		//这一行对应有错误原因
##########################################################
6.客户端测试配置
客户端登录的帐号密码在/usr/local/mycat/conf/server.xml
[root@client50 ~]# mysql -h192.168.4.57 -P8066 -uadmin -p123456
mysql> show databases;
+----------+
| DATABASE |
+----------+
| TESTDB   |			//这个库是逻辑库,数据其实存储在54和55上
+----------+
mysql> use TESTDB;
mysql> show tables;		//这些表是在mycat的配置文件里指定的
+------------------+		//不过其实这些表没有真实存在，还需要创建
| Tables in TESTDB |
+------------------+
| company          |
| customer         |
| customer_addr    |
| employee         |
| goods            |
| hotnews          |
| orders           |
| order_items      |
| travelrecord     |
+------------------+

###########################################################################
[root@mycat57 ~]# vim /usr/local/mycat/conf/schema.xml
<table name="employee" primaryKey="ID" dataNode="dn1,dn2"
                        rule="sharding-by-intfile" />
//表employee要有主键字段id
//rule规则是:rule="sharding-by-intfile"

<rule>
                        <columns>sharding_id</columns>
                        <algorithm>hash-int</algorithm>		//算法是hash-int
                </rule>
/hash-int	//搜索hash-int算法
        <function name="hash-int"
                class="org.opencloudb.route.function.PartitionByFileMap">
                <property name="mapFile">partition-hash-int.txt</property>
        </function>			//映射文件是partition-hash-int.txt
//查看mapFile映射文件partition-hash-int.txt
[root@mycat57 ~]# vim /usr/local/mycat/conf/partition-hash-int.txt 
10000=0		//sharding_id=10000	对应的是第一台数据库服务器
10010=1		//sharding_id=10010	对应的是第二台数据库服务器
###########################################################################

mysql> create table employee(
    -> id int(2) primary key auto_increment,
    -> name char(10),
    -> age tinyint(2) default 18,
    -> sex enum("boy","girl") default "boy",
    -> sharding_id int(2)
    -> );
mysql> desc employee;

mysql> insert into employee(name,sharding_id) values("bob",10000),("tom",10010);
mysql> insert into employee(name,sharding_id) values("jerry",10010);
mysql> select * from employee;
+----+-------+------+------+-------------+
| id | name  | age  | sex  | sharding_id |
+----+-------+------+------+-------------+
|  1 | bob   |   18 | boy  |       10000 |
|  1 | tom   |   18 | boy  |       10010 |
|  2 | jerry |   18 | boy  |       10010 |
+----+-------+------+------+-------------+
//如果sharding_id不是10000或10010则报错
mysql> insert into employee(name,sharding_id) values("jerry",10020);
ERROR 1064(HY000):can't find any valid datanode :EMPLOYEE -> SHARDING_ID -> 10020

#mysql性能调优(理论)

搭建监控服务器:监控服务的硬件(如CPU,内存,存储,网络接口流量)使用率

数据库服务运行参数
1.立刻生效,但是不是永久配置
数据库命令行
mysql> 选项=值
2.永久配置,但是要重启数据库服务才生效
[root@host51 ~]# vim /etc/my.cnf
[mysqld]
选项=值
//一般两种配合着设置,可以立刻生效,且为永久配置

常用调优参数
1.允许的最大并发连接数
mysql> show variables  like "max_connections";		//查看默认的最大连接数
mysql> show global status like "Max_used_connections";	//查看当前已使用的连接数
理想比率:Max_used_connections/max_connections<=0.85

2.等待建立连接的超时时间
connect_timeout		//默认10s,只有在连接登录时有效

3.连接后等待用户执行命令的超时时间
wait_timeout		//默认28800s(8h),连接后超过8个小时不执行命令超时
  //wait_timeoyt数值较大的原因:
  当执行插入大量数据的命令,执行时间会很长
  命令执行过程中会被判定为没有执行下一条命令
  若命令还没执行完就超时会导致插入数据无法正常进行

4.MyISAM引擎的关键索引缓存大小
key_buffer-size	  //默认是8M，当Key_reads/Key_read_requests较低时,可适当加大此缓存值


5.为每个要排序的线程分配此大小的缓存空间
sort_buffer_size	//默认是256K，增大此值可提高ORDER和GROUP的速度

6.为顺序读取表记录保留的缓存大小
read_buffer_size	//查看表记录读取缓存,会影响SQL查询的响应速度

7.允许保存在缓存中被重用的线程数量
thread_cache_size

8.可缓存多少个打开的表
table_open_cache
open_tables	//已打开多少个表
opened_tables	//打开过多少个表
理想比率：open_tables/table_open_cache<=0.95


9.查询缓存参数
mysql> show variables like "query_cache%";
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 1048576 |
| query_cache_type             | OFF     |
| query_cache_wlock_invalidate | OFF     |
+------------------------------+---------+
查询缓存的全局状态信息
mysql> mysql> show global status like"qcache%";
+-------------------------+---------+
| Variable_name           | Value   |
+-------------------------+---------+
| Qcache_free_blocks      | 1       |
| Qcache_free_memory      | 1031832 |
| Qcache_hits             | 0       |
| Qcache_inserts          | 0       |
| Qcache_lowmem_prunes    | 0       |
| Qcache_not_cached       | 1       |
| Qcache_queries_in_cache | 0       |
| Qcache_total_blocks     | 1       |
+-------------------------+---------+

SQL查询优化

1.常用日志种类及选项
-------------------------------------------------------------------------------
类型		用途				       配置
-------------------------------------------------------------------------------	
错误日志	记录启动/运行/停止过程中的错误消息        log-error[=name]
-------------------------------------------------------------------------------	
查询日志	记录客户端连接和查询操作		       general-log
						       [general-log-file=name]
-------------------------------------------------------------------------------	
慢查询日志	记录耗时较长的查询操作	       	       slow-query-log
		(默认记录10秒以上的)		       [slow-query-log-file=name]
						       long-query-time=
	      （记录不使用索引的查询操作）	    log-queries-not-using-indexes
-------------------------------------------------------------------------------
2.开启查询日志
[root@host51 ~]# vim /etc/my.cnf
[mysqld]
general-log
server_id=51
[root@host51 ~]# systemctl restart mysqld
[root@host51 ~]# ls /var/lib/mysql/host51.log 		//日志默认是:主机名.log
/var/lib/mysql/host51.log
[root@host51 ~]# tail -f /var/lib/mysql/host51.log 	//实时监控日志更新内容
连接数据库测试
[root@client50 ~]# mysql -h192.168.4.51 -uroot -p123qqq...A
mysql> select * from mysql.user;
//在host51上的实时监控日志更新出在client50上的查询操作
2018-10-29T01:30:04.876179Z	    3 Query	select * from mysql.user

3.开启慢查询日志
[root@host51 ~]# vim /etc/my.cnf
[mysqld]
slow-query-log
log-queries-not-using-indexes
[root@host51 ~]# systemctl restart mysqld
[root@host51 ~]# ls /var/lib/mysql/*slow*
/var/lib/mysql/host51-slow.log
统计慢查询日志记录的sql命令保存到文本文件
[root@host51 ~]# mysqldumpslow /var/lib/mysql/host51-slow.log > /tmp/sql.txt
记录慢查询
选项					含义
slow-query-log				启用慢查询
slow-query-log-file			指定慢查询日志文件
long-query-time				超过指定秒数（默认10秒）的查询才被记录
log-queries-not-using-indexes		记录未使用索引的查询


优化网络架构：结构中不要有数据传输瓶颈
	     不要有单点故障
--->MHA集群

=================================================================================
		         10.Nosql-day01
=================================================================================
NotOnlySQL(Nosql):非关系型数据库
特点:不需要预先定义数据库结构；表的每条记录都可以有不同的类型和结构

主流软件
Redis，MongoDB，Memcached，CouchDB，Neo4j，FlockDB

#部署Redis服务
RemodeDIctionaryServer:远程字典服务器
是一款高性能的(Key/Values)分布式内存数据库
支持数据持久化，可以把内存里数据保存到硬盘中
支持master-salve模式数据备份
中文网站www.redis.cn

1.安装软件包
[root@host50 ~]# tar -xzvf redis/redis-4.0.8.tar.gz 
[root@host50 ~]# ls redis-4.0.8/
00-RELEASENOTES  COPYING  Makefile   redis.conf       runtest-sentinel  tests
BUGS             deps     MANIFESTO  runtest          sentinel.conf     utils
CONTRIBUTING     INSTALL  README.md  runtest-cluster  src
[root@host50 ~]# cd redis-4.0.8/
[root@host50 redis-4.0.8]# yum -y install gcc
[root@host50 redis-4.0.8]# make
[root@host50 redis-4.0.8]# make install

2.初始配置
[root@host50 redis-4.0.8]# ./utils/install_server.sh 	//然后猛地按回车
Welcome to the redis service installer
This script will help you easily set up a running redis server

Please select the redis port for this instance: [6379] 	//端口号
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf] //主配置文件
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] //日志文件
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance [/var/lib/redis/6379] 
						   //数据库目录
Selected default - /var/lib/redis/6379
Please select the redis executable path [/usr/local/bin/redis-server] 
Selected config:
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf => /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
/var/run/redis_6379.pid exists, process is already running or crashed
Installation successful!
[root@host50 redis-4.0.8]# ss -nultp | grep 6379	//查看服务状态
tcp    LISTEN     0      128    127.0.0.1:6379                  *:*                   users:(("redis-server",pid=6166,fd=6))
[root@host50 redis-4.0.8]# /etc/init.d/redis_6379 stop	//停止服务
Stopping ...
Redis stopped
[root@host50 redis-4.0.8]# ss -nultp | grep 6379
[root@host50 redis-4.0.8]# /etc/init.d/redis_6379 start	//启动服务
Starting Redis server...
[root@host50 redis-4.0.8]# ss -nultp | grep 6379
[root@host50 ~]# /etc/init.d/redis_6379 status		//查看服务运行状态

3.连接redis服务
[root@host50 ~]# redis-cli 

4.常用操作指令
Set keyname keyvalue 		//存储
get keyname			//获取
Select 数据库编号0-15		//切换库
Keys *				//打印所以变量
Keys a?				//打印指定变量,一个问号代表通配一个字母
Exits keyname			//测试是否存在
ttl keyname			//查看生存时间
type keyname			//查看数据类型
move keyname dbname		//移动变量
expire keyname 秒数		//设置有效时间
del keyname			//删除变量
flushall			//删除所有库的所有变量
flushdb				//删除当前库的所有变量
save				//保存所有变量
shutdown			//关闭服务(会自动执行存盘操作再关闭服务)

5.配置文件解析
[root@host50 ~]# vim /etc/redis/6379.conf 
//数据单位
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
//自定义服务使用的端口号
port 6379→→port 6350
//自定义服务使用的ip地址
bind 127.0.0.1→→bind 192.168.4.50
重启服务
[root@host50 ~]# /etc/init.d/redis_6379 stop
[root@host50 ~]# /etc/init.d/redis_6379 start
[root@host50 ~]# ss -nultp | grep :6350

修改管理服务的脚本
[root@host50 ~]# vim /etc/init.d/redis_6379 
$CLIEXEC -p $REDISPORT shutdown→→$CLIEXEC -h 192.168.4.50 -p 6350 shutdown
[root@host50 ~]# /etc/init.d/redis_6379 stop
[root@host50 ~]# /etc/init.d/redis_6379 start
//修改了ip地址和端口之后连接时要指定ip地址和端口号
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350

其他常用配置选项
tcp-backlog 511				//tcp连接总数
timeout 0				//连接超时时间
tcp-keepalive 300			//长连接时间
daemonize yes				//守护进程方式运行
databases 16				//数据库个数
logfile /var/log/redis_6379.log		//pid文件
maxclients 10000			//并发连接数量
dir /var/lib/redis/6379			//数据库目录

内存管理
内存清除策略
volatile-lru			//最近最少使用(针对设置了过期时间的key)
allkeys-lru			//删除最少使用的key
volatile-random			//在设置了过的key里随机移除
allkeys-random			//随机移除key
volatile-ttl (minorTTL) 	//移除最近过期的key
noeviction			//不删除,写满时报错
选项默认设置
maxmemory <bytes>		//最大内存
maxmemory-policy noeviction	//定义使用的策略
maxmemory-samples 5		//选取模板数据的个数(针对lru和ttl策略)

修改服务的连接密码,默认该项是注释掉的(即不需要密码登录)
# requirepass foobared→→requirepass 123456
重启服务
[root@host50 ~]# /etc/init.d/redis_6379 stop
[root@host50 ~]# /etc/init.d/redis_6379 start
[root@host50 ~]# ss -nultp | grep :6350
//不输入密码连接之后，做操作会报错
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350
192.168.4.50:6350> KEYS *
(error) NOAUTH Authentication required.
192.168.4.50:6350> auth 123456
//或者在连接的时候指定密码
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456
//改成密码验证后,不可以用管理脚本停止服务了
[root@host50 ~]# /etc/init.d/redis_6379 stop
Stopping ...
(error) NOAUTH Authentication required.
Waiting for Redis to shutdown ...
//要用命令停止服务
[root@host50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456 shutdown
//修改管理脚本
[root@host50 ~]# vim /etc/init.d/redis_6379 
$CLIEXEC -h 192.168.4.50 -p 6350 →→
$CLIEXEC -h 192.168.4.50 -p 6350 -a 123456 shutdown
[root@host50 ~]# /etc/init.d/redis_6379 start
Starting Redis server...
[root@host50 ~]# /etc/init.d/redis_6379 stop
Stopping ...
Redis stopped


#部署LNMP+Redis
[root@web57 lnmp]# netstat -nultp | grep :80
[root@web57 lnmp]# rpm -q gcc
package gcc is not installed
[root@web57 lnmp]# yum -y install gcc
[root@web57 lnmp]# useradd nginx
[root@web57 lnmp]# tar -xvf nginx-1.12.2.tar.gz 
[root@web57 nginx-1.12.2]# yum -y install pcre-devel
[root@web57 nginx-1.12.2]# yum -y install zlib-devel
[root@web57 nginx-1.12.2]# ./configure --prefix=/usr/local/nginx
[root@web57 nginx-1.12.2]# make && make install
[root@web57 nginx-1.12.2]# echo 123 > /usr/local/nginx/html/test.html
[root@web57 nginx-1.12.2]# ls /usr/local/nginx/html/
50x.html  index.html  test.html
[root@web57 nginx-1.12.2]# /usr/local/nginx/sbin/nginx 
[root@web57 nginx-1.12.2]# ss -nultp |grep :80
tcp    LISTEN     0      128       *:80                    *:*                   users:(("nginx",pid=6596,fd=6),("nginx",pid=6595,fd=6))
[root@web57 nginx-1.12.2]# curl http://localhost/test.html
123
[root@web57 nginx-1.12.2]# vim /usr/local/nginx/html/test.php
<?php
echo "hello world!";		
?>
[root@web57 nginx-1.12.2]# curl 127.0.0.1/test.php
<?php
echo "hello world!";		//没有安装解释程序php-fpm,访问到的是代码内容
?>
[root@web57 lnmp]# cd ..
[root@web57 lnmp]# yum -y install php-fpm-5.4.16-42.el7.x86_64.rpm 
[root@web57 lnmp]# systemctl restart php-fpm
[root@web57 lnmp]# ss -nultp|grep :9000
[root@web57 lnmp]# vim /usr/local/nginx/conf/nginx.conf
        location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
[root@web57 lnmp]# /usr/local/nginx/sbin/nginx -t      //检查配置文件有没有语法错误
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
[root@web57 lnmp]# /usr/local/nginx/sbin/nginx -s reload
[root@web57 lnmp]# curl http://localhost/test.php
hello world!			
[root@web57 lnmp]# yum -y install mariadb-server mariadb 
[root@web57 lnmp]# netstat -nultp | grep :3306
[root@web57 redis]# cd redis/
[root@web57 redis]# tar -xvf redis-4.0.8.tar.gz 
[root@web57 redis-4.0.8]# cd redis/redis-4.0.8/
[root@web57 redis-4.0.8]# make && make install
[root@web57 redis-4.0.8]# ./utils/install_server.sh 
[root@web57 redis-4.0.8]# /etc/init.d/redis_6379 start
[root@web57 redis-4.0.8]# ss -nultp | grep :6379
[root@web57 redis-4.0.8]# redis-cli 
127.0.0.1:6379> ping
//配置php支持redis
[root@web57 redis-4.0.8]# yum -y install autoconf
[root@web57 redis-4.0.8]# yum -y install automake
[root@web57 redis-4.0.8]# cd /root/redis/lnmp/
[root@web57 lnmp]# rpm -ivh php-devel-5.4.16-42.el7.x86_64.rpm 
[root@web57 lnmp]# tar -xvf php-redis-2.2.4.tar.gz 
[root@web57 lnmp]# cd phpredis-2.2.4/
[root@web57 phpredis-2.2.4]# phpize 
[root@web57 phpredis-2.2.4]# ./configure --with-php-config=/usr/bin/php-config
[root@web57 phpredis-2.2.4]# make && make install
[root@web57 phpredis-2.2.4]# ls /usr/lib64/php/modules/
[root@web57 phpredis-2.2.4]# vim /etc/php.ini 
 extension_dir = "/usr/lib64/php/modules/"
 extension = "redis.so"
[root@web57 phpredis-2.2.4]# systemctl restart php-fpm
[root@web57 phpredis-2.2.4]# php -m | grep -i redis
redis
[root@web57 phpredis-2.2.4]# vim /usr/local/nginx/html/test2.php
<?php
phpinfo();
?>
//访问http://192.168.4.57/test2.php可以找到redis
[root@web57 ~]# yum -y install php-mysql
[root@web57 ~]# php -m | grep -i mysql
//编写测试连接redis页面
[root@web57 ~]# vim /usr/local/nginx/html/test3.php
<?php
$redis=new redis();
$redis->connect('127.0.0.1',6379);
$redis->set('x','666');
echo $redis->get('x');
?>
[root@web57 ~]# curl localhost/test3.php
666
[root@web57 ~]# redis-cli 
127.0.0.1:6379> keys *
1) "x"
127.0.0.1:6379> get x
"666"
配置mysql服务
[root@mysql55 ~]# ss -nultp | grep :3306
[root@mysql55 ~]# mysql -uroot -p123qqq...A
mysql> create database gamedb;
mysql> create table gamedb.user(
    -> name char(15),
    -> password char(6)
    -> );
mysql> grant select,insert on gamedb.* to admin@"192.168.4.57" identified by "123qqq...A";
[root@web57 ~]# mysql -h192.168.4.55 -uadmin -p123qqq...A gamedb
					       //直接连接到gamedb库
mysql> insert into user(name,password) values("bob","123456");

//把测试页面拷贝到网页文件根目录下
[root@June ~]# scp index.html reg.php 192.168.4.57:/usr/local/nginx/html
[root@web57 ~]# cat /usr/local/nginx/html/index.html 
<html>
<form action="reg.php" method="post">
<h1> reg login user info :</h1> 
<h3>LoginName: </h3><input type="text" name="name" size="20" maxlength="255"/>
<br />
<br />
<h3>LoginPass: </h3><input type="text" name="password" size="20" maxlength="255"/>
<br />
<br />
<h3><input type="submit" name="submit" value="SUBMIT" /></h3></p>
</form>
</html>
[root@web57 ~]# cat /usr/local/nginx/html/reg.php 
<?php
$servername = "192.168.4.55";
$username = "admin";
$password = "123qqq...A";
$dbname = "gamedb";

$conn = new mysqli($servername, $username, $password, $dbname);

if ($conn->connect_error) {
    die("link fail: " . $conn->connect_error);
}else{echo "link mysql Ok"; echo "       ";} 

$username=$_POST['name'];
$userpassword=$_POST['password'];

$sql="insert into user (name,password) values ('$username','$userpassword')";
if($conn->query($sql)){echo "insert data ok"; }
$conn->close();

?>

[root@web57 ~]# firefox 127.0.0.1	//在页面里随便输入帐号密码注册
link mysql Ok insert data ok		//看到跳转到这样的信息即为成功连接mysql


=================================================================================
		         10.Nosql-day02
=================================================================================
#部署redis集群
		     client
		       |
   ＿＿＿＿＿＿＿＿＿＿＿|＿＿＿＿＿＿＿＿＿＿
   |       |       |       |       |      |
redisA	redisB	redisC	redisD	redisE redisF

redis服务器ip地址及端口规划
redisA	192.168.4.51    6351
redisB	192.168.4.52    6352
redisC	192.168.4.53    6353
redisD	192.168.4.54    6354
redisE  192.168.4.55    6355
redisF  192.168.4.56    6356


1.安装redis软件包
在6台主机上做如下配置，并运行redis服务
#yum -y install gcc   
#tar -zxvf redis-4.0.8.tar.gz
#cd redis-4.0.8/
#make
#make install
#./utils/install_server.sh
2.修改配置文件
#vim /etc/redis/redis.conf
bind  IP地址				//只写物理接口IP地址
daemonize yes				//守护进程方式运行
port  635x				//端口号改成对应的IP主机位
cluster-enabled  yes			//开启集群  
cluster-config-file  nodes.conf		//集群的配置文件不要使用默认的名称 
cluster-node-timeout  5000		//请求超时  5秒
3.查看集群节点信息
[root@redisA ~]# cat /var/lib/redis/6379/nodes-6351.conf
[root@redisB ~]# cat /var/lib/redis/6379/nodes-6352.conf
[root@redisC ~]# cat /var/lib/redis/6379/nodes-6353.conf
[root@redisD ~]# cat /var/lib/redis/6379/nodes-6354.conf
[root@redisE ~]# cat /var/lib/redis/6379/nodes-6355.conf
[root@redisF ~]# cat /var/lib/redis/6379/nodes-6356.conf
4.查看当前机器是否在集群中以及集群中的其他成员
192.168.4.51:6351> cluster info
192.168.4.52:6352> cluster info
192.168.4.53:6353> cluster info
192.168.4.54:6354> cluster info
192.168.4.55:6355> cluster info
192.168.4.56:6356> cluster info
5.把51redisA配置成管理主机并创建集群
5.1.部署ruby脚本的运行环境
[root@redisA ~]# yum -y install ruby rubygems
[root@redisA ~]# ls /root/redis-cluster/
redis-3.2.1.gem  ruby-devel-2.0.0.648-30.el7.x86_64.rpm
[root@redisA ~]# rpm -ivh --nodeps /root/redis-cluster/ruby-devel-2.0.0.648-30.el7.x86_64.rpm 
[root@redisA ~]# gem install redis-cluster/redis-3.2.1.gem 

5.2.在redis源码包里有用于创建集群用的ruby脚本
[root@redisA ~]# mkdir /root/bin
[root@redisA ~]# echo $PATH			
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
[root@redisA ~]# cp /root/redis/redis-4.0.8/src/redis-trib.rb /root/bin/
[root@redisA ~]# redis-trib.rb help		//查看命令帮助信息

5.3.创建集群
[root@redisA ~]# redis-trib.rb create --replicas 1 \	//--replicas 1表示
> 192.168.4.51:6351 \					  自动为每个master节点
> 192.168.4.52:6352 \					  分配一个slave节点
> 192.168.4.53:6353 \
> 192.168.4.54:6354 \
> 192.168.4.55:6355 \
> 192.168.4.56:6356
>>> Creating cluster
>>> Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.4.51:6351
192.168.4.52:6352
192.168.4.53:6353
Adding replica 192.168.4.55:6355 to 192.168.4.51:6351
Adding replica 192.168.4.56:6356 to 192.168.4.52:6352
Adding replica 192.168.4.54:6354 to 192.168.4.53:6353
M: 145db5bc0e2b88a04b52dfd97f9c99dba8139134 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
M: c4f963ba0d678f71946b3e571fd96ca50388cbc0 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
M: 5a672e215f19bc45caced29f9932da87bf40511e 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
S: 98e02c985b4e47826b1ecdf1100c47a9da30c17b 192.168.4.54:6354
   replicates 5a672e215f19bc45caced29f9932da87bf40511e
S: 7426bb61131a29a55ab4d2b7b9320899996a03e2 192.168.4.55:6355
   replicates 145db5bc0e2b88a04b52dfd97f9c99dba8139134
S: fe3495e8be442c1c31924a66f4644d1e0034e3a0 192.168.4.56:6356
   replicates c4f963ba0d678f71946b3e571fd96ca50388cbc0
Can I set the above configuration? (type 'yes' to accept): yes	//输入yes
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join...
>>> Performing Cluster Check (using node 192.168.4.51:6351)
M: 145db5bc0e2b88a04b52dfd97f9c99dba8139134 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
M: c4f963ba0d678f71946b3e571fd96ca50388cbc0 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: 5a672e215f19bc45caced29f9932da87bf40511e 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: 98e02c985b4e47826b1ecdf1100c47a9da30c17b 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 5a672e215f19bc45caced29f9932da87bf40511e
S: 7426bb61131a29a55ab4d2b7b9320899996a03e2 192.168.4.55:6355
   slots: (0 slots) slave
   replicates 145db5bc0e2b88a04b52dfd97f9c99dba8139134
S: fe3495e8be442c1c31924a66f4644d1e0034e3a0 192.168.4.56:6356
   slots: (0 slots) slave
   replicates c4f963ba0d678f71946b3e571fd96ca50388cbc0
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
//随便找一台集群中的主机查看集群信息及节点信息
[root@redisA ~]# redis-cli -h 192.168.4.51 -p 6351
192.168.4.51:6351> cluster info
cluster_state:ok			//状态ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6			//6个节点
cluster_size:3				//3个组
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:87
cluster_stats_messages_pong_sent:114
cluster_stats_messages_sent:201
cluster_stats_messages_ping_received:109
cluster_stats_messages_pong_received:87
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:201
192.168.4.51:6351> cluster nodes	//从库会自动同步其对应主库上的数据
c4f963ba0d678f71946b3e571fd96ca50388cbc0 192.168.4.52:6352@16352 master - 0 1540866848000 2 connected 5461-10922
5a672e215f19bc45caced29f9932da87bf40511e 192.168.4.53:6353@16353 master - 0 1540866846000 3 connected 10923-16383
98e02c985b4e47826b1ecdf1100c47a9da30c17b 192.168.4.54:6354@16354 slave 5a672e215f19bc45caced29f9932da87bf40511e 0 1540866846816 4 connected
145db5bc0e2b88a04b52dfd97f9c99dba8139134 192.168.4.51:6351@16351 myself,master - 0 1540866848000 1 connected 0-5460
7426bb61131a29a55ab4d2b7b9320899996a03e2 192.168.4.55:6355@16355 slave 145db5bc0e2b88a04b52dfd97f9c99dba8139134 0 1540866847518 5 connected
fe3495e8be442c1c31924a66f4644d1e0034e3a0 192.168.4.56:6356@16356 slave c4f963ba0d678f71946b3e571fd96ca50388cbc0 0 1540866847000 6 connected
//根据前面的id编号对比slave后面master的id编号可以判断主从库对应关系
//master52-slave56;master53-slave54;master51-slave55

6.访问redis集群
//必须连接主库的ip地址和端口,但是redis集群是分布式存储,不一定存储在连接在
[root@redisA ~]# redis-cli -c -h 192.168.4.52 -p 6352	//-c代表访问集群

7.在管理主机上检查集群
[root@redisA ~]# redis-trib.rb check 192.168.4.51:6351


8.测试高可用
主库宕机后，对应的从库会自动升级为主库
宕机的主库重新启动后，自动配置为当前主库的从库
并自动同步宕机期间的数据


#管理集群
1.向集群里添加新redis服务器,角色是master
1.1在redis57运行redis服务并修改配置文件启用集群配置
[root@redis57 ~]# vim /etc/redis/redis.conf
bind  192.168.4.57				
daemonize yes				
port  6357				
cluster-enabled  yes			
cluster-config-file  nodes-6357.conf		 
cluster-node-timeout  5000		

1.2在管理主机上把服务器redis57添加到集群里
[root@redisA ~]# redis-trib.rb add-node 192.168.4.57:6357 192.168.4.51:6351
[root@redisA ~]# redis-trib.rb check 192.168.4.51:6351
//可以查看到主机角色为master
//无槽位数量

1.3重新分配哈希槽
[root@redisA ~]# redis-trib.rb reshard 192.168.4.51:6351
How many slots do you want to move(from 1 to 16384)?4096
What is the reciving nodeID?
//输入57的节点ID
Source node #1:all	//all代表从所有节点中平均获取
Source node #2:done
...
Do you want to proceed with the proposed reshard plan (yes/no)?yes

2.向集群里添加新redis服务器,角色是master
2.1在redis50运行redis服务并修改配置文件启用集群配置
[root@redis50 ~]# vim /etc/redis/redis.conf
bind  192.168.4.50				
daemonize yes				
port  6350				
cluster-enabled  yes			
cluster-config-file  nodes-6350.conf		 
cluster-node-timeout  5000

2.2在管理主机上把服务器redis51添加到集群里，角色是slave
[root@redisA ~]# redis-trib.rb add-node --slave [--master-id id值] 192.168.4.50:6350 192.168.4.51:6351					↓ 
					  [可省略]如果不指定主库的节点的话
					  会把从库最少的master添加为主库
>>>Adding node 192.168.4.57:6357 to cluster
192.168.4.51:6351
>>>performing Cluster Check(using node 192.168.4.51:6351)
...
...
[OK]All 16384 slots covered
Automatically selected master 192.168.4.51:6351
>>>Send CLUSTER MEET to node 192.168.4.57:6357 to make it join the cluster
Waiting for the cluster to join
>>>Configure node as replica of 192.168.4.51:6351
[OK]New node added correctly
[root@redisA ~]# redis-trib.rb check 192.168.4.51:6351
[root@redisA ~]# redis-cli -h 192.168.4.50 -p 6350
192.168.4.50:6350> KEYS *

3.移除slave主机
从库节点主机没有槽位，直接移除即可
redis-trib.rb del-node 192.168.4.51:6351 主机id值
//还要删除这个文件才能彻底移除
[root@redis ~]# rm -rf /var/lib/redis/6379/nodes-635X.conf 
[root@redis ~]# /etc/init.d/redis_6379 stop
[root@redis ~]# /etc/init.d/redis_6379 start
[root@redisE ~]# redis-cli -h 192.168.4.55 -p 6355
192.168.4.55:6355> cluster info
cluster_state:fail		//变成fail
cluster_slots_assigned:1
cluster_slots_ok:1
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:1
cluster_size:1
cluster_current_epoch:0
cluster_my_epoch:0
cluster_stats_messages_sent:0
cluster_stats_messages_received:0

4.移除master主机
4.1删除槽位
[root@redisA ~]# redis-trib.rb reshard 192.168.4.51:6351
How many slots do you want to move(from 1 to 16384)?4096	//移除的槽数
What is the reciving nodeID?		//移到哪个库上
Source node #1:id			//从哪个主库节点上移除
Source node #2:done
...
Do you want to proceed with the proposed reshard plan (yes/no)?yes

4.2移除主库节点
[root@redisA ~]# redis-trib.rb del-node 192.168.4.51:6351 被移除节点主机id

=================================================================================
		         10.Nosql-day03
=================================================================================
#Redis主从复制

Master:redis51-->Slave:redis52

[root@redis51 ~]# redis-cli -h 192.168.4.51 -p 6351
192.168.4.51:6351> KEYS *
(empty list or set)
192.168.4.51:6351> set v1 10
OK
192.168.4.51:6351> set v2 20
OK
192.168.4.51:6351> set v3 30
OK
192.168.4.51:6351> KEYS *
1) "v2"
2) "v3"
3) "v1"
192.168.4.51:6351> info replication	//查看主从配置信息
# Replication
role:master		//redis服务运行后默认是master,redis51不需要配置
connected_slaves:0
master_replid:83e1727d612f6a9230e44e87e08e6f09b18f0fa9
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

配置从库redis52
[root@redis53 ~]# redis-cli -h 192.168.4.52 -p 6352
192.168.4.52:6352> set a1 99
OK
192.168.4.52:6352> set a2 88
OK
192.168.4.52:6352> KEYS *
1) "a1"
2) "a2"
//配置redis52成为redis51的从库
192.168.4.52:6352> slaveof 192.168.4.51 6351	//slaveof 主库ip地址 端口号
192.168.4.52:6352> KEYS *
1) "v1"
2) "v2"
3) "v3"
192.168.4.52:6352> INFO replication
# Replication
role:slave			//角色slave
master_host:192.168.4.51
master_port:6351
master_link_status:up
master_last_io_seconds_ago:8
master_sync_in_progress:0
slave_repl_offset:56
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:cac0a6328d155725010d23e826d943279b9e2866
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:56
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:56

客户端连接主库测试
[root@client50 ~]# redis-cli -h 192.168.4.51 -p 6351
192.168.4.51:6351>

反客为主
主库宕机后，手动将从库设置为主库
192.168.4.52:6352> SLAVEOF no one
192.168.4.52:6352> INFO replication
# Replication
role:master
connected_slaves:0
master_replid:8ff6a038d8d38b5ae1cdde9179d68934ebc1e2b4
master_replid2:cac0a6328d155725010d23e826d943279b9e2866
master_repl_offset:1428
second_repl_offset:1429
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1009
repl_backlog_histlen:420


配置密码验证的主从同步永久设置
//以上的是临时配置，重启服务后失效，永久设置需要修改配置文件
[root@redis51 ~]# vim /etc/redis/6379.conf 
 requirepass 123456
[root@redis51 ~]# vim /etc/init.d/redis_6379 
$CLIEXEC -h 192.168.4.51 -p 6351 -a 123456 shutdown
[root@redis51 ~]# /etc/init.d/redis_6379 stop
[root@redis51 ~]# /etc/init.d/redis_6379 start

[root@redis52 ~]# vim /etc/redis/6379.conf 
# slaveof <masterip> <masterport>
slaveof 192.168.4.51 6351
# masterauth <master-password>
masterauth 123456
[root@redis52 ~]# /etc/init.d/redis_6379 stop
[root@redis52 ~]# /etc/init.d/redis_6379 start
[root@redis52 ~]# redis-cli -h 192.168.4.52 -p 6352
192.168.4.52:6352> INFO replication
# Replication
role:slave
master_host:192.168.4.51
master_port:6351
master_link_status:up
master_last_io_seconds_ago:5
master_sync_in_progress:0
slave_repl_offset:182
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:c0706709efc096676419f8123a0b70f9a08e581a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:182
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:113
repl_backlog_histlen:70


配置一主多从

	Master:redis51
	     ↙↘
Slave:redis52	Slave:redis53

[root@redis53 ~]# vim /etc/redis/6379.conf 
# slaveof <masterip> <masterport>
slaveof 192.168.4.51 6351
# masterauth <master-password>
masterauth 123456
[root@redis53 ~]# /etc/init.d/redis_6379 stop 
[root@redis53 ~]# /etc/init.d/redis_6379 start 
[root@redis53 ~]# redis-cli -h 192.168.4.53 -p 6353
192.168.4.53:6353> INFO replication
# Replication
role:slave
master_host:192.168.4.51
master_port:6351
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:406
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:c0706709efc096676419f8123a0b70f9a08e581a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:406
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:323
repl_backlog_histlen:84


配置主从从结构
Master:redis51-->Slave(Master):redis52-->Slave:redis53

[root@redis52 ~]# vim /etc/redis/6379.conf 
 requirepass 123456
[root@redis52 ~]# vim /etc/init.d/redis_6379 
            $CLIEXEC -h 192.168.4.52 -p 6352 -a 123456 shutdown
[root@redis52 ~]# /etc/init.d/redis_6379 stop
[root@redis52 ~]# /etc/init.d/redis_6379 start
[root@redis53 ~]# /etc/init.d/redis_6379 stop
[root@redis53 ~]# vim /etc/redis/6379.conf 
# slaveof <masterip> <masterport>
#slaveof 192.168.4.51 6351
slaveof 192.168.4.52 6352
[root@redis53 ~]# /etc/init.d/redis_6379 start
[root@redis53 ~]# redis-cli -h 192.168.4.53 -p 6353
192.168.4.53:6353> info replication
# Replication
role:slave
master_host:192.168.4.52
master_port:6352
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:1904
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:c0706709efc096676419f8123a0b70f9a08e581a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1904
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1793
repl_backlog_histlen:112
[root@redis52 ~]# redis-cli -h 192.168.4.52 -p 6352 -a 123456
192.168.4.52:6352> info replication
# Replication
role:slave
master_host:192.168.4.51
master_port:6351
master_link_status:up
master_last_io_seconds_ago:9
master_sync_in_progress:0
slave_repl_offset:1946
slave_priority:100
slave_read_only:1
connected_slaves:1
slave0:ip=192.168.4.53,port=6353,state=online,offset=1946,lag=1
master_replid:c0706709efc096676419f8123a0b70f9a08e581a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:1946
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1485
repl_backlog_histlen:462


#哨兵模式:监视主库，当主库宕机之后从库自动升级为主库
//此处redis52兼任哨兵服务器
[root@redis52 ~]# vim /etc/sentinel.conf
sentinel monitor redis51 192.168.4.51 6351 1
sentinel auth-pass redis51 123456

//sentinel monitor 主机名 ip地址 端口 票数
//auth-pass 主机名 密码
//主机名:自定义
//票数:主库宕机后,票数大于1的主机被升级为主库   
//auth-pass:指定验证所需要的密码
[root@redis52 ~]# redis-sentinel /etc/sentinel.conf
3775:X 01 Nov 11:52:36.752 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
3775:X 01 Nov 11:52:36.752 # Redis version=4.0.8, bits=64, commit=00000000, modified=0, pid=3775, just started
3775:X 01 Nov 11:52:36.752 # Configuration loaded
3775:X 01 Nov 11:52:36.753 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 4.0.8 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 26379
 |    `-._   `._    /     _.-'    |     PID: 3775
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

3775:X 01 Nov 11:52:36.754 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
3775:X 01 Nov 11:52:36.773 # Sentinel ID is 49b221a5e0798339da6d98a938d1ab8892471592
3775:X 01 Nov 11:52:36.773 # +monitor master redis51 192.168.4.51 6351 quorum 1
3775:X 01 Nov 11:52:36.778 * +slave slave 192.168.4.52:6352 192.168.4.52 6352 @ redis51 192.168.4.51 6351
//此时哨兵服务器52会冻结命令行进入监控状态
[root@redis51 ~]# /etc/init.d/redis_6379 stop	
//停止redis51的服务后大概30-40秒,哨兵服务器52会有工作输出
3775:X 01 Nov 11:54:47.129 # +sdown master redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:47.129 # +odown master redis51 192.168.4.51 6351 #quorum 1/1
3775:X 01 Nov 11:54:47.129 # +new-epoch 1
3775:X 01 Nov 11:54:47.129 # +try-failover master redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:47.150 # +vote-for-leader 49b221a5e0798339da6d98a938d1ab8892471592 1
3775:X 01 Nov 11:54:47.150 # +elected-leader master redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:47.150 # +failover-state-select-slave master redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:47.217 # +selected-slave slave 192.168.4.52:6352 192.168.4.52 6352 @ redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:47.218 * +failover-state-send-slaveof-noone slave 192.168.4.52:6352 192.168.4.52 6352 @ redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:47.289 * +failover-state-wait-promotion slave 192.168.4.52:6352 192.168.4.52 6352 @ redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:48.217 # +promoted-slave slave 192.168.4.52:6352 192.168.4.52 6352 @ redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:48.217 # +failover-state-reconf-slaves master redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:48.261 # +failover-end master redis51 192.168.4.51 6351
3775:X 01 Nov 11:54:48.261 # +switch-master redis51 192.168.4.51 6351 192.168.4.52 6352
3775:X 01 Nov 11:54:48.261 * +slave slave 192.168.4.51:6351 192.168.4.51 6351 @ redis51 192.168.4.52 6352
3775:X 01 Nov 11:54:49.197 * +slave slave 192.168.4.53:6353 192.168.4.53 6353 @ redis51 192.168.4.52 6352
//ctrl+c退出监控状态
[root@redis52 ~]# !redis-cli 
redis-cli -h 192.168.4.52 -p 6352 -a 123456 
192.168.4.52:6352> INFO replication
# Replication
role:master
connected_slaves:1
slave0:ip=192.168.4.53,port=6353,state=online,offset=18180,lag=0
master_replid:ccc6af145c15c052d39e7bbac5d31a35f05a4770
master_replid2:c0706709efc096676419f8123a0b70f9a08e581a
master_repl_offset:18180
second_repl_offset:15286
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1485
repl_backlog_histlen:16696
//可以查询到redis52已经升级为主库了

[root@redis51 ~]# /etc/init.d/redis_6379 start 
[root@redis51 ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456

生产环境下一般用独立的哨兵服务器
一主多从:
	   ↗			Master:redis51
哨兵服务器60		 	    ↙↘
	   ↘		Slave:redis52	Slave:redis53


主从从:
Master:redis51-->Slave(Master):redis52-->Slave:redis53
     ↑
哨兵服务器60



#Redis持久化

RDB:RedisDataBaase
在指定时间间隔内,将内存中的数据集Snapshot快照写入硬盘
恢复时，将快照文件直接读到内存里

相关配置参数
文件名
dbfilename "dump.rdb"		//指定文件名
#   save ""			//启用RDB，去掉#号为禁用RDB

数据从内存保存到硬盘的频率
save 900 1		// 900秒内且有1次修改存盘  
save 300 10		//300秒内且有10次修改存盘
save 60 10000		//60秒内且有10000修改存盘

手动立刻存盘
save		//阻塞写存盘
bgsave		//不阻塞写存盘

使用RDB文件恢复数据
1.先清除现有数据
[root@redis51 ~]# /etc/init.d/redis_6379 stop 
[root@redis51 ~]# rm -rf /var/lib/redis/6379/dump.rdb 
2.设置存盘间隔为120秒10个key改变存盘
[root@redis51 ~]# vim /etc/redis/6379.conf 
save 900 1
save 120 10
save 60 10000
[root@redis51 ~]# /etc/init.d/redis_6379 start 
3.写入一些数据
[root@redis51 ~]# ls /var/lib/redis/6379/
[root@redis51 ~]# !redis-cli 
redis-cli -h 192.168.4.51 -p 6351 -a 123456 
192.168.4.51:6351> set v1 1
OK
192.168.4.51:6351> set v2 1
OK
192.168.4.51:6351> set v3 1
OK
192.168.4.51:6351> set v4 1
OK
192.168.4.51:6351> set v5 1
OK
192.168.4.51:6351> set v6 1
OK
192.168.4.51:6351> set v7 1
OK
192.168.4.51:6351> set v8 1
OK
192.168.4.51:6351> set v9 1
OK
192.168.4.51:6351> set v10 1
OK
//可以另外开一个终端查看dump.rdb文件的修改时间，有变化说明已经存盘(2分钟内就会变化)
4.备份RDB文件
[root@redis51 ~]# /etc/init.d/redis_6379 stop 
[root@redis51 ~]# cp /var/lib/redis/6379/dump.rdb{,.bak}
[root@redis51 ~]# ls /var/lib/redis/6379/
dump.rdb  dump.rdb.bak
5.删除数据
[root@redis51 ~]# rm -rf /var/lib/redis/6379/dump.rdb
6.查看一下删除后数据为空
[root@redis51 ~]# /etc/init.d/redis_6379 start
[root@redis51 ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456 
192.168.4.51:6351> keys *
(empty list or set)
7.使用RDB文件恢复数据（步骤必须正确,否则会恢复失败！）
[root@redis51 ~]# /etc/init.d/redis_6379 stop 		//步骤1:必须先停止服务
[root@redis51 ~]# mv /var/lib/redis/6379/dump.rdb{.bak,}	//步骤2:恢复数据
mv: overwrite ‘/var/lib/redis/6379/dump.rdb’? yes	//步骤3:覆盖空的数据
[root@redis51 ~]# /etc/init.d/redis_6379 start 		//步骤4:启动服务
8.验证恢复是否成功
[root@redis51 ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456 
192.168.4.51:6351> KEYS *
 1) "v10"
 2) "v1"
 3) "v7"
 4) "v6"
 5) "v8"
 6) "v2"
 7) "v9"
 8) "v3"
 9) "v5"
10) "v4"
RDB的缺点:意外宕机,最后一次存盘之后的数据会丢失


AOF:AppendOnlyFile
相关配置参数
文件名
appendfilename "appendonly.aof"  //文件名
appendonly   yes  //启用aof ，默认n

AOF文件记录,写操作的三种方式
appendfsync always	//有新的写操作立即记录,性能差,完整性好。
appendfsync everysec	//每秒记录一次,宕机时会丢失1秒的数据
appendfsync no		//从不记录


使用AOF文件恢复数据
1.清空现有数据
192.168.4.51:6351> flushall
192.168.4.51:6351> KEYS *
2.停止服务，修改配置文件，开启aof文件
[root@redis51 ~]# /etc/init.d/redis_6379 stop
[root@redis51 ~]# vim /etc/redis/6379.conf 
appendonly yes
# appendfsync always
appendfsync everysec
# appendfsync no
3.启动服务，可以查看到自动生成了appendonly.aof文件
[root@redis51 ~]# /etc/init.d/redis_6379 start
[root@redis51 ~]# ls /var/lib/redis/6379/
appendonly.aof  dump.rdb
4.写入数据
[root@redis51 ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456 
192.168.4.51:6351> set v1 1
5.停止服务，备份aof文件
[root@redis51 ~]# /etc/init.d/redis_6379 stop
[root@redis51 ~]# cp /var/lib/redis/6379/appendonly.aof{,.bak}
[root@redis51 ~]# ls /var/lib/redis/6379/
appendonly.aof.bak  dump.rdb
6.启动服务，删除数据
[root@redis51 ~]# /etc/init.d/redis_6379 start
[root@redis51 ~]# !redis-cli 
redis-cli -h 192.168.4.51 -p 6351 -a 123456  
192.168.4.51:6351> FLUSHALL
OK
192.168.4.51:6351> KEYS *
(empty list or set)
7.恢复数据(必须按步骤操作先停止服务！)
[root@redis51 ~]# /etc/init.d/redis_6379 stop 
[root@redis51 ~]# cp /var/lib/redis/6379/appendonly.aof{.bak,}
[root@redis51 ~]# /etc/init.d/redis_6379 start 
8.验证恢复是否成功
[root@redis51 ~]# !redis-cli
redis-cli -h 192.168.4.51 -p 6351 -a 123456  
192.168.4.51:6351> keys *


修复AOF文件
[root@redis51 ~]# /etc/init.d/redis_6379 stop
//破坏aof文件（shift+G在最后一行后随意添加一些内容）
[root@redis51 ~]# vim /var/lib/redis/6379/appendonly.aof
aaaaaaaaa
//启动服务，由于aof文件损坏，会启动失败
[root@redis51 ~]# /etc/init.d/redis_6379 start 
Starting Redis server...
[root@redis51 ~]# /etc/init.d/redis_6379 status
Redis is not running
[root@redis51 ~]# ss -nultp | grep :6351
//修复aof文件
[root@redis51 ~]# redis-check-aof --fix /var/lib/redis/6379/appendonly.aof
0x              33: Expected prefix '*', got: 'a'
AOF analyzed: size=62, ok_up_to=51, diff=11
This will shrink the AOF from 62 bytes, with 11 bytes, to 51 bytes
Continue? [y/N]: y
Successfully truncated AOF
//再启动会由于/var/run/redis_6379.pid已存在启动失败
[root@redis51 ~]# /etc/init.d/redis_6379 start 
/var/run/redis_6379.pid exists, process is already running or crashed
//删除/var/run/redis_6379.pid文件再启动，恢复成功
[root@redis51 ~]# rm -rf /var/run/redis_6379.pid
[root@redis51 ~]# /etc/init.d/redis_6379 start 
Starting Redis server...
[root@redis51 ~]# !redis-cli
redis-cli -h 192.168.4.51 -p 6351 -a 123456  
192.168.4.51:6351> keys *


#数据类型

1.string字符串
set key value [ex seconds] [px milliseconds] [nx|xx]
设置key及值,过期时间可以设置为秒或毫秒为单位
nx只有key不存在,才对key进行操作			//可以防止覆盖原有变量
xx只有key已存在,才对key进行操作			//省略该选项则默认就是xx

从偏移量开始复写特定位的变量值
格式：setrange 变量名 偏移量 变化部分的值
192.168.4.51:6351> set tel "17520304404"
OK
192.168.4.51:6351> setrange tel 3 ****		//改写为175****4404
(integer) 11
192.168.4.51:6351> get tel
"175****4404"

统计字符串长度
格式：strlen 变量名
192.168.4.51:6351> strlen tel

字符存在则追加,不存在则创建并赋值(返回值为key的长度)
192.168.4.51:6351> append name june
(integer) 4
192.168.4.51:6351> get name
"june"
192.168.4.51:6351> append name cheung
(integer) 10
192.168.4.51:6351> get name
"junecheung"

统计字串中被设置为1的比特位数量
>setbit account 0 1	//0001
>setbit account 2 0
>setbit account 3 1	//1001
>bitcount account	//结果为2
//应用情景：记录网站用户上线频率,如用户A上线了多少天等
           类似的数据如用户在某天上线，则使用setbit
           以用户名为key，将网站上线日为offset并在该offset上设置1
           最后计算用户总上线次数时，使用bitcount用户名即可这样
           即使网站运行10年，每个用户仅占用10*365比特位即456字节即可(占用空间小)
>setbit peter 100 1//网站上线100天用户登录了一次
>setbit peter 105 1//网站上线105天用户登录了一次
>bitcount peteer

decr key
将key中的值减1,key不存在则先初始化为0,再减1
>set test 10
>decr test
decrby key decrement
将key中的值,减去decrement
>set count 100
>decrby count 20

incr key
将key中的值减1,key不存在则先初始化为0,再减1
>set test 10
>incr test
incrby key increment
将key中的值,减去increment
>set count 100
>incrby count 20

mget key:一次性取多个变量(空格分隔开)
get key:一次性取一个变量
返回key所存储的字符串值
如果key不存在则返回特殊值nil
如果key的值不是字串,则返回错误,get只能处理字串

getrange key start end
返回字串值中范围内的子字串,截取范围为start到end
负数偏移量表示从末尾计数,-1表示倒数第一个字符
>set name “junecheung”
>getrange name -6 -1
"cheung"
>getrange name 0 3
"june"


incrbyfloat key increment
–为key中所储存的值加上浮点数增量 increment
>set num 16.1
>incrbyfloat num 1.1
"17.2"

mset key1 value1 key2 value2 ...
一次设置多个key及值，空格分隔



=================================================================================
		         10.Nosql-day04
=================================================================================
一、搭建MongoDB服务器
二、MongoDB服务基本使用


在主机192.168.4.51 上部署 MongoDB服务
1 安装软件包
  339  mkdir /usr/local/mongodb
  340  tar -zxvf mongodb-linux-x86_64-rhel70-3.6.3.tgz 
  345  cd mongodb-linux-x86_64-rhel70-3.6.3/
  348  cp -r bin /usr/local/mongodb/
  349  ls /usr/local/mongodb/
  350  ls /usr/local/mongodb/bin/

2 创建工作目录
  353  cd /usr/local/mongodb/
  356  mkdir etc
  358  mkdir log
  361  mkdir -p data/db

3 创建服务主配置文件
[root@mongodb51 mongodb]# cat  etc/mongodb.conf 
logpath=/usr/local/mongodb/log/mongodb.log
logappend=true						//日志文件设置为追加写入
dbpath=/usr/local/mongodb/data/db
fork=true						//启动fork记录程序pid
[root@mongodb51 mongodb]# 

4 启动 服务
]#/usr/local/mongodb/bin/mongod -f /usr/local/mongodb/etc/mongodb.conf 

查看服务信息
]#netstat -utnlp  | grep  :27017
]#ps -C mongod

连接服务
]#/usr/local/mongodb/bin/mongo
>exit

停止服务
]#/usr/local/mongodb/bin/mongod --shutdown -f /usr/local/mongodb/etc/mongodb.conf 


4 设置服务使用的ip地址和端口号
* 默认只允许本机连接

]# mstop 
]#vim /usr/local/mongodb/etc/mongodb.conf 
.....
port=27051
bind_ip=192.168.4.51
:wq
]# mstart

]# netstat -utnlp  | grep  :27051

]# /usr/local/mongodb/bin/mongo --host 192.168.4.51 --port 27051
管理mongodb数据库服务器上库集合文档
show dbs
db
use gamedb
show tables
db.t1.save({name:"bob",age:19})
db.t1.save({name:"tom",age:19,mail:"tom@163.com"})
db.t1.save({name:"tom",class:"1807",addr="bj"})
db.t1.find()
db.t1.findOne()
db.t1.find({name:"bob"})
db.t1.find({name:"tom"})
db.t1.insert({name:"bob",like:"a,b,c"})
db.t1.remove({name:"bob"})
db.t1.remove({})
db.t1.find()
show tables
db.t1.drop()
show tables
+++++++++++++++++++++++++++++
数据类型 ：
字符 bool  数值  数组 代码 日志 对象 内嵌 正则表达式
use userdb
show tables
> db.t2.save({name:"xiaosix",card:null})
> db.t2.save({name:"xiao7",gz:3.14})
> db.t2.save({name:"xiao8",gz:3})
> db.t2.save({pay:NumberInt(3)})
> db.t2.save({pay:NumberInt(3.999)})
> db.t2.save({pay:NumberLong(3.999)})
> db.t2.save({pay:NumberLong(3888)})
> db.t2.save({name:"lucy",
like:["boy","eat","sleep","game"]})
> db.t2.save({lg:"php",
code:function(){/* <?php echo "hello boy"; ?> */}  })
> db.t2.save({ name:"jerry" , day:new Date() })
> db.t2.find({name:"jerry"})
> db.t2.save({name:"lucy",stuid:ObjectId()})
> db.t2.find({name:"lucy"})
> db.t2.save({tarena:{addre:"bj",tel:"40018888",
person:"hsy"}  })
> db.t2.save({comment:"match null  line",bds:/^$/})


数据导入与导出
]# mkdir /mdb

# /usr/local/mongodb/bin/mongoexport  \
> --host 192.168.4.51 --port 27051 \
> -d userdb  -c t2  -f _id,name,age --type=csv  \
   > /mdb/userdb-t2.csv

]# cat /mdb/userdb-t2.csv


]#mongoexport --host 192.168.4.51 --port 27051 \
-d userdb -c t2  --type=json > /mdb/t2.json

]# cat /mdb/t2.json



]#mongoexport --host 192.168.4.51 --port 27051 \
-d userdb -c t2 -f name,age,class \
--type=csv > /mdb/userdb-t2.csv
 
]#mongoimport --host 192.168.4.51 --port 27051  \
-d db2  -c stutab --type=csv /mdb/userdb-t2.csv
>use studb
>db.stutab.find()
>db.stutab2.count()

]#mongoimport --host 192.168.4.51 --port 27051  \
-d db2  -c stutab2  --headerline  \
--type=csv /mdb/userdb-t2.csv 
>use studb
>db.stutab2.find()
>db.stutab2.count()

]#mongoimport --host 192.168.4.51 --port 27051  \
-d db2  -c stutab2  --headerline  \
--type=csv /mdb/userdb-t2.csv 
>use studb
>db.stutab2.find()
>db.stutab2.count()

]#mongoimport --host 192.168.4.51 --port 27051  \
-d db2  -c stutab2  --headerline --drop  \
--type=csv /mdb/userdb-t2.csv 

>use studb
>db.stutab2.find()
>db.stutab2.count()  


]#mongoimport --host 192.168.4.51 \
--port 27051  -d db2  -c stutab3  \
--headerline  --drop --type=csv /mdb/userdb-t2.csv 

]#mongoimport --host 192.168.4.51 \
--port 27051  -d db2  -c stutab4  \
--type=json /mdb/t2.json 

>use studb
>db.stutab4.find()
>db.stutab4.count() 
++++++++++++++++++++++++++++++++++++++
]#cp /etc/passwd  /mdb/
]#sed -i 's/:/,/g' /mdb/passwd 
]#head  /mdb/passwd
]# sed -i '1iname,password,uid,gid,comment,homedir,shell'  \
/mdb/passwd 

]# mongoimport --host 192.168.4.51 --port 27051  
-d db4 -c user --headerline  --type=csv /mdb/passwd

>use  db4
>show  tables
>db.user.count()
>db.user.find()-> it
>db.user.find({name:"root"})


]#mongoexport --host 192.168.4.51 \
--port 27051 -d db4  -c user  \
-f name,password,uid,gid,comment,homedir,shell \
--type=csv  > /mdb/user.csv


]#mongoexport --host 192.168.4.51 \
--port 27051 -d db4  -c user  --type=json  > /mdb/user2.json

休息到17：15

数据备份与恢复

]# cd /mdb
]# pwd
]# mongodump  --host  192.168.4.51   --port 27051  
]# ls
]# ls dump/
]# ls dump/db4
]# bsondump dump/db4/user.bson 
  
]# mkdir /mdb2
]# mongodump  --host  192.168.4.51   --port 27051  \
-d db4  -c user -o /mdb2

]# ls /mdb2
]# ls /mdb2/db4/

> use db4 
> show tables
> db.user.drop()

]#mongorestore --host 192.168.4.51  --port 27051 
-d db4  -c user /mdb2/db4/user.bson

]# mongorestore --host 192.168.4.51  --port 27051 \
-d db5  -c user2  /mdb2/db4/user.bson

> show dbs
> use db4
> show tables
> db.user.find()

=================================================================================
		         10.Nosql-day05
=================================================================================

#配置Replica Sets副本集
1.停止服务，修改副本集的模式为replSets
[root@mongodb51 ~]# /usr/local/mongodb/bin/mongod --shutdown -f /usr/local/mongodb/etc/mongodb.conf 
[root@mongodb52 ~]# /usr/local/mongodb/bin/mongod --shutdown -f /usr/local/mongodb/etc/mongodb.conf 
[root@mongodb53 ~]# /usr/local/mongodb/bin/mongod --shutdown -f /usr/local/mongodb/etc/mongodb.conf 
[root@mongodb51 ~]# vim /usr/local/mongodb/etc/mongodb.conf 
replSet=rs1		//rs1是集群名称
[root@mongodb52 ~]# vim /usr/local/mongodb/etc/mongodb.conf 
replSet=rs1			
[root@mongodb53 ~]# vim /usr/local/mongodb/etc/mongodb.conf 
replSet=rs1			
[root@mongodb51 ~]# /usr/local/mongodb/bin/mongod  -f /usr/local/mongodb/etc/mongodb.conf
[root@mongodb52 ~]# /usr/local/mongodb/bin/mongod  -f /usr/local/mongodb/etc/mongodb.conf
[root@mongodb53 ~]# /usr/local/mongodb/bin/mongod  -f /usr/local/mongodb/etc/mongodb.conf
[root@mongodb51 ~]# ss -nultp | grep mongod
[root@mongodb52 ~]# ss -nultp | grep mongod
[root@mongodb53 ~]# ss -nultp | grep mongod
配置节点信息
[root@mongodb51 ~]# /usr/local/mongodb/bin/mongo --host 192.168.4.51 --port 27051
> config = {
... _id:"rs1",
... members:[
... {_id:0,host:"192.168.4.51:27051"},
... {_id:1,host:"192.168.4.52:27052"},
... {_id:2,host:"192.168.4.53:27053"}
... ]
... }
{
	"_id" : "rs1",
	"members" : [
		{
			"_id" : 0,
			"host" : "192.168.4.51:27051"
		},
		{
			"_id" : 1,
			"host" : "192.168.4.52:27052"
		},
		{
			"_id" : 2,
			"host" : "192.168.4.53:27053"
		}
	]
}
初始化ReplicaSets环境
> rs.initiate(config)
{
	"ok" : 1,
	"operationTime" : Timestamp(1541209788, 1),
	"$clusterTime" : {
		"clusterTime" : Timestamp(1541209788, 1),
		"signature" : {
			"hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
			"keyId" : NumberLong(0)
		}
	}
}
rs1:SECONDARY> （敲一下回车）
rs1:PRIMARY> 
rs1:PRIMARY> rs.status()	//查看集群状态
rs1:PRIMARY> rs.isMaster()	//查看主库

测试集群:
客户端连接主库存取数据
[root@mongodb53 ~]# /usr/local/mongodb/bin/mongo --host 192.168.4.51 --port 27051
rs1:PRIMARY> use db5
switched to db db5
rs1:PRIMARY> db.t1.save({name:"bob",age:19})
WriteResult({ "nInserted" : 1 })
rs1:PRIMARY> db.t1.find()
{ "_id" : ObjectId("5bdd076ae03bcefa5dd588c6"), "name" : "bob", "age" : 19 }

客户端连接从库存储数据
rs1:SECONDARY> db.getMongo().setSlaveOk()	//连接从库时，允许操作数据
rs1:SECONDARY> use db5
switched to db db5
rs1:SECONDARY> show tables
t1
rs1:SECONDARY> db.t1.find()
{ "_id" : ObjectId("5bdd076ae03bcefa5dd588c6"), "name" : "bob", "age" : 19 }

测试集群高可用功能
停止mongodb51的mongod服务
[root@mongodb51 ~]# /usr/local/mongodb/bin/mongod  --shutdown -f /usr/local/mongodb/etc/mongodb.conf
在mongodb52和53上看一下，其中一台升级为主库
rs1:SECONDARY> rs.isMaster()
重新启动mongodb51的服务
[root@mongodb51 ~]# /usr/local/mongodb/bin/mongod -f /usr/local/mongodb/etc/mongodb.conf
[root@mongodb51 ~]# /usr/local/mongodb/bin/mongo --host 192.168.4.51 --port 27051
rs1:SECONDARY> rs.isMaster()	//51现在成为当前主库的从库


=================================================================================
		         11.Security-day01
=================================================================================
服务器安全=系统安全+服务安全+数据安全+网络安全

#用户帐号安全

与系统用户相关的配置文件和命令
/etc/passwd
/etc/shadow
/etc/group
/etc/gshadow
ls -a /etc/skel/	#添加系统帐号的初始环境配置文件
			(创建用户时自动复制该目录下文档到用户家目录)
[root@Security60 ~]# echo test > /etc/skel/test.txt
[root@Security60 ~]# useradd test
[root@Security60 ~]# su - test
[test@Security60 ~]$ ls
test.txt
ls /etc/login.defs	#添加一个系统帐号的默认设置
			(如不指定shell则默认时/bin/bash)

chage	//修改用户密码限制条件
[root@Security60 ~]# useradd admin
[root@Security60 ~]# echo 123456 | passwd --stdin admin
Changing password for user admin.
passwd: all authentication tokens updated successfully.
[root@Security60 ~]# chage -d 0 admin
//把用户最近修改密码的次数改成0，用于强制首次登录需要修改密码
[root@Security60 ~]# ssh admin@localhost
The authenticity of host 'localhost (::1)' can't be established.
ECDSA key fingerprint is SHA256:59Byua15gv4TAVEm7YutMtmgXfxGTYbzSfO84kICu0E.
ECDSA key fingerprint is MD5:7e:6e:95:ed:84:fe:5b:8e:26:94:73:9b:c3:4b:90:cb.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'localhost' (ECDSA) to the list of known hosts.
admin@localhost's password: 
You are required to change your password immediately (root enforced)
WARNING: Your password has expired.
You must change your password now and login again!
更改用户 admin 的密码 。
为 admin 更改 STRESS 密码。
（当前）UNIX 密码：123456
新的 密码：123456
无效的密码： 这个密码和原来的相同
新的 密码：123123
无效的密码： 密码与原来的太相似
新的 密码：123qqq...A
重新输入新的 密码：123qqq...A
passwd：所有的身份验证令牌已经成功更新。
Connection to localhost closed.
[root@Security60 ~]# ssh admin@localhost
admin@localhost's password: 
Last login: Mon Nov  5 09:25:54 2018 from ::1
[admin@Security60 ~]$ exit
[root@Security60 ~]# chage -l admin 
Last password change					: Nov 05, 2018
Password expires(过期)					: never
Password inactive(失效)					: never
Account expires						: never
Minimum number of days between password change		: 0
Maximum number of days between password change		: 99999
Number of days of warning before password expires	: 7
[root@Security60 ~]# grep admin /etc/shadow
admin:$6$N.G1mPcR$37Oc6fyQy.ey5t5JJs2H6R/YA48HtyjvbYRweHNcK9zD3VpiKnzc0kAj55v..hvHjlmjm5waEJgTBtTvPxkZo.:17840:0:99999:7:::
[root@Security60 ~]# cal
    November 2018   
Su Mo Tu We Th Fr Sa
             1  2  3
 4 [5] 6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30
[root@Security60 ~]# chage -E 2018-12-5 admin	//设置密码一个月后即12-5过期
[root@Security60 ~]# chage -l admin 
Last password change					: Nov 05, 2018
Password expires					: never
Password inactive					: never
Account expires						: Dec 05, 2018
Minimum number of days between password change		: 0
Maximum number of days between password change		: 99999
Number of days of warning before password expires	: 7
[root@Security60 ~]# grep -v ^$ /etc/login.defs	  //该文件指定了用户不过期的默认设置
[root@Security60 ~]# chage -m 10 admin 		//每10天要修改一次密码
[root@Security60 ~]# chage -l admin 
Last password change					: Nov 05, 2018
Password expires					: never
Password inactive					: never
Account expires						: Dec 05, 2018
Minimum number of days between password change		: 10
Maximum number of days between password change		: 99999
Number of days of warning before password expires	: 7
[root@Security60 ~]# passwd -S test 		//查看用户密码信息
test LK 2018-11-05 0 99999 7 -1 (Password locked.)//新建用户未设定密码，显示密码锁定
[root@Security60 ~]# echo 123456 | passwd --stdin test 
Changing password for user test.
passwd: all authentication tokens updated successfully.
[root@Security60 ~]# passwd -S test 	//设定密码后LK变成PS，显示密码加密方式SHA512
test PS 2018-11-05 0 99999 7 -1 (Password set, SHA512 crypt.)
[root@Security60 ~]# passwd -l test 	//锁定密码
Locking password for user test.
passwd: Success
[root@Security60 ~]# passwd -S test 	//状态变成LK(Lock)
test LK 2018-11-05 0 99999 7 -1 (Password locked.)
[root@Security60 ~]# passwd -u test 	//解锁密码
Unlocking password for user test.
passwd: Success
[root@Security60 ~]# passwd -S test 
test PS 2018-11-05 0 99999 7 -1 (Password set, SHA512 crypt.)
[root@Security60 ~]# passwd -d test 	//清空密码
Removing password for user test.
passwd: Success
[root@Security60 ~]# passwd -S test 
test NP 2018-11-05 0 99999 7 -1 (Empty password.)
[root@Security60 ~]# grep test /etc/shadow
test::17840:0:99999:7:::

#伪装登录提示(隐藏内核，系统版本)
配置文件
本地登录:/etc/issue
远程登录:/etc/issue.net
//默认会提示内核，系统版本等信息

#文件系统安全
1.程序和服务控制
禁用非必要的系统服务:使用systemctl,chkconfig工具
rhel7:systemctl
rhel6:chkconfig 
[root@Security60 ~]# yum -y install httpd
[root@Security60 ~]# chkconfig httpd on		//设置开机自启
[root@Security60 ~]# chkconfig httpd off	//禁止开机自启
[root@Security60 ~]# service httpd status	//rhel6查看服务状态
[root@Security60 ~]# service httpd start	//rhel6启动服务
[root@Security60 ~]# service httpd stop		//rhel6停止服务

2.锁定/解锁保护文件
EXT3/EXT4的文件属性控制
chattr,lsattr
+,-,=控制方式
属性i:不可变(immutable)
属性a:仅可追加(append only)
[root@Security60 ~]# chattr +i /etc/hosts
[root@Security60 ~]# rm -rf /etc/hosts
rm: cannot remove ‘/etc/hosts’: Operation not permitted
[root@Security60 ~]# mv /etc/hosts /root/
mv: cannot move ‘/etc/hosts’ to ‘/root/hosts’: Operation not permitted
[root@Security60 ~]# echo "1.1.1.1 www.qq.com" >> /etc/hosts
-bash: /etc/hosts: Permission denied
[root@Security60 ~]# lsattr /etc/hosts	//查看锁定状态
----i----------- /etc/hosts
[root@Security60 ~]# chattr -i /etc/hosts
[root@Security60 ~]# lsattr /etc/hosts
---------------- /etc/hosts
[root@Security60 ~]# chattr +a /etc/hosts
[root@Security60 ~]# lsattr /etc/hosts
-----a---------- /etc/hosts
[root@Security60 ~]# echo test > /etc/hosts
-bash: /etc/hosts: Operation not permitted
[root@Security60 ~]# chattr =ai /etc/hosts
[root@Security60 ~]# lsattr /etc/hosts
----ia---------- /etc/hosts
[root@Security60 ~]# chattr = /etc/hosts
[root@Security60 ~]# lsattr /etc/hosts
---------------- /etc/hosts


#su切换用户身份(SubstituteUser)
快速切换为指定的其他用户
普通用户执行时，需验证目标用户的口令
root执行时，无需验证口令

命令格式
su [-] 目标用户	//-是可选项:如果有-代表切换到目标用户的身份和环境
			   没有-则代表仅切换到目标用户的身份,没有切换到目标用户的环境
su [-] -c "命令" 目标用户	//su命令不写目标用户，则默认是root

[root@Security60 ~]# su - admin
Last login: Mon Nov  5 09:28:39 CST 2018 from ::1 on pts/1
[admin@Security60 ~]$ systemctl start httpd
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===
Authentication is required to manage system services or units.
Authenticating as: root
Password: 123456
==== AUTHENTICATION COMPLETE ===	//仅验证完成，没有真正启动服务

[admin@Security60 ~]$ su - -c "systemctl status httpd"	//用root用户查看服务状态
密码：
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)
   Active: inactive (dead)		//服务未启动
     Docs: man:httpd(8)
           man:apachectl(8)
[admin@Security60 ~]$ su - -c "systemctl start httpd"	//用root用户启动服务
密码：
[admin@Security60 ~]$ su - -c "systemctl status httpd"
密码：
● httpd.service - The Apache HTTP Server	
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; vendor preset: disabled)
   Active: active (running) since 一 2018-11-05 11:03:47 CST; 3s ago  //服务已启动
     Docs: man:httpd(8)
           man:apachectl(8)
 Main PID: 2446 (httpd)
   Status: "Processing requests..."
   CGroup: /system.slice/httpd.service
           ├─2446 /usr/sbin/httpd -DFOREGROUND
           ├─2447 /usr/sbin/httpd -DFOREGROUND
           ├─2448 /usr/sbin/httpd -DFOREGROUND
           ├─2449 /usr/sbin/httpd -DFOREGROUND
           ├─2450 /usr/sbin/httpd -DFOREGROUND
           └─2451 /usr/sbin/httpd -DFOREGROUND

#sudo提升权限(Super or another Do)
管理员预先为用户设置执行许可
被授权用户有权执行授权的命令，验证自己的口令

命令格式
sudo 特权命令
sudo [-u 目标用户] 特权命令

配置sudo授权
修改方法:
visudo			//命令配置
或
vim /etc/sudoers	//修改配置文件

which 命令		//查看命令的绝对路径
visudo localhost，主机名=命令1绝对路径,命令2绝对路径...(!命令绝对路径则为取反,不允许)

普通用户sudo -l 查看自己有的权限

给用户授权
[root@Security60 ~]# useradd  tom
[root@Security60 ~]# useradd  bob
[root@Security60 ~]# echo 123456 | passwd --stdin tom
[root@Security60 ~]# echo 123456 | passwd --stdin bob
[root@Security60 ~]# vim /etc/sudoers
root    ALL=(ALL)       ALL
bob	localhost,Security60=/usr/bin/systemctl * httpd,/usr/bin/vim /etc/httpd/conf/httpd.conf
:wq!		/无法直接wq保存并退出,加!强制执行
给组授权
[root@Security60 ~]# groupadd webadmin
[root@Security60 ~]# gpasswd -a bob webadmin
[root@Security60 ~]# gpasswd -a tom webadmin
[root@Security60 ~]# vim /etc/sudoers
%wheel  ALL=(ALL)       ALL
%webadmin localhost,Security60=/usr/bin/systemctl *,/usr/bin/vim /etc/httpd/conf/httpd.conf

sudo别名设置(配置文件里默认存在一些,去掉注释就可以用)
User_Alias 别名=用户名1,用户名2...
Host_Alias 别名=主机名1,主机名2...
Cmnd_Alias 别名=命令绝对路径1,命令绝对路径2...

[root@Security60 ~]# vim /etc/sudoers
# Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum  //去掉注释
bob     localhost,Security60=/usr/bin/systemctl * httpd,/usr/bin/vim /etc/httpd/conf/httpd.conf,SOFTWARE		//在bob的权限中加入SOFTWARE
[root@June ~]# ssh bob@192.168.4.60
[bob@Security60 ~]$ sudo yum -y install autofs
[bob@Security60 ~]$ sudo rpm -e autofs

修改全局配置，启用sudo日志
[root@Security60 ~]# vim /etc/sudoers
Defaults logfile="/var/log/sudo"
[bob@Security60 ~]$ sudo yum -y install autofs
[root@Security60 ~]# cat /var/log/sudo


#ssh服务
除了ssh还有telnet也可用于远程连接

[root@Security60 ~]# vim /etc/ssh/sshd_config 
Protocol 2			//启用SSH V2版本协议
Port 444			//设置ssh的端口
ListenAddress 192.168.4.254	//设置监听的IP地址
PermitRootLogin no		//禁止root登录(了解,一般不开)
[root@Security60 ~]# systemctl restart sshd
[root@June ~]# ssh 192.168.4.60
ssh: connect to host 192.168.4.60 port 22: Connection refused
[root@June ~]# ssh -p 444 192.168.4.60

其它配置项
UseDNS no			//不解析客户机地址
LoginGraceTime 1m		//超过最多认证次数之后,登录时间隔限制为1m
MaxAuthTries 3			//每次连接最多认证次数为3次
DenyUsers 用户1 用户2 ...	//拒绝登录的用户名黑名单
AllowUsers 用户1 用户2 ...	//允许登录的用户名白名单
DenyGroups 组1 组2 ...		//拒绝登录的组黑名单
AllowGroups 组1 组2 ...		//拒绝登录的组白名单

禁止密码验证登录			//用密钥对验证
PasswordAuthentication no
#ListenAddress 192.168.4.254	//必须要把ListenAddress注释掉才能禁止密码登录

#SELinux
[root@Security60 ~]# sestatus	//查看selinux状态

SELinux策略设置
查看安全上下文策略
[root@Security60 ~]# ls -Z /var/www/html/test.html 	//文件
[root@Security60 ~]# ls -Zd /var/www/html/	 	//目录
[root@Security60 ~]# ps auxZ | grep httpd		//进程
//四列分别代表：用户:角色:访问类型:选项
[root@Security60 ~]# ls -Zd /root/
dr-xr-x---. root root system_u:object_r:admin_home_t:s0 /root/
[root@Security60 ~]# ls -Zd /home/bob/
drwx------. bob bob unconfined_u:object_r:user_home_dir_t:s0 /home/bob/
[root@Security60 ~]# ls -Zd /var/www/html/
drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html/
[root@Security60 ~]# ls -Zd /var/ftp/
drwxr-xr-x. root root system_u:object_r:public_content_t:s0 /var/ftp/
//移动的文件，原有的上下文属性不变
//复制的文件，自动继承目标位置的上下文

修改安全上下文
命令
chcon 选项 /文档目录
-t 指定访问类型
-R 递归修改
[root@Security60 ~]# echo aaa > /root/a.html
[root@Security60 ~]# mv /root/a.html /var/www/html/
[root@Security60 ~]# ls -Z /var/www/html/
[root@Security60 ~]# chcon -t httpd_sys_content_t /var/www/html/a.html 
[root@Security60 ~]# ls -Z /var/www/html/
[root@Security60 ~]# echo bbb > /root/b.html
[root@Security60 ~]# mv /root/b.html /var/www/html/
[root@Security60 ~]# chcon -R -t httpd_sys_content_t /var/www/html
[root@Security60 ~]# ls -Z /var/www/html/

重置安全上下文:恢复为所在位置的默认上下文属性
restorecon 选项 /文档目录
-R 递归修改
或
创建/.autorelabel文件：下次重启后全部重置

修改波尔值
[root@Security60 ~]# systemctl restart vsftpd
[root@Security60 ~]# mkdir /var/ftp/sharedir
[root@Security60 ~]# chmod o+w /var/ftp/sharedir/
[root@Security60 ~]# ls -ld /var/ftp/sharedir/
drwxr-xrwx. 2 root root 6 Nov  6 10:23 /var/ftp/sharedir/
[root@Security60 ~]# cp /etc/passwd /var/ftp/sharedir/
[root@Security60 ~]# chmod +r /var/ftp/sharedir/passwd 
[root@Security60 ~]# ls -l /var/ftp/sharedir/passwd
-rw-r--r--. 1 root root 2373 Nov  6 10:25 /var/ftp/sharedir/passwd
[root@Security60 ~]# vim /etc/vsftpd/vsftpd.conf 
anon_upload_enable=YES			//开启匿名用户上传
真机安装ftp客户端软件
[root@June ~]# yum -y install ftp
[root@Security60 ~]# getsebool -a | grep ftp
[root@Security60 ~]# setsebool ftpd_anon_write on
[root@Security60 ~]# setsebool ftpd_full_access on
[root@June ~]# ftp 192.168.4.60
Connected to 192.168.4.60 (192.168.4.60).
220 (vsFTPd 3.0.2)
Name (192.168.4.60:root): ftp			//匿名登录用户名用ftp
331 Please specify the password.
Password:					//匿名登录密码直接回车跳过
ftp> lcd /etc/
Local directory now /etc
ftp> cd sharedir
ftp> put hosts
local: hosts remote: hosts
227 Entering Passive Mode (192,168,4,60,22,143).
150 Ok to send data.
226 Transfer complete.
554 bytes sent in 2.4e-05 secs (23083.33 Kbytes/sec)

[root@Security60 ~]# setsebool ftpd_anon_write off
[root@Security60 ~]# setsebool ftpd_full_access off
[root@Security60 ~]# rpm -qa | grep -i shoot
setroubleshoot-3.2.28-3.el7.x86_64
setroubleshoot-server-3.2.28-3.el7.x86_64
setroubleshoot-plugins-3.0.65-1.el7.noarch
[root@Security60 ~]# tail -f /var/log/messages 
[root@June ~]# ftp 192.168.4.60
Name (192.168.4.60:root): ftp
ftp> cd sharedir
ftp> lcd /etc/
ftp> put shadow
local: shadow remote: shadow
227 Entering Passive Mode (192,168,4,60,85,206).
553 Could not create file.
[root@Security60 ~]# grep setroubleshoot /var/log/messages | tail -1
Nov  6 11:21:10 Security60 setroubleshoot: SELinux is preventing vsftpd from write access on the directory /var/ftp/sharedir. For complete SELinux messages run: sealert -l 3472613e-5d4c-465e-a755-a5cb8b781a50
[root@Security60 ~]# sealert -l 3472613e-5d4c-465e-a755-a5cb8b781a50
//根据提示可以排查除上传失败的原因
setsebool -P allow_ftpd_anon_write 1
setsebool -P ftpd_full_access 1

=================================================================================
		         11.Security-day02
=================================================================================
#数据加密与解密
GPG加解密工具
GnuPG,GNU Privacy Guard
http://www.gnupg.org/
最流行的数据加密,数字签名工具软件
[root@Security60 ~]# which gpg
/usr/bin/gpg
[root@Security60 ~]# rpm -qa |grep gnupg
gnupg2-2.0.22-4.el7.x86_64
[root@Security60 ~]# gpg --version
gpg (GnuPG) 2.0.22
libgcrypt 1.5.3
Copyright (C) 2013 Free Software Foundation, Inc.
Home: ~/.gnupg
Supported algorithms:		//支持的算法
Pubkey: RSA, ?, ?, ELG, DSA	//公钥
Cipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, //对称加密
        CAMELLIA128, CAMELLIA192, CAMELLIA256
Hash: MD5, SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224	//散列
Compression: Uncompressed, ZIP, ZLIB, BZIP2

1.对称加密
加密操作:gpg -c 文件
解密操作:gpg -d 文件

加密文件
[root@A ~]# gpg -c test.sh			//输入验证密码
[root@A ~]# scp test.sh.gpg B:/root/
解密别人传过来的文件
[root@B ~]# gpg -d test.txt.gpg			//输入密码解密
[root@B ~]# gpg -d test.txt.gpg > test_1.txt	//解密后导成文件
[root@B ~]# cat test_1.txt 

2.非对称加密与解密(密钥对)
Step01.B把自己的公钥传给A
userb@Security60 ~]$ gpg --gen-key
gpg (GnuPG) 2.0.22; Copyright (C) 2013 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

gpg: directory `/home/userb/.gnupg' created
gpg: new configuration file `/home/userb/.gnupg/gpg.conf' created
gpg: WARNING: options in `/home/userb/.gnupg/gpg.conf' are not yet active during this run
gpg: keyring `/home/userb/.gnupg/secring.gpg' created
gpg: keyring `/home/userb/.gnupg/pubring.gpg' created
Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? 	//直接回车选择默认算法(1) RSA and RSA (default)
RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048) 1024
Requested keysize is 1024 bits
Please specify how long the key should be valid.	//选择密钥对过期时间
         0 = key does not expire
      <n>  = key expires in n days
      <n>w = key expires in n weeks
      <n>m = key expires in n months
      <n>y = key expires in n years
Key is valid for? (0) 			//0代表不过过期
Key does not expire at all
Is this correct? (y/N) y		//输入y确定

GnuPG needs to construct a user ID to identify your key.

Real name: cheungjune			//输入姓名
Email address: cheungjune@foxmail.com	//输入邮箱
Comment: usera				//输入描述注释
You selected this USER-ID:
    "cheungjune (usera) <cheungjune@foxmail.com>"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O	//大写O确认OK
You need a Passphrase to protect your secret key.
┌────────────────────────
│ Enter passphrase                                    
│                                                     
│                                                     
│ Passphrase ______________________________ 		//输入密码
│                                                     
│       <OK>                <Cancel>     
└────────────────────────
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: /home/userb/.gnupg/trustdb.gpg: trustdb created
gpg: key 39F7AE3C marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   1024R/39F7AE3C 2018-11-06
      Key fingerprint = C1D3 DDBB B584 DBEE 6629  E419 7436 AFB2 39F7 AE3C
uid                  cheungjune (usera) <cheungjune@foxmail.com>
sub   1024R/E0E5CB62 2018-11-06
//有可能因为系统缺少随机数导致长期未生成密钥对
//解决方法：对/a.txt文件进行写0操作,让磁盘做写操作
//[userb@Security60 ~]$ dd if=/dev/zero of=/a.txt bs=1M count=10240
//导出公钥并放到系统公用目录/tmp给usera
[userb@Security60 ~]$ gpg --export -a > userb.pub
[userb@Security60 ~]$ ls userb.pub 
userb.pub
[userb@Security60 ~]$ pwd
/home/userb
[userb@Security60 ~]$ cp userb.pub /tmp/

Step02.A使用B的公钥加密数据，将加密后的数据给B
//导入公钥
[usera@Security60 ~]$ rm -rf ~/.gnupg
[usera@Security60 ~]$ gpg --import /tmp/userb.pub 
[usera@Security60 ~]$ ls ~/.gnupg/
gpg.conf  pubring.gpg  pubring.gpg~  secring.gpg  trustdb.gpg
//加密有两种方法
加密方法1
[usera@Security60 ~]$ gpg -e t2.txt 
You did not specify a user ID. (you may use "-r")	//或者加-r选项
Current recipients:
Enter the user ID.  End with an empty line: cheungjune
或
加密方法2
[usera@Security60 ~]$ gpg -e -r cheungjune t2.txt 
Use this key anyway? (y/N) y
[usera@Security60 ~]$ ls
t2.txt  t2.txt.gpg  test.txt
把加密后的文件拷贝到公共目录下给userb
[usera@Security60 ~]$ cp t2.txt.gpg /tmp/

Step03.B用自己的私钥解密数据
//此时userb已经能看到该文件,但是是乱码
[userb@Security60 ~]$ cat /tmp/t2.txt.gpg 
���b�E����^����_n�v8��z��^�c:;-�N�A魻'� �'�*��|}&7�3�����d��6���j�٪���]���>bIr�r[����7aVZm�U�WNH��X1�s
//解密加密文件
[userb@Security60 ~]$ gpg -d /tmp/t2.txt.gpg > c.txt		//输入密码
lqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqk
xPleaseEnter the passphrase to unlock the secret key for theOpenPGP certificate:x
x "cheungjune (usera) <cheungjune@foxmail.com>"                                 x
x 1024-bit RSA key, ID E0E5CB62,                                                x
x created 2018-11-06 (main key ID 39F7AE3C).                                    x
x                                                                               x
x                                                                               x
x Passphrase _______________________________________________                    x
x                                                                               x
x            <OK>                                                  <Cancel>     x
mqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqj
[userb@Security60 ~]$ cat c.txt 

3.数字签名:不可否认性(不可抵赖)，验证完整性
[userb@Security60 ~]$ gpg -b d.txt 		//签名需要调用私钥，输入私钥密码
You need a passphrase to unlock the secret key for
user: "cheungjune (usera) <cheungjune@foxmail.com>"
1024-bit RSA key, ID 39F7AE3C, created 2018-11-06
[userb@Security60 ~]$ ls d.txt*
d.txt  d.txt.sig
[userb@Security60 ~]$ cp d.txt* /tmp/
[usera@Security60 ~]$ ls /tmp/d.txt*
/tmp/d.txt  /tmp/d.txt.sig
[usera@Security60 ~]$ cat /tmp/d.txt	//usera能看到文件，但是不知道是否完整
ABCDEF
WWWWWW
[usera@Security60 ~]$ gpg --verify /tmp/d.txt.sig 
gpg: Signature made Tue 06 Nov 2018 04:09:25 PM CST using RSA key ID 39F7AE3C
gpg: Good signature from "cheungjune (usera) <cheungjune@foxmail.com>"
//签名来自cheungjune
gpg: WARNING: This key is not certified with a trusted signature!
//警告：没有证据表明这个签名是可信的卡名
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: C1D3 DDBB B584 DBEE 6629  E419 7436 AFB2 39F7 AE3C
//私钥的指纹
[root@Security60 ~]# vim /tmp/d.txt	//用root身份修改文件内容
ABCDEFG
WWWWWW
[usera@Security60 ~]$ gpg --verify /tmp/d.txt.sig 	//会显示签名损坏了
gpg: Signature made Tue 06 Nov 2018 04:09:25 PM CST using RSA key ID 39F7AE3C
gpg: BAD signature from "cheungjune (usera) <cheungjune@foxmail.com>"
[root@Security60 ~]# vim /tmp/d.txt	//再次修改回去
ABCDEF
WWWWWW
[usera@Security60 ~]$ gpg --verify /tmp/d.txt.sig 	//签名恢复正常
验证签名的真实性
[userb@Security60 ~]$ gpg --fingerprint		//把指纹打印出来给接收方比对
/home/userb/.gnupg/pubring.gpg
------------------------------
pub   1024R/39F7AE3C 2018-11-06
      Key fingerprint = C1D3 DDBB B584 DBEE 6629  E419 7436 AFB2 39F7 AE3C
uid                  cheungjune (usera) <cheungjune@foxmail.com>
sub   1024R/E0E5CB62 2018-11-06

#aide入侵检测系统(只能检测,但不能防止)
1.安装软件包
[root@Security60 ~]# yum -y install aide
[root@Security60 ~]# vim /etc/aide.conf 
@@define DBDIR /var/lib/aide			//数据库目录
@@define LOGDIR /var/log/aide			//日志目录
database=file:@@{DBDIR}/aide.db.gz		
database_out=file:@@{DBDIR}/aide.db.new.gz	//数据库文件名
# These are the default rules.
#p:      permissions				//希望检测的项目
#i:      inode:
#n:      number of links
#u:      user
#g:      group
#s:      size
#md5:    md5 checksum
#sha1:   sha1 checksum
#sha256:        sha256 checksum
FIPSR = p+i+n+u+g+s+m+c+acl+selinux+xattrs+sha256   //FIRSP是别名,代表=后面的检查项
//从99行到最后一行是默认检查的目录,全注释掉自定义想要检查的目录加快检查速度
:99,312 s/^/#/
//在最后面插入一行
/testdir FIRSP		//代表检查/testdit目录下的文件,检查项是FIPSR
[root@Security60 ~]# mkdir /testdir
[root@Security60 ~]# echo ABCDEFGHIJ > /testdir/test.txt
//生成被监控目录的初始检测信息
[root@Security60 ~]# aide -i
AIDE, version 0.15.1
### AIDE database at /var/lib/aide/aide.db.new.gz initialized.
[root@Security60 ~]# ls /var/lib/aide/
aide.db.new.gz
//拷贝一份被监控目录的初始检测信息,防止被入侵者删除
[root@Security60 ~]# cp /var/lib/aide/aide.db.new.gz /root/
//把初始检测信息拷贝回，并改名为检测时软件要读的文件名
[root@Security60 ~]# mv /root/aide.db.new.gz /var/lib/aide/aide.db.gz
//模拟入侵者，在测试目录新建文件
[root@Security60 ~]# echo bbbb > /testdir/b.txt 
//检测
[root@Security60 ~]# aide -C
Summary:
  Total number of files:	4		//总文件数
  Added files:			1		//添加的文件
  Removed files:		0		//移除的文件
  Changed files:		1		//改变的文件

---------------------------------------------------
Added files:
---------------------------------------------------

added: /testdir/b.txt

---------------------------------------------------
Changed files:
---------------------------------------------------

changed: /testdir

---------------------------------------------------
Detailed information about changes:
---------------------------------------------------


#扫描与抓包
1.NMAP扫描
基本用法：
nmap [扫描类型] [选项] 扫描目标
-sS,TCP半开式扫描：没有完成三次握手-四次断开,省略最后一次请求
-sT,TCP全开式扫描：完成三次握手-四次断开才算扫描结束
-sU,UDP扫描
-sP,ICMP扫描
-A，目标系统全面分析
[root@June ~]# yum -y install nmap
[root@June ~]# man nmap
[root@June ~]# nmap -sP 176.121.213.0/24	//查看对应网段是否可以ping通
[root@June ~]# nmap -p 80 176.121.213.89	//查看对应ip的端口是否开放
Starting Nmap 6.40 ( http://nmap.org ) at 2018-11-06 17:44 CST
Nmap scan report for zyk (176.121.213.89)
Host is up (0.00018s latency).			//扫描结果:端口开放
PORT   STATE SERVICE
80/tcp open  http
MAC Address: 1C:1B:0D:4C:5B:33 (Unknown)
Nmap done: 1 IP address (1 host up) scanned in 0.09 seconds


2.tcpdump抓包
基本用法
tcpdump [选项] [过滤条件]
选项					过滤条件
-i,指定监控的网络接口		类型:host,net,port,portrange
-A,转换为ACSII码以方便阅读	方向:src host(源地址),dst host(目标地址)
-w,将数据包信息保存到指定文件	协议:tcp,udp,ip,wlan,arp
-r，从指定文件读取数据包信息	多个条件组合:and,or,not
//默认情况下不指定网路接口是监控eth0网口


[root@June ~]# tcpdump -i enp2s0 -w /tmp/tcpdump.cap
[root@June ~]# tcpdump -r /tmp/tcpdump.cap 
[root@June ~]# tcpdump -i enp2s0 -A -w /tmp/tcpdump.cap

3.WireShark协议分析工具(也可以抓包,但是一般用于分析抓到的包)
[root@June ~]# yum -y install wireshark wireshark-gnome
//把抓到的包传到真机进行分析
[root@Security60 ~]# scp /tmp/ftp.cap 192.168.4.254:/root
[root@June ~]# ls /root/ftp.cap 
/root/ftp.cap


=================================================================================
		         11.Security-day03
=================================================================================
#iptables防火墙

[root@Security60 ~]# systemctl stop firewalld
[root@Security60 ~]# systemctl disable firewalld
[root@Security60 ~]# yum list | grep -i iptables
iptables.x86_64                     1.4.21-18.el7            @anaconda/7.4      
iptables.i686                       1.4.21-18.el7            192.168.4.254_rhel7
iptables-devel.i686                 1.4.21-18.el7            192.168.4.254_rhel7
iptables-devel.x86_64               1.4.21-18.el7            192.168.4.254_rhel7
iptables-services.x86_64            1.4.21-18.el7            192.168.4.254_rhel7
[root@Security60 ~]# rpm -qa | grep -i iptables		//仅有提供命令的包
iptables-1.4.21-18.el7.x86_64
[root@Security60 ~]# yum -y install iptables-services.x86_64 //安装提供服务的包
[root@Security60 ~]# service iptables status		//查看服务状态
[root@Security60 ~]# service iptables start		//启动服务
[root@Security60 ~]# chkconfig iptables on		//设置服务开机自启

iptables基本用法
iptables [-t 表名] 管理选项 [链名] [条件] [-j 处理动作]

#######################################
可以不指定表，默认为filter表
可以不指定链，默认为对应表的所有链
如果没有匹配的规则，则使用防火墙默认规则
选项/链名/处理动作用大写字母，其余都小写
#######################################

<常用管理选项>
--------------------------------------------------------------------------
类别		选项		用途
--------------------------------------------------------------------------
添加规则	-A		在链的末尾追加一条规则
		-I		在链的开头(或指定序号)插入一条规则
--------------------------------------------------------------------------
查看规则	-L		列出所有的规则条目
		-n		以数字形式显示地址，端口等信息
		--line-numbers	查看规则时，显示规则的序号
--------------------------------------------------------------------------
删除规则	-D		删除链内指定序号(或内容)的一条规则
		-F		清空所有的规则
--------------------------------------------------------------------------
默认策略	-P		为指定的链设置默认规则
--------------------------------------------------------------------------

<基本匹配条件>
--------------------------------------------------------------------
类别		选项		用法
--------------------------------------------------------------------
通用匹配	协议匹配	-p 协议名
		地址匹配	-s 源地址 -d 目标地址
		接口匹配	-i 收数据的网卡 -o 发数据的网卡
--------------------------------------------------------------------
隐含匹配	端口匹配	--sport 源端口 --dport 目标端口
		ICMP类型匹配	--icmp-type ICMP类型
--------------------------------------------------------------------
需要取反条件时，用!
--------------------------------------------------------------------

iptables的结构(4张表对应不同的功能)
raw表		状态跟踪表：PREROUTING，OUTPUT
mangle表	包标记表：PREROUTING，POSTROUTING，INPUT，OUTPUT，FORWARD
nat表		地址转换表：PREROUTING，POSTROUTING，OUTPUT，INPUT
filter表	过滤表：INPUT，FORWARD，OUTPUT

5种链(ip包传输的方向)
INPUT		进入防火墙本机ip包
OUTPUT		从防火墙本机出去的ip包	
FORWARD		经过防火墙主机的ip包
POSTROUTING	路由后
PREROUTING	路由前

规则（匹配到达防火墙主机的ip包，存放在链里）
规则链内的匹配顺序是：
顺序比对，匹配即停止（LOG除外）
若无任何匹配，则按该链的默认策略处理

处理动作（ip包到达防火墙后，与规则匹配的处理方式）
ACCEPT	放行
DROP	丢弃
REJECT	拒绝
LOG	记录日志

[root@Security60 ~]# iptables -t filter -L	//查看filter表
[root@Security60 ~]# iptables -L		//不指定表名默认是filter表
[root@Security60 ~]# iptables -nL
[root@Security60 ~]# iptables -nL --line-numbers
[root@Security60 ~]# iptables -F		//清空filter表
[root@Security60 ~]# iptables -t mangle -F	//清空mangle表
[root@Security60 ~]# iptables -t raw -F		//清空raw表
[root@Security60 ~]# iptables -t nat -F		//清空nat表
[root@Security60 ~]# service iptables save	//保存配置

只允许真机连接60的ssh服务，其它主机不可以连接
[root@Security60 ~]# iptables -t filter -A INPUT -p tcp -s 192.168.4.254 --dport 22 -j ACCEPT	//允许4.254访问22端口
[root@Security60 ~]# iptables -t filter -P INPUT DROP	//默认策略设置为DROP
[root@Security60 ~]# service iptables save		//保存配置

让所有主机可以访问60的网站服务
[root@Security60 ~]# iptables -t filter -A INPUT -p tcp --dport 80 -j ACCEPT 
[root@Security60 ~]# service iptables save

让所有主机可以ping通60
[root@Security60 ~]# iptables -t filter -A INPUT -p icmp -j ACCEPT 
[root@Security60 ~]# service iptables save

拒绝62主机ping主机60
[root@Security60 ~]# iptables -t filter -A INPUT -p icmp -s 192.168.4.62 
-j REJECT 
[root@Security60 ~]# iptables -t filter -nL INPUT      //由于顺序匹配，还是可ping通
ACCEPT     tcp  --  192.168.4.254        0.0.0.0/0            tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80
ACCEPT     icmp --  0.0.0.0/0        0.0.0.0/0           
REJECT     icmp --  192.168.4.62     0.0.0.0/0  reject-with icmp-port-unreachable
[root@Security60 ~]# iptables -t filter -D INPUT 4	//删除第四条
[root@Security60 ~]# iptables -t filter -I INPUT 3 -p icmp -s 192.168.4.62 
-j REJECT 						//写在第三条前
[root@Security60 ~]# iptables -t filter -I INPUT 4 -p icmp -s 192.168.4.61 
-j DROP					//让61也ping不通且处理方式是DROP

60主机可以ping其它主机，其它主机ping不了60主机
[root@Security60 ~]# iptables -t filter -D INPUT 5
[root@Security60 ~]# iptables -t filter -D INPUT 4
[root@Security60 ~]# iptables -t filter -D INPUT 3
[root@Security60 ~]# iptables -t filter -A INPUT -p icmp --help	//查看帮助
[root@Security60 ~]# iptables -t filter -A INPUT -p icmp --icmp-type echo-reply 
-j ACCEPT 			//允许pong(ping操作回包)
[root@Security60 ~]# service iptables save

常见扩展匹配
-----------------------------------------------------------------------------		选项		用法
-----------------------------------------------------------------------------
MAC地址匹配	-m mac --mac-source MAC地址
-----------------------------------------------------------------------------
多端口匹配	-m multiport --sports 源端口列表(不连续用,间隔;连续的用:间隔)
		-m multiport --dports 目标端口列表(不连续用,间隔;连续的用:间隔)
-----------------------------------------------------------------------------
IP范围匹配	-m iprange --src-range 起始IP-结束IP
		-m iprange --dst-range 起始IP-结束IP
-----------------------------------------------------------------------------
//还原设置
[root@Security60 ~]# iptables -t filter -P INPUT ACCEPT	
[root@Security60 ~]# iptables -t filter -F
		
[root@Security60 ~]# arp -n	//查看ping过本机的主机(可以看mac地址)
[root@Security60 ~]# iptables -t filter -A INPUT -p icmp -m mac --mac-source 52:54:00:e0:73:13 -j DROP		//封禁mac地址
[root@Security60 ~]# service iptables save

[root@Security60 ~]# iptables -t filter -A INPUT -p tcp -m multiport --dports 3306,80 -j DROP			//封禁多个端口
[root@Security60 ~]# service iptables save

[root@Security60 ~]# iptables -t filter -A INPUT -p icmp -m iprange --src-range 192.168.4.61-192.168.4.63 -j DROP	//封禁IP范围
[root@Security60 ~]# service iptables save


#网络型防火墙
		    ----------------
		   |host52:eth1:2.52|
host51:eth1:2.51-->|		    |-->host53:eth0:4.53
		   |host52:eth0:4.52|
                    ----------------
主机61指定网关
[root@Security61 ~]# systemctl stop NetworkManager
[root@Security61 ~]# systemctl disable NetworkManager
[root@Security61 ~]# route add default gw 192.168.2.62
主机63指定网关
[root@Security63 ~]# systemctl stop NetworkManager
[root@Security63 ~]# systemctl disable NetworkManager
[root@Security63 ~]# route add default gw 192.168.4.62
主机63配置httpd和mariadb服务
[root@Security63 ~]# yum -y install httpd
[root@Security63 ~]# echo test > /var/www/html/test.html
[root@Security63 ~]# systemctl restart httpd
[root@Security63 ~]# yum -y install mariadb mariadb-server
[root@Security63 ~]# systemctl restart mariadb
[root@Security63 ~]# mysql -uroot
MariaDB [(none)]> grant all  on *.* to admin@"%" identified by "123qqq...A"
主机62开启路由转发功能
[root@Security62 ~]# echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf 
[root@Security62 ~]# sysctl -p
主机62停止firewalld并安装iptables服务
[root@Security62 ~]# systemctl stop firewalld
[root@Security62 ~]# systemctl disable firewalld
[root@Security62 ~]# yum -y install iptables-services
清空默认策略并保存
[root@Security62 ~]# iptables -t filter -F
[root@Security62 ~]# iptables -t nat -F
[root@Security62 ~]# iptables -t raw -F
[root@Security62 ~]# iptables -t mangle -F
[root@Security62 ~]# service iptables save
[root@Security62 ~]# service iptables restart
修改FORWARD默认策略
[root@Security62 ~]# iptables -t filter -nL FORWARD 
Chain FORWARD (policy ACCEPT)		//FORWARD默认是ACCEPT
[root@Security62 ~]# iptables -t filter -P FORWARD DROP
[root@Security62 ~]# iptables -t filter -nL FORWARD 
Chain FORWARD (policy DROP)		//修改成DROP
添加允许网站服务80的策略
[root@Security62 ~]# iptables -t filter -A FORWARD -p tcp --dport 80 -j ACCEPT 
[root@Security62 ~]# iptables -t filter -A FORWARD -p tcp --sport 80 -j ACCEPT 
[root@Security62 ~]# iptables -t filter -nL FORWARD
Chain FORWARD (policy DROP)
target     prot opt source               destination         
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp spt:80
[root@Security62 ~]# service iptables save
添加允许ping策略
[root@Security62 ~]# iptables -t filter -A FORWARD -p icmp  -j ACCEPT
[root@Security62 ~]# service iptables save
添加允许数据库服务3306的策略
[root@Security62 ~]# iptables -t filter -A FORWARD -p tcp --dport 3306 -j ACCEPT
[root@Security62 ~]# iptables -t filter -A FORWARD -p tcp --sport 3306 -j ACCEPT
[root@Security62 ~]# service iptables save


#配置SNAT实现共享上网
		          ________私网4.63
	                 |		  
		         |
公网:2.61---2.62防火墙4.62---------私网4.64
		         |
		         |
		          --------私网4.66
清空网络防火墙的配置
[root@Security61 ~]# route -n
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.2.62    0.0.0.0         UG    0      0        0 eth1
[root@Security61 ~]# route del default gw 192.168.2.62
[root@Security62 ~]# iptables -t filter -F
[root@Security62 ~]# iptables -t filter -P FORWARD ACCEPT
[root@Security62 ~]# service iptables save
[root@Security62 ~]# sysctl -p		//主机62路由转发功能保留打开状态
net.ipv4.ip_forward = 1
[root@Security63 ~]# route -n		//主机63的网关也保留
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.4.62    0.0.0.0         UG    0      0        0 eth0

在主机61上部署网站服务并编写测试页面
[root@Security61 ~]# yum -y install httpd
[root@Security61 ~]# systemctl restart httpd
[root@Security61 ~]# echo test > /var/www/html/test.html
[root@Security62 ~]# iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -p tcp --dport 80 -j SNAT --to-source 192.168.2.62
[root@Security62 ~]# iptables -t nat -nL POSTROUTING 
Chain POSTROUTING (policy ACCEPT)
target     prot opt source             destination         
SNAT       tcp  --  192.168.4.0/24     0.0.0.0/0     tcp dpt:80 to:192.168.2.62
//不指定目标地址则为缺省0.0.0.0/0可访问公网任意ip地址
在主机64和66上也指定网关为4.62
[root@Security64 ~]# route add default gw 192.168.4.62
[root@Security66 ~]# route add default gw 192.168.4.62


=================================================================================
		         11.Security-day04
=================================================================================
#系统审计
//概念：
基于事先配置的规则生成日志，记录可能发生在系统上的事件
(不会为系统提供额外的安全保护,仅记录)

//审计记录的日志内容：
日期与事件，事件结果
触发事件的用户

红帽系统内置审计软件audit
[root@Security61 ~]# rpm -q audit 
audit-2.7.6-3.el7.x86_64
[root@Security61 ~]# systemctl status auditd	//服务默认开启
[root@Security61 ~]# systemctl stop auditd	//该服务无法停止
Failed to stop auditd.service: Operation refused, unit auditd.service may be requested by dependency only (it is configured to refuse manual start/stop).
See system logs and 'systemctl status auditd.service' for details.
[root@Security61 ~]# grep  "log_file" /etc/audit/auditd.conf	//从配置文件种查找
log_file = /var/log/audit/audit.log		//日志文件位置
max_log_file = 8
max_log_file_action = ROTATE
[root@Security61 ~]# auditctl -s		//查看audit状态
enabled 1					//1代表服务正在运行
failure 1
pid 637
rate_limit 0
backlog_limit 8192
lost 0
backlog 0
loginuid_immutable 0 unlocked
[root@Security61 ~]# auditctl -l		//查看审计规则
[root@Security61 ~]# auditctl -D		//删除所有规则

临时定义规则
auditctl -w 文档路径 -p 权限 -k 规则名称
文档路径：需要审计的文件或目录
权限：r,w,x,a(文件或目录的所有者所属组等属性发生变化)
规则名称：可选项，方便识别哪些规则生成特定的日志项

[root@Security61 ~]# auditctl -w /etc/passwd -p rwa -k passwd_change
[root@Security61 ~]# auditctl -l
-w /etc/passwd -p rwa -k passwd_change
[root@Security61 ~]# auditctl -w /etc/ -p rwx -k mon_etc
[root@Security61 ~]# auditctl -l
-w /etc/passwd -p rwa -k passwd_change
-w /etc -p rwx -k mon_etc
[root@Security61 ~]# tail -f /var/log/audit/audit.log 	//动态监控日志文件
//新开终端，对以上文件和目录操作，日志会出现变化

[root@Security61 ~]# which rm
/usr/bin/rm
[root@Security61 ~]# auditctl -w /usr/bin/rm -p x -k mon_rm
[root@Security61 ~]# auditctl -l
-w /usr/bin/rm -p x -k mon_rm

永久定义规则
[root@Security61 ~]# auditctl -l	//查询出来复制
-w /etc/passwd -p rwa -k passwd_change
-w /etc -p rwx -k mon_etc
-w /usr/bin/rm -p x -k mon_rm
[root@Security61 ~]# vim /etc/audit/rules.d/audit.rules 
//粘贴到规则文件的最后

规则文件参考模板
[root@Security61 ~]# ls /usr/share/doc/audit-版本号(可以tab出来)/rules/

查看audit日志
[root@Security61 ~]# grep -i mon_etc /var/log/audit/audit.log | tail -1
type=SYSCALL msg=audit(1541660699.124:1122): arch=c000003e syscall=2 success=yes exit=3 a0=7ff8aa111c67 a1=80000 a2=1 a3=7ff8aa3184f8 items=1 ppid=5010 pid=5664 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=40 comm="grep" exe="/usr/bin/grep" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="mon_etc"
字段含义：
type为类型
msg为(time_stamp:ID),事件是date +%s
arch=c000003e,代表x86_64(16进制)
success=yes/no，事件是否成功
a0-a3是程序调用时前4个参数，16进制编码
ppid父进程id，如bash,pid进程id，如cat命令
auid是审核用户的id,su -test,依然可以追踪su前的账户
uid,gid用户与组
tty从哪个终端执行的命令
comm="cat"用户在命令行执行的指令
exr="/bin/cat"实际程序的路径
key="mon_etc"管理员定义的策略关键字
type=CWD用来记录当前工作目录
-cmd="/home/username"
type=PATH
ouid(owner's user id)对象所有者id
guid(owner's group id)对象所属组id

系统提供的ausearch命令可以方便搜索特定日志
//默认该程序搜索/var/log/audit/audit.log

[root@Security61 ~]# ausearch -k mon_etc -i | tail -1	
//-k指定规则名称，-i按易读单位显示
type=SYSCALL msg=audit(11/08/2018 15:08:08.987:1148) : arch=x86_64 syscall=open success=yes exit=4 a0=0x7feac2af1427 a1=O_RDONLY|O_CLOEXEC a2=0x1b6 a3=0x24 items=1 ppid=5010 pid=5699 auid=root uid=root gid=root euid=root suid=root fsuid=root egid=root sgid=root fsgid=root tty=pts0 ses=40 comm=ausearch exe=/usr/sbin/ausearch subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=mon_etc

#服务安全
1.Nginx安全
停止iptables,httpd服务,安装nginx
[root@Security60 ~]# systemctl stop httpd
[root@Security60 ~]# systemctl disable httpd
Removed symlink /etc/systemd/system/multi-user.target.wants/httpd.service.
[root@Security60 ~]# service iptables stop
Redirecting to /bin/systemctl stop iptables.service
[root@Security60 ~]# yum -y install gcc zlib-devel pcre-devel
[root@Security60 nginx-1.12.2]# ./configure --prefix=/usr/local/nginx
[root@Security60 nginx-1.12.2]# /usr/local/nginx/sbin/nginx 
[root@Security60 nginx-1.12.2]# ss -nultp | grep :80
[root@Security60 nginx-1.12.2]# vim /usr/local/nginx/conf/nginx.conf
    server {
        listen       80;
        server_name  localhost;
        autoindex on;		//在server下添加这一行
[root@Security60 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@Security60 ~]# mkdir /usr/local/nginx/html/test
[root@Security60 ~]# touch /usr/local/nginx/html/test/{a,b,c}.txt
[root@June ~]# firefox 192.168.4.60/test	
//当网页目录下没有index.html索引文件时，则会自动把该文件夹所有文件列出来
Index of /test/
../
a.txt                              08-Nov-2018 07:50                   0
b.txt                              08-Nov-2018 07:50                   0
c.txt                              08-Nov-2018 07:50                   0
[root@Security60 ~]# echo index > /usr/local/nginx/html/test/index.html
//必须创建index.html索引文件，才安全
//也可以在安装的时候把这个模块去掉
[root@Security60 nginx-1.12.2]# ./configure --prefix=/usr/local/nginx \
--with-http_autoindex_module \
//同时也去掉ssi模块
--with-http_ssi_module
//这个模块为处理服务器端包含(SSI)的输入提供一个过滤器，目前所支持的SSI命令并不完善

修改nginx版本信息
[root@Security60 ~]# curl -I 192.168.4.60
HTTP/1.1 200 OK
Server: nginx/1.12.2	//可以查看到版本信息
[root@Security60 ~]# vim /usr/local/nginx/conf/nginx.conf
http {
server_tokens off;	//隐藏软件版本
[root@Security60 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@Security60 ~]# curl -I 192.168.4.60
HTTP/1.1 200 OK
Server: nginx		//成功隐藏软件版本

修改软件名信息
[root@Security60 http]# vim nginx-1.12.2/src/http/ngx_http_header_filter_module.c
//修改源码包里的文件
static u_char ngx_http_server_string[] = "Server: nginx" CRLF;
→→→
static u_char ngx_http_server_string[] = "Server: 自定义软件名信息" CRLF;

static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;
→→→
static u_char ngx_http_server_full_string[] = "Server: 自定义软件名信息"  CRLF;

static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;
→→→
static u_char ngx_http_server_build_string[] = "Server: 自定义软件名信息"  CRLF;
[root@Security60 nginx-1.12.2]# cd /root/lnmp_soft/nginx-1.12.2/
[root@Security60 nginx-1.12.2]# ./configure --prefix=/usr/local/nginx
[root@Security60 nginx-1.12.2]# make && make install
[root@Security60 nginx-1.12.2]# killall -9 nginx
[root@Security60 nginx-1.12.2]# /usr/local/nginx/sbin/nginx
[root@Security60 ~]# curl -I 192.168.4.60
HTTP/1.1 200 OK
Server: 自定义软件名			//软件名信息修改成自定义的软件名

拒绝非法请求
//HTTP定义了很多方法,实际应用中一般仅需要get和post
-------------------------------------------------------------------------
请求方法	功能描述
-------------------------------------------------------------------------
GET		请求指定的页面信息,并返回实体主体
HEAD		类似于get请求,只不过返回的响应中没有具体的内容,用于获取报头
POST		向指定资源提交数据进行处理请求(例如提交表单或上传文件)
DELETE		请求服务器删除指定的页面
PUT		向服务器特定位置上传资料
...		其它
-------------------------------------------------------------------------
//禁用其它方法，仅允许(GET|POST)
[root@Security60 ~]# vim /usr/local/nginx/conf/nginx.conf
    server {
        listen       80;
        server_name  localhost;
        autoindex on;
        #charset koi8-r;
	//在server里写以下配置项
        if ($request_method !~ ^(GET|POST)$ ){		//匹配非GET或POST
                        return 500;			//匹配成功则返回500
                }
[root@Security60 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@Security60 ~]# curl -X GET 192.168.4.60/test/index.html
index
[root@Security60 ~]# curl -X HEAD 192.168.4.60/test/index.html
curl: (52) Empty reply from server	//非法请求无法获取页面

限制并发
[root@Security60 ~]# ab -n 100 http://192.168.4.60/	//模拟100次连接请求
[root@Security60 ~]# ab -n 1000000 http://192.168.4.60/	//模拟100万次,访问速度变慢
[root@Security60 ~]# vim /usr/local/nginx/conf/nginx.conf
http {		//在http里加入以下一行配置
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
//在ngingx服务开启的时候在内存里获取一块区域
//空间10M(1M可以存储8000个ip的信息),名称叫one
//用于存储客户端发起访问请求的ip
//当同一个ip发起多次请求则报错
    server {	//在server加入这一行配置
        listen       80;
        server_name  localhost;
	limit_req zone=one burst=5;
//同一个ip每秒只接受1个请求，多余的4个放到漏斗(one)里
//漏斗(one)中超过5个则报错

在真机上发起10次连接共10次请求
[root@June ~]# ab -c 10 -n 10 http://192.168.4.60/
Failed requests:        4		//丢掉了4次请求

防止buffer溢出
防止客户端请求数据溢出
有效降低机器Dos攻击风险
http{
	client_body_buffer_size 1k;
	client_header_buffer_size 1k;
	client_max_body_size 16k;
	large_client_header_buffer 4 4k;
......

}

2.数据库mariadb安全
[root@Security60 ~]# yum -y install mariadb mariadb-server
[root@Security60 ~]# systemctl restart mariadb
[root@Security60 ~]# mysql_secure_installation		//初始化安全脚本
Remove anonymous users? [Y/n] Y				//删除匿名登录
Disallow root login remotely? [Y/n] Y 			//禁止root远程登录
Remove test database and access to it? [Y/n] Y		//删除测试数据库
Reload privilege tables now? [Y/n] Y			//刷新权限

命令行修改密码
[root@Security60 ~]# mysqladmin -uroot -predhat password 'mysql'
使用账户登录数据库修改密码
MariaDB[(none)]>set password for root@'localhost'=password('redhat')

历史命令明文密码
binlog日志里有明文密码(5.6版本后修复了)
[root@Security60 ~]# cat ~/.bash_history 
[root@Security60 ~]# cat ~/.mysql_history 
解决方法：
管理好自己的历史，不使用明文密码登录，选择合适的版本
日志，行为审计
防火墙从TCP层设置ACL(禁止外网接触数据库)

数据库默认明文传输
[root@June ~]# tcpdump -i eth0 src or dst port 3306
//使用tcpdump抓包就能抓到数据库上的操作
解决方法：
使用SSL或SSH加密数据传输

3.Tomcat安全
//安装tomcat并编写测试页面
[root@Security60 ~]# tar -xf apache-tomcat-8.0.30.tar.gz 
[root@Security60 ~]# mv apache-tomcat-8.0.30 /usr/local/tomcat
[root@Security60 ~]# ls /usr/local/tomcat/
[root@Security60 ~]# echo test > /usr/local/tomcat/webapps/ROOT/test.html
[root@Security60 ~]# /usr/local/tomcat/bin/startup.sh 
[root@Security60 ~]# ss -nultp | grep java
[root@Security60 ~]# curl 192.168.4.60:8080/test.html
//存在的网页或不存在的网页都会显示版本信息
[root@Security60 ~]# curl -I 192.168.4.60:8080
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
[root@Security60 ~]# curl -I 192.168.4.60:8080/xx
HTTP/1.1 404 Not Found
Server: Apache-Coyote/1.1


修改tomcat主配置文件，隐藏版本信息
[root@Security60 ~]# yum -y install java-1.8.0-openjdk-devel
[root@Security60 ~]# cd /usr/local/tomcat/lib/
[root@Security60 lib]# jar -xf catalina.jar 
//修改以下文件的版本信息
[root@Security60 lib]# vim org/apache/catalina/util/ServerInfo.properties 
server.info=Apache Tomcat/8.0.30
server.number=8.0.30.0
server.built=Dec 1 2015 22:30:46 UTC
→→→
server.info=Nginx qwer/9.1.3
server.number=9.1.3.0
server.built=Dec 1 2015 22:30:46 UTC
[root@Security60 ~]# /usr/local/tomcat/bin/shutdown.sh 
[root@Security60 ~]# /usr/local/tomcat/bin/startup.sh 
//修改软件名信息
[root@Security60 ~]# vim /usr/local/tomcat/conf/server.xml 
    <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />
→→→
    <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" server="IIS"/>	//自定义一个软件名

降权启动
[root@Security60 ~]# useradd tomcat
[root@Security60 ~]# chown -R tomcat:tomcat /usr/local/tomcat/
[root@Security60 ~]# su -c /usr/local/tomcat/bin/startup.sh tomcat
//开机启动
[root@Security60 ~]# chmod +x /etc/rc.local 
[root@Security60 ~]# chmod +x /etc/rc.d/rc.local 
[root@Security60 ~]# echo "su -c /usr/local/tomcat/bin/startup.sh tomcat" >> /etc/rc.local 

//删除默认的测试页面以及默认网页目录
//自己定义网页目录名
[root@Security60 ~]# rm -rf /usr/local/tomcat/webapps/*	

#Linux安全打补丁
[root@Security60 ~]# mkdir /demo
[root@Security60 ~]# cd /demo/
[root@Security60 demo]# vim game.sh
#!/bin/bash
echo "hello girl"
[root@Security60 demo]# vim game_1.sh
#!/bin/bash
echo "hello beautiful girl"
echo "I love you!"
##########################################################
diff工具
-u	输出统一内容的头部信息(打补丁使用)
-r	递归对比目录中的所有资源(可以对比目录)
-a	所有文件视为文本(包括二进制程序)
-N	无文件视为空文件(空文件才可以与要更新的文件对比)
##########################################################
[root@Security60 demo]# diff -u game.sh game_1.sh 	//-u代表生成补丁文件
--- game.sh	2018-11-09 11:17:00.683888518 +0800
+++ game_1.sh	2018-11-09 11:19:11.312888518 +0800
@@ -1,2 +1,3 @@
 #!/bin/bash
-echo "hello girl"
+echo "hello beautiful girl"
+echo "I love you!"
[root@Security60 demo]# diff -u game.sh game_1.sh > game.patch	//生成补丁文件
[root@Security60 demo]# yum -y install patch
[root@Security60 demo]# patch -p0 < game.patch 	//打补丁,-p0代表补丁文件在当前目录
patching file game.sh
[root@Security60 demo]# cat game.sh 
#!/bin/bash
echo "hello beautiful girl"
echo "I love you!"
[root@Security60 demo]# patch -RE < game.patch 		//版本还原回滚
patching file game.sh
[root@Security60 demo]# cat game.sh 
#!/bin/bash
echo "hello girl"

[root@Security60 demo]# mkdir s1
[root@Security60 demo]# mkdir s2
[root@Security60 demo]# vim s1/game.sh
#!/bin/bash
echo "hello world"
[root@Security60 demo]# vim s2/game.sh
#!/bin/bash
echo "hello world"
echo "haha"
[root@Security60 demo]# which find
/usr/bin/find					//二进制文件
[root@Security60 demo]# cp /usr/bin/find ./s1/
[root@Security60 demo]# cp /usr/bin/find ./s2/
[root@Security60 demo]# echo 1 >> s2/find	//给s2里的二进制文件追加一个1
[root@Security60 demo]# echo "FFFF" > s2/test.txt      //在s2里新建一个s1没有的文件
[root@Security60 demo]# yum -y install tree	//按树型结构显示目录列表的软件
[root@Security60 demo]# tree /demo
/demo
  ├── s1
  │     ├── find
  │     └── game.sh
  └── s2
        ├── find
        ├── game.sh
        └── test.txt
[root@Security60 demo]# diff -Nuar s1 s2 > bd.patch
[root@Security60 demo]# ls
bd.patch  s1  s2
[root@Security60 demo]# cd s1		//打补丁需要进到目录里打
[root@Security60 s1]# patch -p1 < ../bd.patch 	//-p1代表补丁文件在上1级目录
patching file find
patching file game.sh
patching file test.txt
[root@Security60 s1]# patch -RE -p1 < ../bd.patch 	//版本还原回滚
patching file find
patching file game.sh
patching file test.txt


=================================================================================
		         11.Security-day05
=================================================================================

#部署Zabbix需要的LNMP环境
[root@monitor5 ~]# yum -y install gcc pcre-devel zlib-devel
[root@monitor5 lnmp_soft]# tar -xf nginx-1.12.2.tar.gz 
[root@monitor5 lnmp_soft]# cd nginx-1.12.2/
[root@monitor5 nginx-1.12.2]# ./configure --prefix=/usr/local/nginx
[root@monitor5 nginx-1.12.2]# make && make install
[root@monitor5 ~]# /usr/local/nginx/sbin/nginx 
[root@monitor5 ~]# ss -nultp | grep :80
[root@monitor5 ~]# echo test > /usr/local/nginx/html/test.html
[root@monitor5 ~]# curl localhost/test.html
[root@monitor5 ~]# yum -y install mariadb mariadb-server
[root@monitor5 ~]# systemctl restart mariadb
[root@monitor5 ~]# systemctl enable mariadb
[root@monitor5 ~]# yum -y install mariadb-devel		//zabbix需要的依赖包
[root@monitor5 ~]# mysql_secure_installation 		//对mariadb安全初始化
[root@monitor5 ~]# yum -y install php php-mysql.x86_64  
[root@monitor5 lnmp_soft]# ls php-fpm-5.4.16-42.el7.x86_64.rpm 
[root@monitor5 lnmp_soft]# yum -y install php-fpm-5.4.16-42.el7.x86_64.rpm
[root@monitor5 lnmp_soft]# systemctl restart php-fpm.service
[root@monitor5 lnmp_soft]# systemctl enable php-fpm.service
[root@monitor5 lnmp_soft]# ss -nultp | grep :9000
[root@monitor5 ~]# vim /usr/local/nginx/conf/nginx.conf
http{
        fastcgi_buffers 8 16k;		//缓存php生成的页面内容,8个16k
        fastcgi_buffer_size 32k;	//缓存php生产的头部信息
        fastcgi_connect_timeout 300;	//连接php的超时时间
        fastcgi_send_timeout 300;	//发生请求的超时时间
        fastcgi_read_timeout 300;	//读取请求的超时时间

        location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            include        fastcgi.conf;
        }
[root@monitor5 ~]# vim /usr/local/nginx/html/test.php
<?php
echo "hello"
?>
[root@monitor5 ~]# /usr/local/nginx/sbin/nginx -s reload
[root@monitor5 ~]# curl 192.168.4.5/test.php
//创建库，用于存储zabbix监控服务的配置信息和监控数据
[root@monitor5 ~]# mysql -uroot -p123456
MariaDB [(none)]> create database zabbixdb;
MariaDB [(none)]> grant all on zabbixdb.* to zbixadmin@"localhost" identified by "123456";

#部署zabbix服务
1.安装源码zabbix软件
[root@monitor5 ~]# useradd zabbix
[root@monitor5 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@monitor5 ~]# cd zabbix-3.4.4/
[root@monitor5 lnmp_soft]# yum -y install libevent-devel-2.0.21-4.el7.x86_64.rpm 
[root@monitor5 zabbix-3.4.4]# yum -y install net-snmp-devel curl-devel
[root@monitor5 zabbix-3.4.4]# ./configure --prefix=/usr/local/zabbix \
> --enable-server \		//监控服务模块
> --with-mysql \		//mysql模块
> --with-net-snmp \		//net-snmp协议模块
> --with-libcurl \		//libcurl模块
> --enable-agent \		//监控zabbix服务器自身的模块
> --enable-proxy		//提供代理服务的模块
***********************************************************
*            Now run 'make install'                       *
*                                                         *
*            Thank you for using Zabbix!                  *
*              <http://www.zabbix.com>                    *
***********************************************************
[root@monitor5 zabbix-3.4.4]# make install
[root@monitor5 zabbix-3.4.4]# ls /usr/local/zabbix/
bin  etc  lib  sbin  share
[root@monitor5 zabbix-3.4.4]# cp -r frontends/php/ /usr/local/nginx/html/zabbix
//把zabbix的网页文件复制到nginx网页文件目录
[root@monitor5 zabbix-3.4.4]# cd database/mysql/
[root@monitor5 mysql]# mysql -uzbixadmin -p123456 zabbixdb < schema.sql 
[root@monitor5 mysql]# mysql -uzbixadmin -p123456 zabbixdb < images.sql 
[root@monitor5 mysql]# mysql -uzbixadmin -p123456 zabbixdb < data.sql 
[root@monitor5 mysql]# mysql -uzbixadmin -p123456 zabbixdb 
MariaDB [zabbixdb]> show tables;
修改php程序的运行参数并安装
[root@monitor5 ~]# vim /etc/php.ini 
max_execution_time = 30	-->max_execution_time = 300
max_input_time = 60	-->max_input_time = 300
post_max_size = 8M	-->post_max_size = 16M
;date.timezone =	-->date.timezone = Asia/Shanghai
[root@monitor5 ~]# yum -y install php-gd php-xml php-ldap
[root@monitor5 ~]# rpm -ivh --nodeps lnmp_soft/php-bcmath-5.4.16-42.el7.x86_64.rpm lnmp_soft/php-mbstring-5.4.16-42.el7.x86_64.rpm
[root@monitor5 ~]# systemctl restart php-fpm

2.对zabbix服务做初始化配置，并登录管理页面
[root@June ~]# firefox 192.168.4.5/zabbix/index.php
<Configure DB connection>
Database type	MySQL
Database host	localhost
Database port	0		//0 - use default port
Database name	zabbixdb
User		zbixadmin
Password	123456
<Zabbix server details>
Host	192.16.8.4.5
Port	10051
Name	monitor_server
//Finish会报错
Unable to create the configuration file.
Alternatively, you can install it manually:
Download the configuration file
Save it as "/usr/local/nginx/html/zabbix/conf/zabbix.conf.php"
//给该目录加写权限
[root@monitor5 ~]# chmod o+w /usr/local/nginx/html/zabbix/conf/
//再次Finish成功配置
Congratulations! You have successfully installed Zabbix frontend.
Configuration file "/usr/local/nginx/html/zabbix/conf/zabbix.conf.php" created.
//再点击Finish完成配置,跳转到登录界面
Username:Admin		//默认管理员账户
Password:Zabbix		//默认密码
//登录进去之后，点击右上角的图表可修改语言及密码
语言且换成中文
密码修改成123456

3.启动zabbix服务
[root@monitor5 ~]# vim /usr/local/zabbix/etc/zabbix_server.conf
LogFile=/tmp/zabbix_server.log
# DBHost=localhost			//指定数据库服务器,不指定默认是本地
DBName=zabbix	-->DBName=zabbixdb	//指定库
DBUser=zabbix	-->DBUser=zbixadmin	//指定授权的数据库用户名
# DBPassword=	-->DBPassword=123456	//指定授权的数据库用户密码
[root@monitor5 ~]# ls zabbix-3.4.4/misc/init.d/		//不同linux系统版本
aix  debian  fedora  freebsd  gentoo  README  suse  tru64  ubuntu
[root@monitor5 ~]# ls zabbix-3.4.4/misc/init.d/fedora/
core  		//单核服务器
core5		//多核服务器
[root@monitor5 ~]# ls zabbix-3.4.4/misc/init.d/fedora/core	//虚拟机是单核
zabbix_agentd  	//被监控服务器的服务脚本
zabbix_server	//监控服务器启动服务脚本
[root@monitor5 ~]# cp -r zabbix-3.4.4/misc/init.d/fedora/core/zabbix_server /etc/init.d/		//复制到/etc/init.d目录
[root@monitor5 ~]# vim /etc/init.d/zabbix_server 
BASEDIR=/usr/local	-->BASEDIR=/usr/local/zabbix
[root@monitor5 ~]# chmod +x /etc/init.d/zabbix_server
[root@monitor5 ~]# /etc/init.d/zabbix_server start	//启动服务
Reloading systemd:                                         [  OK  ]
Starting zabbix_server (via systemctl):                    [  OK  ]
[root@monitor5 ~]# ss -nultp | grep :10051
[root@monitor5 ~]# /etc/init.d/zabbix_server status	//服务状态

4.zabbix基本使用
查看监控服务器正在监控的主机
菜单：配置-->主机		//默认有一个监控本机的监控项
(右上角)创建主机按钮		//创建主机

查看监控服务器支持的监控模板
菜单：配置-->模板

查看检测信息
菜单：监测中-->仪表板
菜单：监测中-->最新数据		//查看监控主机的实时状态

#zabixx基本配置
1.监控本机
在本机运行zabbix_agentd服务
[root@monitor5 ~]# vim /usr/local/zabbix/etc/zabbix_agentd.conf
LogFile=/tmp/zabbix_agentd.log		
//zabbix_agentd日志文件目录
Server=127.0.0.1			
//允许访问agentd服务的ip地址，监控本机则默认不用改
ServerActive=127.0.0.1	-->ServerActive=127.0.0.1:10051
//监控服务器的地址和端口号
# UnsafeUserParameters=0	-->UnsafeUserParameters=1
//设置允许自定义监控命令
# Include=/usr/local/etc/zabbix_agentd.conf.d/*.conf
-->
Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf
//自定义监控命令的配置文件要放在此目录下
[root@monitor5 ~]# cp /root/zabbix-3.4.4/misc/init.d/fedora/core/zabbix_agentd /etc/init.d/	//复制启动agentd服务的脚本到/etc/init.d
[root@monitor5 ~]# chmod +x /etc/init.d/zabbix_agentd 
[root@monitor5 ~]# vim /etc/init.d/zabbix_agentd 
BASEDIR=/usr/local	-->BASEDIR=/usr/local/zabbix
[root@monitor5 ~]# /etc/init.d/zabbix_agentd start
Reloading systemd:                                         [  OK  ]
Starting zabbix_agentd (via systemctl):                    [  OK  ]
[root@monitor5 ~]# ss -nultp | grep :10050
//如果查端口没有启动
[root@monitor5 ~]# /etc/init.d/zabbix_agentd status	//查看服务状态信息报错
[root@monitor5 ~]# /etc/init.d/zabbix_agentd stop	//排完错先停止服务
[root@monitor5 ~]# /etc/init.d/zabbix_agentd start	//再重新启动服务
//或排完错后重启服务
[root@server54 ~]# /etc/init.d/zabbix_agentd start
//登录web页面添加监控本机
添加监控本机(默认监控本机,直接启用即可)
菜单：配置-->主机		
点击状态下的停用-->OK		//然后多刷新几次看到可用性：zbx变成绿色即可

2.监控远端主机
配置远端主机:配置运行zabbix_agentd服务
[root@server54 ~]# useradd zabbix
[root@server54 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@server54 zabbix-3.4.4]# yum -y install gcc pcre-devel
[root@server54 ~]# cd zabbix-3.4.4/
[root@server54 zabbix-3.4.4]# ./configure --prefix=/usr/local/zabbix \
> --enable-agent
[root@server54 zabbix-3.4.4]# yum -y install pcre-devel
[root@server54 zabbix-3.4.4]# make install
[root@server54 zabbix-3.4.4]# ls /usr/local/zabbix/
bin  etc  lib  sbin  share
[root@server54 zabbix-3.4.4]# vim /usr/local/zabbix/etc/zabbix_agentd.conf
Server=127.0.0.1	-->Server=127.0.0.1,192.168.4.5
ServerActive=127.0.0.1	-->ServerActive=192.168.4.5:10051
UnsafeUserParameters=0	-->UnsafeUserParameters=1	
# Include=/usr/local/etc/zabbix_agentd.conf.d/*.conf
-->
Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf
//以上配置项与监控本机基本是一致的,除了指定监控服务器的地址和允许监控的主机
[root@server54 zabbix-3.4.4]# cp /root/zabbix-3.4.4/misc/init.d/fedora/core/zabbix_agentd /etc/init.d/
[root@server54 zabbix-3.4.4]# vim /etc/init.d/zabbix_agentd 
BASEDIR=/usr/local	-->BASEDIR=/usr/local/zabbix
[root@server54 zabbix-3.4.4]# chmod +x /etc/init.d/zabbix_agentd 
[root@server54 zabbix-3.4.4]# /etc/init.d/zabbix_agentd start
[root@server54 zabbix-3.4.4]# ss -nultp | grep :10050

配置监控服务器:添加监控新主机
配置-->主机-->创建主机-->主机名称:host54-->可见的名称:54-->群组:Linux servers-->agent代理程序的接口:IP地址:192.168.4.54

3.自定义监控项
3.1配置被监控端192.168.4.54
允许自定义监控项	//前面已经配置好
[root@server54 zabbix-3.4.4]# vim /usr/local/zabbix/etc/zabbix_agentd.conf
UnsafeUserParameters=0	-->UnsafeUserParameters=1	
# Include=/usr/local/etc/zabbix_agentd.conf.d/*.conf
-->
Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf

定义监控命令
[root@server54 ~]# vim /usr/local/zabbix/etc/zabbix_agentd.conf	//主配置文件有模板
#       Format: UserParameter=<key>,<shell command>
[root@server54 ~]# vim /usr/local/zabbix/etc/zabbix_agentd.conf.d/getusers.conf
UserParameter=get_users,wc -l /etc/passwd | awk '{print $1}'
测试定义的监控命令
[root@server54 ~]# /etc/init.d/zabbix_agentd restart
[root@server54 ~]# /usr/local/zabbix/bin/zabbix_get -s 127.0.0.1 \
> -p 10050 -k get_users

3.2配置监控服务器
测试是否可以调用被检控主机定义的监控命令
[root@monitor5 ~]# /usr/local/zabbix/bin/zabbix_get -s 192.168.4.54 -p 10050 -k get_users
创建监控模板
菜单：配置-->模板-->创建模板-->模版名称:ATMP-->添加
创建应用集
ATMP->应用集-->创建应用集-->名称:usergrp-->添加
创建监控项
监控项-->创建监控项-->名称:monitor_54_users-->键值:get_users-->应用集:usergrp-->添加
创建主机54时调用新创建的模板
菜单：配置-->主机-->host54-->模板-->链接指示器:ATMP-->添加-->更新
查看监控信息
菜单：监视中-->最新数据-->主机群组:Linuxservers-->主机:host54-->应用集:usergrp-->应用


4.监控报警


=================================================================================
		             12.Cloud-day01
=================================================================================

课堂资料
yum -y install git
git clone git://124.193.128.166/nsd1807.git             //下载git目录
git pull                     //更新内容（必须进入git目录才能执行此命令）

[root@room9pc01 cloud]# git clone git://124.193.128.166/nsd1807.git
正克隆到 'nsd1807'...
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
接收对象中: 100% (3/3), done.
[root@room9pc01 cloud]# ls
nsd1807

-----------------------------------------------------------------------------------------------------------------------------------------------------------------
虚拟化概念
1、将x个物理资源虚拟成y个逻辑资源
x可以大于y（但一般不会这么做；不可能将多台计算机虚拟成一台超级计算机；网速跟不上物理资源：内存速率、缓存速率）
2、根据实现程度分为：完全虚拟化、部分虚拟化、硬件辅助虚拟化

+++++++++++++++++++++++++++++++++++++++++++++++++++++++
vSphere : esxi和vcenter组成
vcenter:管理节点；类似目录文件夹；树状结构
安装vcenter：需要sql server
esxi:每个计算节点有若干个虚拟机esxi；基于红帽linux的一个系统
安装esxi客户端：安装光盘输入密码就可以了

[root@room9pc01 nsd1807]# lsmod  //查找内核模块，可以看到kvm
[root@room9pc01 ~]# ps -efww     //ww可以使运行进程的命令显示完全
qemu  ........                   //启动虚拟化的命令

虚拟机的组成
KVM：内核虚拟化模块；linux内核模块；需要cpu支持（cat /proc/cpuinfo 信息里有个flag标签，代表支持那些指令集，其中有个vmx指令集就是代表支持kvm）
QEMU：虚拟化仿真工具；通过 ioctl 与内核kvm 交互完成对硬件的虚拟化支持；系统设备仿真
一台虚拟机：KVM+QEMU；KVM提供底层命令支持，QEMU提供硬件仿真支持

libvirt：是一个对虚拟化管理的借口和工具；虚拟机管理程序；将虚拟机内容翻译成人类的语言
提供virsh，virt-install，virt-manager，virt-view等命令
安装qemu、lxc、vmware驱动就能管理对应的工具

++++++++++++++++++++++++++++++++++++++++++++++++++++++

必备软件（yum安装）
• qemu-kvm
– 为 kvm 提供底层仿真支持
• libvirt-daemon
– libvirtd 守护进程,管理虚拟机
• libvirt-client
– 用户端软件,提供客户端管理命令
• libvirt-daemon-driver-qemu
– libvirtd 连接 qemu 的驱劢
• 可选功能
– virt-install # 系统安装工具
– virt-manager # 图形管理工具
– virt-v2v     # 虚拟机迁移工具
– virt-p2v     # 物理机迁移工具（物理机迁移到虚拟机）
• 虚拟化平台的安装
yum -y install qemu-kvm libvirt-daemon libvirt-client libvirt-daemon-driver-qemu
systemctl start libvirtd         //启动虚拟化程序
##如果要做openstack，还需要安装python-setuptools，因为openstack是用python写的

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

virsh命令工具介绍
• 查看KVM节点(服务器)信息
– virsh nodeinfo
• 列出虚拟机
– virsh list [--all]     //不写--all，显示正在运行的
• 列出虚拟网络
– virsh net-list [--all]
• 查看虚拟机的信息
– virsh dominfo 虚拟机名称
• 运行|重启|关闭虚拟机
– virsh start|reboot|shutdown 虚拟机名称
• 强制关闭虚拟机
– virsh destroy 虚拟机名称
• 将虚拟机设为开机自动运行
– virsh autostart 虚拟机名称
– virsh autostart --disable 虚拟机名称    //取消开机自动运行
• 在虚拟机没有IP的情况下还要连接虚拟机
– virsh console 虚拟机名称
– 按Ctrl+]退出console

+++++++++++++++++++++++++++++++++++++++++++++++++++++

常用镜像盘类型
• 虚拟机的磁盘镜像文件格式
特点\类型     RAW    QCOW2
KVM默认       否        是
I/O效率       高       较高
占用空间       大       小
压缩         不支持    支持
后端盘复用   不支持    支持
快照          不支持    支持
• QCOW2比RAW只是牺牲了很小的I/O效率就做到压缩、后段盘复用、快照；主要技术是COW

COW技术原理
• Copy On Write,写时复制
– 直接映射原始盘的数据内容
– 当原始盘的旧数据有修改时,在修改之前自劢将旧数据存入前端盘
– 对前端盘的修改不回写到原始盘
• 通俗说法：拷贝原始盘时只拷贝一份空文件：写时才把文件内容复制过来；读时先判断本地有没有数据，有就直接给用户，没有就从后端盘读取（本地不保存数据）返回给用户

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

qemu-img命令
• qemu-img 是虚拟机的磁盘管理命令,支持非常多
的磁盘格式,例如raw、qcow2、vdi、vmdk等等
• qemu-img 命令格式
– qemu-img 命令 参数 块文件名称 大小
– 常用的命令有
– create 创建一个磁盘
– convert 转换磁盘格式
– info 查看磁盘信息
– snapshot 管理磁盘快照
• 创建新的镜像盘文件
– qemu-img create -f 格式 磁盘路径 大小
– qemu-img create -f qcow2 disk.img 50G
• 查询镜像盘文件的信息
– qemu-img info 磁盘路径
• -b 使用后端模板文件
– qemu-img create -b disk.img -f qcow2 disk1.img

[root@room9pc01 images]# qemu-img create -b node.qcow2 -f qcow2 openstack.img 50G
[root@room9pc01 images]# qemu-img info openstack.img 
image: openstack.img
file format: qcow2                       //格式
virtual size: 50G (53687091200 bytes)    //虚拟硬盘大小
disk size: 1.5G                          //已使用大小
cluster_size: 65536
backing file: node.qcow2                 //后端盘文件
Format specific information:
    compat: 1.1
    lazy refcounts: false

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

]# LANG=zh_CN.UTF-8 virsh autostart --help         //设置输出中文

]# virsh -c qemu:///system                          //virsh命令的完全版；可扩展如以下命令
]# virsh -c qemu+ssh://176.121.213.84/system       //连接远程主机并进入virsh模式；前提是能ssh登陆上

图形界面管理远程主机
打开虚拟系统管理器
1、文件--->添加连接
2、在主机名里输入IP：176.121.213.84，已生成的URL会变成：qemu+ssh://root@176.121.213.84/system
3、提示需要软件包：实际上是需要免密码登陆（没有密码输入框）

+++++++++++++++++++++++++++++++++++++++++++++++++++++

自定义网络=创建虚拟交换机
虚拟机要上网就要虚拟交换机

创建虚拟交换机
• libvirtd 网络接口
– 原理:调用 dnsmasq 提供 DNS、DHCP 等功能

网络管理
• virsh管理虚拟网络
以 virsh net 开头的命令就是虚拟交换机的命令
只有在 virsh 控制台界面中 virsh 命令才能 tab
– net-list                           查看虚拟网络
– net-define vbr.xml                 创建虚拟网络
– net-undefine vbr                   删除虚拟网络
– net-start vbr                      启动虚拟网络
– net-destroy vbr                    停止虚拟网络
– net-edit vbr                       修改 vbr 网络的配置：定义完网络后只能用这条命令修改；修改配置文件需要重启系统。原则：只改需要改的
– net-autostart vbr                  设置 vbr 虚拟网络开机自启动
– net-autostart --disable vbr        取消 vbr 虚拟网络开机自启动

[root@room9pc01 nsd1807]# cat vbr.xml   //uuid、mac地址 那两行删掉
<network>
  <name>vbr</name>                            //配置文件名称
  <bridge name='vbr' stp='on' delay='0'/>     //ifconfig中的名称
  <domain name='vbr'/>                        //virsh net-list中的名称
  <forward mode="nat"/>                       //设置虚拟机能上网
  <ip address='192.168.1.254' netmask='255.255.255.0'> //虚拟交换机的IP地址、网关
    <dhcp>                                     //自动配置虚拟机IP地址
      <range start="192.168.1.100" end="192.168.1.200"/>
    </dhcp>
  </ip>
</network>

[root@room9pc01 nsd1807]# cp vbr.xml /etc/libvirt/qemu/networks/
[root@room9pc01 nsd1807]# cd /etc/libvirt/qemu/networks/
[root@room9pc01 networks]# ls
autostart    private1.xml  public1.xml  rhce.xml
default.xml  private2.xml  public2.xml  vbr.xml

[root@room9pc01 networks]# virsh net-define /etc/libvirt/qemu/networks/vbr.xml           //定义网络，系统自动分配uuid和mac地址

[root@room9pc01 networks]# virsh net-start vbr
[root@room9pc01 networks]# virsh net-autostart vbr

[root@room9pc01 networks]# ifconfig vbr
vbr: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 192.168.1.254  netmask 255.255.255.0  broadcast 192.168.1.255
        ether 52:54:00:93:e8:95  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

虚拟机文件：xml文件和磁盘文件
导出虚拟机
• xml 配置文件
– 定义了一个虚拟机的名称、CPU、内存、虚拟磁盘、网卡等各种参数设置
– 默认位于/etc/libvirt/qemu/虚拟机名.xml
• 导出 xml 配置文件
– 查看:virsh dumpxml 虚拟机名
– 备份:virsh dumpxml 虚拟机名 > 虚拟机名.xml
编辑虚拟机设置
• 对虚拟机的配置进行调整
– 编辑:virsh edit 虚拟机名
– 若修改name、memory、disk、network,可自动保存为新虚拟机配置
[root@kvmsvr ~]# virsh edit rhel-207
<domain type='kvm'>
<name>rhel-207</name>
<uuid>76d5dc2c-5eef-4e30-8b6c-e58851814f84</uuid>
<disk type='file' device='disk'>
<source file='/var/lib/libvirt/images/rhel7.2.qcow2'/>
.. ..
<interface type='network'>
<mac address='52:54:00:91:52:e4'/>

[root@room9pc01 nsd1807]# cat node.xml  //虚拟机模板
<domain type='kvm'>                         //类型
  <name>node</name>                         //virsh list、virt-manager中的名称
  <memory unit='KB'>2097152</memory>        //限制虚拟主机最大内存使用量
  <currentMemory unit='KB'>2097152</currentMemory> //限制虚拟主机当前内存使用量
  <vcpu placement='static'>2</vcpu>          //cpu数量
  <os>                                       //系统参数
    <type arch='x86_64' machine='pc'>hvm</type>    //64位系统
    <boot dev='hd'/>                               //启动从硬盘引导
    <bootmenu enable='yes'/>                       //打开引导菜单
    <bios useserial='yes'/>                        //打开用户连接
  </os>
  <features>                 //电源管理，永不断电
    <acpi/>
    <apic/>
  </features>
  <cpu mode='host-passthrough'>      //cpu指令集
  </cpu>
  <clock offset='localtime'/>         //时钟，使用系统时间
  <on_poweroff>destroy</on_poweroff>   //定义关机命令
  <on_reboot>restart</on_reboot>        //定义重启命令
  <on_crash>restart</on_crash>          //定义强制重启命令
  <devices>                              //硬件
    <emulator>/usr/libexec/qemu-kvm</emulator>  //指定硬件仿真程序
    <disk type='file' device='disk'>             //定义主机硬盘
      <driver name='qemu' type='qcow2'/>         //qcow2指下一行file的类型
      <source file='/var/lib/libvirt/images/node.img'/>
      <target dev='vda' bus='virtio'/>         //dev：在系统里的设备编号；bus：系统总线
    </disk>
    <interface type='bridge'>      //虚拟网卡
      <source bridge='vbr'/>       //连接到vbr虚拟交换机上
      <model type='virtio'/>
    </interface>
    <channel type='unix'>          //qemu-agent客户端程序，系统控制虚拟机的程序
      <target type='virtio' name='org.qemu.guest_agent.0'/>
    </channel>
    <serial type='pty'></serial>
    <console type='pty'>           //console命令的接口
      <target type='serial'/>
    </console>
    <memballoon model='virtio'></memballoon>   //内存驱动
  </devices>
</domain>

内存、cpu设置
• xml 配置文件
<domain type='kvm' id='4'>
<name>centos7.0</name>
<uuid>8413f30a-c978-4796-a28f-8ba9fe74b759</uuid>
<memory unit='KiB'>2097152</memory>
<currentMemory unit='KiB'>2097152</currentMemory>
– id=4 个性化设置 ,去掉
– uuid 去掉
– memory unit 虚拟机最大使用内存,可以手动调整
– currentmemory 创建虚拟机使用内存
• xml 配置文件
– cpu 设置,可以调整
<vcpu placement='static'>2</vcpu>
– 资源设置,可以删除
<resource> ... ... </resource>
– 系统配置及引导设备,丌需要修改
<os>
<boot dev='hd'/>
</os>
– 电源相关配置无需修改
<features> ... ... </features>
• xml 配置文件
– cpu 配置,可以修改成使用真机 cpu
<cpu ... ... />
<cpu mode='host-passthrough'></cpu>
– 时钟相关配置,可以删除
<clock ... ... </clock>
– 重启,关机,强制关闭对应命令
<on_poweroff>destroy</on_poweroff>
<on_reboot>restart</on_reboot>
<on_crash>destroy</on_crash>
磁盘设置
• xml 配置文件
– 内存及硬盘休眠相关设置,可以删除
<pm> ... ... </pm>
– 仿真设备相关配置
<devices> ... ... </devices>
– 其他配置
– 驱劢安全标签,可删除
<seclabel> ... ... </seclabel>
硬件仿真设备
• 仿真设备配置
– 总线地址,别名配置,都可以删除
<address ....
<alias ...
– 硬盘配置,需要修改
<emulator>/usr/libexec/qemu-kvm</emulator>
<disk ... ... </disk>
– usb 相关设备配置,可以删除
<controller type='usb'
• 仿真设备配置
– type='pci' pci总线设备,可删除
– type='virtio-serial' 串口设备需要保留串口终端
– type='network' 网络配置需要修改
– type='pty' 串口终端,需要保留
– type='unix' 虚拟机通讯控制接口
– type='spicevmc' 图形图像相关配置可以删除
– type='tablet' 数位板,可以删除
• 仿真设备配置
– type='mouse' 鼠标,保留
– type='keyboard' 键盘保留
– graphics、video 图形图像显卡相关配置,可以删除
– sound 声卡相关配置,可以删除
– redirdev 设备重定向,可以删除
– memballoon 内存气泡,可以动态调整内存

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

配置一台虚拟机作为后端盘
自定义虚拟机安装：yum源装虚拟机（CentOS系统）

真机搭yum
CentOS-1708.iso 8.1G 共9591个包 ：作为网络yum源
[root@room9pc01 nsd1807]# mkdir /var/ftp/centos7
[root@room9pc01 nsd1807]# mount '/root/桌面/笔记/第四阶段/cloud/cloud 1/CentOS7-1708.iso' /var/ftp/centos7
[root@room9pc01 nsd1807]# df -h
[root@room9pc01 nsd1807]# ls /var/ftp/centos7/
CentOS_BuildTag  GPL       LiveOS    RPM-GPG-KEY-CentOS-7
EFI              images    Packages  RPM-GPG-KEY-CentOS-Testing-7
EULA             isolinux  repodata  TRANS.TBL

[root@room9pc01 nsd1807]# cat /etc/yum.repos.d/CentOS7-Base-163.repo 
[CentOS7-1708]
name=centos1708
baseurl=ftp://192.168.4.254/centos7
enabled=1
gpgcheck=0

[root@room9pc01 nsd1807]# yum clean all
[root@room9pc01 nsd1807]# yum repolist
--------------------------------------------------------------------------------------------------------
[root@room9pc01 nsd1807]# getenforce   //selinux  disabled
Disabled
[root@room9pc01 nsd1807]# systemctl stop firewalld
[root@room9pc01 nsd1807]# systemctl mask firewalld
-------------------------------------------------------------------------------------------------------

创建系统
第一步 创建一个qcow2的磁盘文件（空盘）
[root@room9pc01 nsd1807]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# qemu-img create -f qcow2 node.qcow2 2G 

第二步 在virt-manager中安装系统
1、打开虚拟机管理系统 --> 文件 --> 新建虚拟机
2、网络安装 --> URL:yum源地址 --> 内存：2048、CPU：2 --> 选择自定义存储：node.qcow2 --> 名称：node、选择网络：vbr --> 完成
3、语言：英语 --> 时区：Asia/Shanghai --> 软件包：最小安装 --> KDUMP:取消enable --> 分区：手动分区  DONE  分区类型LVM改成：Standerd、+ /（根分区）  DONE两次  ACCEPT --> 安装 设root密码

测试虚拟机能不能连外网
]# ping www.baidu.com  //ping不通：没有设DNS /etc/resolv.conf nameserver 0.0.0.0
我的情况：需要重启真机

虚拟机模板制作
1、搭建yum源
]# rm -f /etc/yum.repos.d/*    //删除所有国外yum源
]# vi /etc/yum.repos.d/local.repo   //新机没有vim命令

2、安装常用工具包
]# yum -y install git
]# yum -y install vim
]# yum provides *ifconfig
]# yum install -y net-tools bridge-utils psmisc lftp
]# yum list | grep bash
]# yum -y install bash-completion       //tab键包

3、禁用selinux
]# vim /etc/selinux/config
SELINUX=disabled
]# reboot

4、卸载防火墙与NetworkManager
]# systemctl stop NetworkManager
]# yum -y remove firewalld-* NetworkManager python-firewall

5、配置IP、禁用空路由
[root@room9pc01 nsd1807]# cat ifcfg-eth0 
# Generated by dracut initrd
DEVICE="eth0"             //设备驱动
ONBOOT="yes"               //开机自启动
NM_CONTROLLED="no"         //NetworkManager命令对此文件无效
TYPE="Ethernet"            //网卡类型
BOOTPROTO="dhcp"           //以dhcp协议获取IP地址
#BOOTPROTO="static"        //静态IP
#IPADDR="192.168.1.XX"     
#NETMASK="255.255.255.0"    //子网掩码
#GATEWAY="192.168.1.254"     //网关：一个机器只有一个网关，一张网卡配了，其他网卡都不能配

]# ip route show          //显示路由信息
]# vim /etc/sysconfig/network
NOZEROCONF="yes"            //禁用空路由
]# systemctl restart network

6、设置能用console命令控制虚拟机
[root@room9pc01 nsd1807]# cat /etc/sysconfig/grub       //内核启动参数，是一个软链接
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL="serial console"                        //改了3行
GRUB_SERIAL_COMMAND="serial --unit=1 --speed=115200"        //
GRUB_CMDLINE_LINUX="biosdevname=0 net.ifnames=0 console=tty0 console=ttyS0,115200n8"                           //
GRUB_DISABLE_LINUX_UUID="true"
GRUB_ENABLE_LINUX_LABEL="true"
GRUB_DISABLE_RECOVERY="true"

重新生成配置文件 grub.cfg
[root@room9pc01 nsd1807]# grub2-mkconfig -o /boot/grub2/grub.cfg
重启后真机用 virsh console node 检查

7、导入公钥
yum 源导入公钥验证配置
gpgcheck=1
导入 gpg key    //验证软件包有没有被修改过
rpm --import ftp://192.168.1.254/centos7/RPM-GPG-KEY-CentOS-7  //公钥在光盘里
安装任意包验证

8、分区：每个硬盘都有一个UUID，后端盘无法保证每个前段盘的UUID一样，所以要禁用UUID，使用卷标
[root@room9pc01 nsd1807]# cat /etc/sysconfig/grub
GRUB_DISABLE_LINUX_UUID="true"         //禁用UUID
GRUB_ENABLE_LINUX_LABEL="true"          //使用卷标
[root@room9pc01 nsd1807]# grub2-mkconfig -o /boot/grub2/grub.cfg

9、将fstab中的UUID换成/dev/vda
]# cat /etc/fstab
UUID
]# blkid
/dev/vda的UUID和/etc/fstab中的UUID一致
]# vim /etc/fstab
将fstab中的UUID换成/dev/vda

10、后段盘安装分区扩展软件
yum install -y cloud-utils-growpart

注：前端盘扩容
– 设置第一次开机自动扩容根目录
chmod 755 /etc/rc.local
– 根分区扩容
/usr/bin/growpart /dev/vda 1
/usr/sbin/xfs_growfs /

11、清理日志信息
关闭虚拟机
真机执行 virt-sysprep -d node
]# yum provides virt-sysprep

12、最后写脚本
后端盘只能是只读的，不能修改

真机：自定义虚拟机脚本
[root@room9pc01 nsd1807]# cat /root/桌面/envir/cloud/clone.sh
#!/bin/bash
if [ ! $1 ];then
	echo "请在脚本后面加上虚拟机名称"
	exit
fi
read -p "请输入系统内存大小（单位：G）：" big
cd /var/lib/libvirt/images/
qemu-img create -b node.qcow2 -f qcow2 ${1}.img ${big}G
cd /root/cloud/nsd1807/
sed "s/node/$1/" node.xml > /etc/libvirt/qemu/$1.xml
virsh define /etc/libvirt/qemu/$1.xml
virsh start $1
virsh console $1

虚拟机脚本放在后端盘里，创建前端盘后执行
虚拟机扩容脚本
]# cat sh/extend.sh 
#!/bin/bash
LANG=en_US.UTF-8 /usr/bin/growpart /dev/vda 1   //必须英语，否则空格是中文输入法的空格导致脚本错误
/usr/sbin/xfs_growfs /

虚拟机配置静态IP脚本
]# cat sh/staticIP.sh 
#!/bin/bash
echo "
# Generated by dracut initrd
DEVICE=\"eth0\"
ONBOOT=\"yes\"
NM_CONTROLLED=\"no\"
TYPE=\"Ethernet\"
BOOTPROTO=\"static\"
IPADDR=\"192.168.1.$1\"
NETMASK=\"255.255.255.0\"
" > /etc/sysconfig/network-scripts/ifcfg-eth0
systemctl restart network

13、保证后端盘安全
virsh list 
node关机
virsh undefine node
virsh list --all 没有node

=================================================================================
		             12.Cloud-day02
=================================================================================

离线访问虚拟机
• 使用guestmount工具：后悔药
– 支持离线挂载 raw、qcow2 格式虚拟机磁盘
– 可以在虚拟机关机的情冴下,直接修改磁盘中的文档
– 方便对虚拟机定制、修复、脚本维护
!!! 需要注意 SELinux 机制的影响
• 基本用法
guestmount -a 虚拟机磁盘路径 -i /挂载点
umount /挂载点

注：guestmount修改后端盘，所有相关的前端盘都失效

+++++++++++++++++++++++++++++++++++++++++++++++++++

openstack：综合性的云管理平台，自动管理虚拟机的网络；与NetworkManager冲突
openstack：管理虚拟机的防火墙；要将虚拟机的防火墙卸掉

装openstack
准备环境

真机做DNS服务器
[root@room9pc01 ~]# yum -y install bind bind-chroot
[root@room9pc01 ~]# vim /etc/named.conf 
 14         listen-on port 53 { 192.168.1.254; };
 15         #listen-on-v6 port 53 { ::1; }; //不监听IPV6
 21         allow-query     { any; };     //允许所有主机查询
 35         forwarders{ 114.144.144.144; };  //地址转发
 37         dnssec-enable no;
 39         dnssec-validation no;
[root@room9pc01 ~]# systemctl restart named
[root@room9pc01 ~]# dig @192.168.1.254 A www.baidu.com   //验证配置是否成功

将真机做成时间服务器
[root@room9pc01 ~]# yum -y install chrony
[root@room9pc01 ~]# vim /etc/chrony.conf
#server 0.centos.pool.ntp.org iburst
#server 1.centos.pool.ntp.org iburst
#server 2.centos.pool.ntp.org iburst
#server 3.centos.pool.ntp.org iburst
server ntp.aliyun.com iburst         //与阿里云时间服务器同步（客户端配置）
bindacqaddress 0.0.0.0               //监听所有地址（服务端配置，重启服务后有123端口）
allow 0/0                            //允许所有客户端与本机同步（服务端配置）
cmdallow 127.0.0.1                   //指定本机可以通过chronyd使用控制命令

[root@room9pc01 ~]# systemctl restart chronyd
[root@room9pc01 ~]# chronyc sources -v
======================================================
^* 203.107.6.88                  2   9   357   425   +430us[ +550us] +/-   26ms      //阿里云服务器的地址

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

什么是云计算
• 基于互联网的相关服务的增加、使用和交付模式
• 这种模式提供可用的、便捷的、按需的网络访问,进入可配置的计算资源共享池
• 这些资源能够被快速提供,只需投入很少的管理工作,或与服务供应商进行很少的交互
• 通常涉及通过互联网来提供劢态易扩展且经常是虚拟化的资源

IaaS（主要云；阿里云、腾讯云、亚马孙）
• IaaS(Infrastructure as a Service),即基础设施即服务
• 提供给消费者的服务是对所有计算基础设施的利用,包括处理CPU、内存、存储、网络和其它基本的计算资源,用户能够部署和运行任意软件,包括操作系统和应用程序
• IaaS通常分为三种用法:公有云、私有云（自己买）和混合云
openstack是私有云，改了去卖就变成共有云

PaaS（淘宝提供平台，用户【买家、卖家】提供销售空间；类似万达广场；无数用户组成）
• PaaS (Platform-as-a-Service),意思是平台即服务
• 以服务器平台戒者开发环境作为服务进行提供就成为了PaaS
• PaaS运营商所需提供的服务,不仅仅是单纯的基础平台,还针对该平台的技术支持服务,甚至针对该平
台而运行的应用系统开发、优化等服务
• 简单地说,PaaS平台是指云环境中的应用基础设施服务,也可以说是中间件即服务

SaaS（应用商店，提供软件销售）
• SaaS(Software-as-a-Service)软件即服务,是一种通过Internet提供软件的模式,厂商将应用软件统一部署在自己的服务器上,客户可以根据自己实际需求,通过互联网向厂商定购所需的应用软件服务
• 用户不用再购买软件,而是向提供商租用基于Web的软件,来管理企业经营活动,不用对软件迚行维护,提供商会全权管理和维护软件,同时也提供软件的离线操作和本地数据存储
一台是虚拟机、一百台是集群、海量台就是云

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

什么是Openstack
• OpenStack是一个由NASA(美国国家航空航天局)
和Rackspace合作研发并发起的项目
• OpenStack是一套IaaS解决方案
• OpenStack是一个开源的云计算管理平台
• 以Apache许可证为授权

Openstack主要组件
• Horizon
– 用于管理Openstack各种服务的、基于web的管理接口
– 通过图形界面实现创建用户、管理网络、启劢实例等操作
• Keystone
– 为其他服务提供认证和授权的集中身份管理服务
– 也提供了集中的目录服务
– 支持多种身份认证模式,如密码认证、令牌认证、以及AWS(亚马逊Web服务)登陆
– 为用户和其他服务提供了SSO认证服务
• Neutron
– 一种软件定义网络服务
– 用于创建网络、子网、路由器、管理浮劢IP地址
– 可以实现虚拟交换机、虚拟路由器
– 可用于在项目中创建VPN
• Cinder
– 为虚拟机管理存储卷的服务
– 为运行在Nova中的实例提供永久的块存储
– 可以通过快照迚行数据备份
– 经常应用在实例存储环境中,如数据库文件
• Nova（相当于代理客户端；在服务器上的命令会下发到nova，nova再发给客户端；每台客户端都要有一个nova）
– 在节点上用于管理虚拟机的服务
– Nova是一个分布式的服务,能够不Keystone交互实现认证,不Glance交互实现镜像管理
– Nova被设计成在标准硬件上能够迚行水平扩展
– 启劢实例时,如果有则需要下载镜像
• Glance
– 扮演虚拟机镜像注册的角色
– 允许用户为直接存储拷贝服务器镜像
– 这些镜像可以用于新建虚拟机的模板
• Swift
对象存储软件，虚拟机内存不够，东西存这里

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

安装openstack
1、配置yum仓库
CentOS7-1708.iso RHEL7-extras.iso RHEL7OSP-10.iso 12个yum源 10731个包

2、虚拟机配置
虚拟机1  服务 openstack nova
hostname openstack
内存 9.5G
硬盘 系统 50G
硬盘 空   50G
网卡 2块  vbr provate1

虚拟机2  服务 nova
hostname nova01
内存 5G
硬盘 系统 50G
网卡 2块  vbr provate1

3、用上面3个脚本创建2个虚拟机
]# sh /root/桌面/envir/cloud/clone.sh openstack
请输入系统内存大小（单位：G）：50
]# sh /root/桌面/envir/cloud/clone.sh nova01
请输入系统内存大小（单位：G）：50

[root@nova01 ~]# sh sh/extend.sh
[root@nova01 ~]# sh sh/staticIP.sh 11
[root@nova01 ~]# hostname nova01
[root@openstack ~]# sh sh/extend.sh
[root@openstack ~]# sh sh/staticIP.sh 10
[root@openstack ~]# hostname openstack

4、创建20G空盘
[root@room9pc01 nsd1807]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# qemu-img create -f qcow2 disk.img 20G

5、修改虚拟机配置（先关闭虚拟机）
[root@room9pc01 images]# virsh edit openstack    //nova01一样
  <memory unit='KiB'>9848000</memory>            //内存
  <currentMemory unit='KiB'>9848000</currentMemory>


    <disk type='file' device='disk'>                  //在disk下面添加一段
      <driver name='qemu' type='qcow2'/>
      <source file='/var/lib/libvirt/images/disk.img'/>
      <target dev='vdb' bus='virtio'/>
    </disk>

    <interface type='bridge'>                   //在interface下面添加一段
      <source bridge='private1'/>
      <model type='virtio'/>
    </interface>
：wq
[root@room9pc01 images]# virsh edit openstack    //保存再打开会自动生成mac地址和总线地址，不能删了
--------------------------------------------------------------------
[root@room9pc01 images]# brctl show //查看已有网桥
---------------------------------------------------------------------

[root@openstack ~]# free -mh          //检查内存
[root@openstack ~]# lsblk             //检查硬盘
[root@openstack ~]# ifconfig -a       //设置eth1开机自启，并检查两块网卡
[root@openstack ~]# cd /etc/sysconfig/network-scripts/
[root@openstack ~]# cp ifcfg-eth0 ifcfg-eth1
[root@openstack ~]# vim ifcfg-eth1
DEVICE="eth1"
IPADDR="192.168.4.10"
#GATEWAY
[root@openstack ~]# systemctl restart network   //或reboot

6、设置虚拟机可以ping通虚拟机名称
]# vim /etc/hosts
192.168.1.10 openstack
192.168.1.11 nova01

7、检查虚拟机DNS和时间服务器
[root@openstack ~]# cat /etc/resolv.conf    //DNS
; generated by /usr/sbin/dhclient-script
nameserver 192.168.1.254                   //必须在第一行
search openstack
[root@openstack ~]# ping www.baidu.com      //能通
[root@openstack ~]# vim /etc/chrony.conf
    server gateway iburst
[root@openstack ~]# systemctl restart chronyd
[root@openstack ~]# chronyc sources -v
======================================================
^* gateway                       3   6   377    55    +11us[  +13us] +/-   


=================================================================================
		             12.Cloud-day03
=================================================================================

检查openstack环境部署
• 是否禁用selinux
• 是否卸载firewalld和NetworkManager
• 检查配置主机网络参数(静态IP)
• 检查配置主机yum源(12个)
• 检查cinder-volumes卷组是否已经创建
• 检查公钥是否导入
• 查看相关软件包是否安装
• 检查NTP和DNS服务器是否可用

注：要虚拟机重新读配置文件，需要shutdown再开机，reboot不行

配置卷组    （给组件cinder用的）
• Openstack为虚拟机提供的云硬盘,本质上是本地的逻辑卷
• 逻辑卷创建于名为cinder-volumes的卷组
• 没有物理卷可以使用 loop 文件替代
– losetup loop0 /var/disk.img
– pvcreate /dev/loop0 
– vgcreate cinder-volumes /dev/loop0

1、openstack配置卷组
]# yum install lvm2
]# pvcreate /dev/vdb                      //创建物理卷
]# vgcreate cinder-volumes /dev/vdb        //创建卷组，名字一定要是cinder-volumes，程序里写死了
]# vgs


2、openstack和nova01安装额外软件包
]# yum install -y qemu-kvm libvirt-client libvirt-daemon
libvirt-daemon-driver-qemu python-setuptools


3、openstack安装openstack-packstack
[root@openstack ~]# yum install openstack-packstack      

4、安装openstack服务器
[root@openstack ~]# packstack --gen-answer-file=answer.ini       //生成一个应答文件，txt格式也可以，但ini格式有颜色
[root@openstack ~]# vim answer.ini
11   CONFIG_DEFAULT_PASSWORD=Taren1         //设置默认密码，没什么用，数据、系统会生成随机密码，在生成随机密码失败时才会用这个密码
42   CONFIG_SWIFT_INSTALL=n                  //swift是对象存储，需要很大的机器
75   CONFIG_NTP_SERVERS=192.168.1.254        //NTP服务器，时间同步
554  CONFIG_CINDER_VOLUMES_CREATE=n          //自动随机创建卷组
840  CONFIG_NEUTRON_ML2_TYPE_DRIVERS=flat,vxlan   //openstack网络支持哪些格式，vxlan：能给每个虚拟机提供独立的内网，隔离同一个公司同一个云主机公司的机器；云主机公司只有一个外网，flat扁平网络：能给每个虚拟机提供独立的外网，让虚拟机可以上网
876  CONFIG_NEUTRON_ML2_VXLAN_GROUP=239.1.1.5     //组播，给组里每个主机广播，组播地址239开头
910  CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS=physnet1:br-ex  //（云主机的物理机中的虚拟机与真机通信：虚拟机 - 虚拟交换机 - 云主机的物理网卡 - 物理交换机 - 真机）把物理网卡当成虚拟机交换机的端口physnet1[表示要定义一个有物理端口的虚拟交换机]:br-ex[虚拟交换机的名称]
921  CONFIG_NEUTRON_OVS_BRIDGE_IFACES=br-ex:eth0  //把物理网卡eth0当成虚拟交换机的端口
936  CONFIG_NEUTRON_OVS_TUNNEL_IF=eth1      //隧道的端口；支持不同物理机的虚拟机通信
1178 CONFIG_PROVISION_DEMO=n        //测试DEMO，自行执行测试脚本
[root@openstack ~]# packstack --answer-file=answer.ini       //执行应答文件

------------------------------------------------------------------------------------------
删除虚拟机
1、virsh destroy vm4  //强制停止虚拟机
2、virsh undefine vm4  //删除虚拟机
3、删除和vm4一切相关的内容
-----------------------------------------------------------------------------------------

安装成功后
openstack的网页默认用apache打开，有个bug
Horizon
• Horizon BUG 处理
• 安装虽然没有报错,但默认无法打开 Horizon,这是一个软件的配置 BUG
[root@openstack ~]# vim /etc/httpd/conf.d/15-horizon_vhost.conf
ServerAlias localhost
WSGIDaemonProcess apache group=apache processes=3 threads=10 user=apache
WSGIProcessGroup apache
WSGIApplicationGroup %{GLOBAL}      <--- 这里添加
• 重新载入配置文件 apachectl graceful

openstack默认管理员用户名密码
[root@openstack ~]# cat keystonerc_admin  //改文件密码无效，要在服务器上修改；该文件主要用作记录密码
    export OS_USERNAME=admin
    export OS_PASSWORD=34a023335fc64a5a

[root@openstack ~]# ifconfig br-ex          //eth0变成br-ex的一个端口

————————————————————————————————————————————
根据个人情况需要自行添加、修改文件
[root@openstack ~]# cat /etc/sysconfig/network-scripts/ifcfg-br-ex
ONBOOT="yes"
NM_CONTROLLED="no"
IPADDR="192.168.1.10"
NETMASK="255.255.255.0"
GATEWAY="192.168.1.254"
DEVICE=br-ex
NAME=br-ex
DEVICETYPE=ovs         //驱动类型ovs   注：加这三行就能配置一个交换机
OVSBOOTPROTO="none"   //没有协议
TYPE=OVSBridge       //ovs技术的交换机
[root@openstack ~]# cat /etc/sysconfig/network-scripts/ifcfg-br-ex
DEVICE="eth0"
NAME=eth0
DEVICETYPE=ovs
ONBOOT="yes"
TYPE=OVSPort
OVS_BRIDGE=br-ex
BOOTPROTO=none
————————————————————————————————————————————

[root@openstack ~]# ovs-vsctl show      //查看ovs网桥配置
    Bridge br-ex
        Controller "tcp:127.0.0.1:6633"
            is_connected: true
        fail_mode: secure
        Port br-ex
            Interface br-ex
                type: internal
        Port "eth0"
            Interface "eth0"
        Port phy-br-ex
            Interface phy-br-ex
                type: patch
                options: {peer=int-br-ex}
[root@openstack ~]# ip -o addr show  //查看ip地址 -o是在一行显示

使用openstack命令
要导入环境变量
[root@openstack ~]# source keystonerc_admin
[root@openstack ~(keystone_admin)]# openstack user list //查看用户信息

++++++++++++++++++++++++++++++++++++++++++++++++++++

openstack服务器
1、系统默认两个项目
admin：管理员
services：协调七大组件工作

2、默认8个用户：一个管理员，七个对应七大组件

管理员admin
创建云主机：
1、创建云主机类型
2、创建镜像（后端盘xml）   //small：redhat6系统、100M、qcow2格式；文件会在真机上找
管理镜像由Glance组件提供
3、创建网络
供应商网络类型    //flat：外网
物理网络   //写物理网络名称
段ID    //不用写，自动生成
共享的   //打勾
外部网络   //打勾

用户u1
1、网络拓扑
2、创建网络-创建内网交换机
网络 --> 网络名称：lan --> 下一步
子网 --> 子网名称：lan_net --> 网络地址：10.10.10.0/24 --> 网关（内网卡IP地址，没买）：10.10.10.254 --> 下一步
子网详情 --> 激活DHCP --> 分配地址：10.10.10.100,10.10.10.200 --> 创建
3、public增加子网-买公网IP
子网 --> 子网名称：wan --> 网络地址：192.168.1.0/24 --> 网关IP：192.168.1.254 --> 下一步
子网详情 --> 不激活DHCP --> 创建
4、新建路由
路由名称：r1 --> 外部网络：public --> 创建
路由增加接口 --> 子网：lan --> IP地址：10.10.10.254 --> 提交
5、创建云主机
详情 --> 名称：h1 
源（后端盘） --> 选择源类型：镜像 --> 创建新卷：否 --> 添加CentOS6
云主机类型 --> 添加test01
网络 --> 添加lan
创建

---------------------------------------------------------------------------------------------------------------------------
控制台：root redhat

排错
1、1006
]# cat /etc/resolv.conf
nameserver 192.168.1.254  //必须在第一行

2、无法打开控制台
]# vim /etc/nova/nova.conf
8465 vncserver_proxyclient_address=openstack.openstack  //改配置需要重启服务，所以将域名复制到DNS上
[root@localhost ~]# vim /etc/hosts
192.168.1.10 openstack openstack.openstack

3、No valid host was found. There are not enough hosts available.
]# systemctl list-unit-files | grep -i openstack
openstack-nova-compute.service             //管理虚拟机的服务
openstack-nova-console.service             //控制台接口服务
]# systemctl restart openstack-nova-compute

=================================================================================
		             12.Cloud-day04
=================================================================================

云主机上网：买浮动IP
用户u1
1、云主机数量 --> 绑定浮动IP --> 添加IP地址 --> 分配 --> 关联
2、openstack管理防火墙
访问与安全 --> 创建安全组 --> 名称：n1 --> 添加规则 --> 规则：ALL ICMP(ping) --> 方向：入口 --> 创建
3、编辑云主机 --> 编辑安全组 --> 添加n1 --> 取消default --> 保存
4、检查
真机ping通云主机浮动IP

ps：
裸奔：两条规则（其他就是所有）
其他规则 入口
其他规则 出口
---------------------------------------------------------------------------------------------------------------------------------
出错原因一般是服务没起来（内存不够，要先确定openstack先起来，再开nova01）
[root@localhost ~]# cd /usr/lib/systemd/system
[root@localhost system]# ls | grep neu       //网络相关的配置服务
neutron-dhcp-agent.service
neutron-l3-agent.service
neutron-linuxbridge-cleanup.service
neutron-metadata-agent.service
neutron-metering-agent.service
neutron-netns-cleanup.service
neutron-openvswitch-agent.service
neutron-ovs-cleanup.service
neutron-server.service
最快办法：重启openstack服务器

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

安装额外计算节点（环境在搭建后端盘时准备好了）
nova01
准备网络
• 配置两块网卡,和第一台Openstack服务器的两块网卡对应
• 一块网卡用于主机间通信（1.10：1.11）,另一块网卡用于隧道（4.10：4.11）
• DNS地址指向正确的服务器地址，NTP时间同步
• 停止并禁用NetworkManager、firewall，关闭selinux
准备软件环境
• 配置好yum,能够使用rhel7光盘和Openstack光盘提供的仓库源
• 由于安装过程中有些依赖包没有在yum源中,所以要提前安装上,依赖的软件包
• 导入签名信息

安装计算节点
修改应答文件
• 安装额外节点,只需要在第一台Openstack服务器上进行即可
• 修改配置文件
[root@openstack ~] # vim answer.txt
98  CONFIG_COMPUTE_HOST=192.168.1.10,192.168.1.11  //在哪台主机安装nova
102 CONFIG_NETWORK_HOSTS=192.168.1.10,192.168.1.11   //在哪台主机安装user网络

安装节点（内存不够，需要删云主机；项目名称是中文的也要删掉）
------------------------------------------------------------------------------------------------------------------------
删项目，先删用户
删网络，先删路由
删路由，先删子接口
-------------------------------------------------------------------------------------------------------------------------
• 在第一台节点上执行安装命令
[root@opstack ~] # packstack --answer-file answer.txt
• 按提示,输入进程主机root密码
• 本机已安装服务,不会被覆盖,只有改动后的选项才需要重新配置

+++++++++++++++++++++++++++++++++++++++++++++++++
云主机热迁移
云主机迁移过程中能一直被ping通
+++++++++++++++++++++++++++++++++++++++++++++++++

FULL-NAT模式
CLOUD课程第四天下午

=================================================================================
		             12.Cloud-day05
=================================================================================

什么是容器
• 容器技术已经成为应用程序封装和交付的核心技术
• 容器技术的核心有以下几个内核技术组成:
– Cgroups(Control Groups)-进程资源管理        
– NameSpace-进程隔离                        //命名空间，核心技术，空间内的进程只能使用空间内的资源
– SELinux安全
• 由于是在物理机上实施隔离,启动一个容器,可以像启动一个进程一样快速

------------------------------------------------------------------------------------------------------
六大命名空间
No.1	MNT Namespace	提供磁盘挂载点和文件系统的隔离能力
No.2	IPC Namespace	提供进程间通信的隔离能力
No.3	Net Namespace	提供网络隔离能力
No.4	UTS Namespace	提供主机名隔离能力
No.5	PID Namespace	提供进程隔离能力
No.6	User Namespace	提供用户隔离能力
------------------------------------------------------------------------------------------------------

什么是Docker
• Docker是完整的一套容器管理系统
• Docker提供了一组命令,让用户更加方便直接地使用容器技术,而不需要过多关心底层内核技术

Docker优点
• 相比于传统的虚拟化技术,容器更加简洁高效
• 传统虚拟机需要给每个VM安装操作系统
• 容器使用的共享公共库和程序（共享本机的内核，不可能装windows系统）

Docker缺点
• 容器的隔离性没有虚拟化强
• 共用Linux内核,安全性有先天缺陷
• SELinux难以驾驭
• 监控容器和容器排错是挑战

安装前准备
• 需要64位操作系统
• 至少RHEL6.5以上的版本,强烈推荐RHEL7
• 关闭防火墙(不是必须)

安装Docker
1、准备两台虚拟机 16G硬盘 4G内存

]# virsh edit dockerA.xml
  <memory unit='KiB'>4194304</memory>              //可以写GB
  <currentMemory unit='KiB'>4194304</currentMemory>    //也要改成GB

2、真机搭建yum源
[root@room9pc01 qemu]# cp '/root/桌面/笔记/第四阶段/cloud/cloud 4/docker 1/docker-engine-1.12.1-1.el7.centos.x86_64.rpm' '/root/桌面/笔记/第四阶段/cloud/cloud 4/docker 1/docker-engine-selinux-1.12.1-1.el7.centos.noarch.rpm' '/root/桌面/笔记/第四阶段/cloud/cloud 4/docker 1/docker_images.zip' /var/ftp/docker
[root@room9pc01 qemu]# cd /var/ftp/docker/
[root@room9pc01 docker]# createrepo .

3、两台虚拟机配置yum源
[root@dockera ~]# cat /etc/yum.repos.d/local.repo 
[docker]
name=docker
baseurl=ftp://192.168.1.254/docker
enabled=1
gpgcheck=0

4、装包启服务
[root@dockera ~]# yum -y install docker-engine
[root@dockera ~]# systemctl start docker
[root@dockera ~]# ifconfig               //多了docker0，它是虚拟交换机
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0
        ether 02:42:61:c8:40:dd  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
[root@dockera ~]# docker version

5、配置DNS
[root@dockera ~]# vim /etc/hosts
192.168.1.20 dockerA
192.168.1.21 dockerB

+++++++++++++++++++++++++++++++++++++++++++++++++++++
使用Docker，分两部分：镜像和容器
镜像：后端盘
容器：以后端盘运行的实例

什么是镜像
• 在Docker中容器是基于镜像启动的
• 镜像是启动容器的核心
• 镜像采用分层设计（以后端盘创建前端盘，再以后端盘和前端盘打包创建前前端盘，前前前端盘..）
• 使用快照的COW技术,确保底层数据不丢失

Docker hub镜像仓库
• https://hub.docker.com
• Docker官方提供公共镜像的仓库(Registry)

Docker镜像管理命令
]# docker images           //查看镜像
]# docker search 镜像名       //查找命令
]# docker pull             //下载镜像
]# docker push             //上传镜像，需要用户名密码
]# man docker              //查看帮助
]# docker help images      //查看子命令帮助

练习（前提能上网）
[root@dockerb ~]# docker search busybox
[root@dockerb ~]# docker pull busybox
[root@dockerb ~]# docker images

备份
]# docker save busybox:lastest > busybox.tar      //标签默认是latest，所以可以不用写；保存下来的文件是个tar包
]# docker load < busybox.tar    //恢复

---------------------------------------------------------------------------------------------------------------------------
docker_images.zip  备份恢复（老师下载的包）
[root@dockera ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
sshd                apache              5b334c531ba5        3 days ago          392.3 MB
apache              latest              e2f652eeec05        3 days ago          368.7 MB
myos                latest              2b923df5079a        3 days ago          198.6 MB
busybox             latest              59788edf1f3e        7 weeks ago         1.154 MB
ubuntu              latest              452a96d81c30        6 months ago        79.62 MB
centos              latest              e934aafc2206        7 months ago        198.6 MB
registry            latest              d1fd7d86a825        10 months ago       33.26 MB
nginx               latest              a5311a310510        2 years ago         181.4 MB
redis               latest              1aa84b1b434e        2 years ago         182.8 MB
------------------------------------------------------------------------------------------------------------------------

用镜像创建容器
]# docker run -it 镜像名:标签名  要运行的命令  //‘要运行的命令’是镜像里的命令

[root@dockera ~]# docker run -it centos:latest /bin/bash
[root@f368aa168a00 /]# cd /etc/yum.repos.d/       
[root@f368aa168a00 yum.repos.d]# ls
CentOS-Base.repo       CentOS-Media.repo    CentOS-fasttrack.repo
CentOS-CR.repo         CentOS-Sources.repo
CentOS-Debuginfo.repo  CentOS-Vault.repo
[root@f368aa168a00 yum.repos.d]# rm -f *
[root@f368aa168a00 yum.repos.d]# vi local.repo
[root@f368aa168a00 yum.repos.d]# yum repolist
[root@f368aa168a00 yum.repos.d]# yum provides ifconfig
[root@f368aa168a00 yum.repos.d]# yum -y install net-tools
[root@f368aa168a00 yum.repos.d]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 0.0.0.0

--------------------------------------------------------------------------------------------------------
[root@room9pc01 docker]# echo $$        //查看当前进称号
10493
-----------------------------------------------------------------------------------------------------

问题：
[root@dockera ~]# docker run -it busybox:latest ls /bin   //busybox没有bash命令
[root@dockera ~]# docker run -it busybox:latest /bin/sh  
/ # 
[root@dockera ~]# docker run -it busybox:latest  //默认启动命令，什么也不写

nginx也是用ubuntu命令
--------------------------------------------------------------------------------------------------------
命令区别
redhat                  ubuntu      //系统
yum                     apt-get   //装包命令
rpm                     dpkg      //包管理命令
除了这两个之外其他命令都一样
-----------------------------------------------------------------------------------------------------
[root@dockera ~]# docker run -it nginx      //会卡，服务启动了

[root@dockera ~]# curl -i http://172.17.0.2    //再开一个终端连接容器
<title>Welcome to nginx!</title>

容器不是虚拟机，证明：1、容器里执行的进程可以在真机（虚拟机docker）可以看见（ps -ef），容器里却看不见；2、虚拟机没有装nginx，但有nginx进程


镜像常用命令
– docker images     //查看镜像列表
– docker history    //查看镜像制作历史
– docker inspect    //查看镜像底层信息
– docker pull       //下载镜像
– docker push       //上传镜像
– docker rmi        //删除本地镜像
– docker save       //镜像另存为tar包
– docker load       //使用tar包导入镜像
– docker search     //搜索镜像
– docker tag        //修改镜像名称和标签

docker images
• 查看镜像列表
– 镜像仓库名称
– 镜像标签
– 镜像ID
– 创建时间
– 大小
docker history 镜像名
• 查看镜像历史
– 了解镜像制作过程
– 详细参考后面的dockerfile内容
docker inspect 镜像|容器|网络|ID
• 查看镜像底层信息（详细信息）
– 了解镜像环境变量、存储卷、标签等信息
docker rmi 镜像名
• 删除本地镜像
– 注意:启动容器时删除镜像会提示错误（先删容器再删镜像）
docker tag centos:latest test:v1    \\类似软连接，ID一样；ID唯一，可以理解通过名称标签找到ID
• 重命名镜像名称(复制镜像)

容器常用命令
• 命令列表
– docker run          //运行容器
– docker ps           //查看容器列表
– docker stop         //关闭容器
– docker start        //启动容器
– docker restart      //重启容器
– docker attach|exec  //进入容器
– docker inspect      //查看容器底层信息
– docker top          //查看容器进程列表
– docker rm           //删除容器

容器的第二种启动方式
[root@dockera ~]# docker run -itd nginx   //docker中的&命令，将进程放在后台运行

docker ps
• 列出容器列表
– docker ps 查看正在运行的容器
– docker ps -a 查看所有容器列表
– docker ps -aq 仅显示容器id

docker stop|start|restart
• 管理容器
– docker stop     \\关闭容器
– docker start    \\开启容器，默认放后台
– docker restart  \\重启容器，默认放后台

注：前一个命令的结果可以当作后一个命令的参数
[root@server0 ~]# docker rm `docker stop $(docker ps -aq)`

docker top 容器ID          \\查错的时候会用
• 查看容器进程列表

docker attach|exec 容器ID
• 进入容器
– docker attach 进入容器,exit会导致容器关闭；连上的是上帝进程；Ctrl p（松开） q：在不关闭容器的情况下退出；看错误日志时才用到
– docker exec 进入容器,退出时不会关闭容器,容器在后台运行


[root@dockera ~]# pstree -p
systemd(1)─┬─agetty(559)      \\上帝：进称号为1的；没有父进程的进程会自动挂在上帝进程下

=================================================================================
		             12.Cloud-day06
=================================================================================

安装两个容器
第一个容器启动 httpd
第二个容器启动 nginx
设置默认首页为 hello world
特别要求：不允许使用find命令

[root@dockera ~]# docker run -itd nginx
4172198b61e5d923c4d75ad6163b1e61abd4eb1937de4e0b589b5b2a6fb95b77
[root@dockera ~]# docker run -itd centos
77cc9ee9c228220fa8b3ec74942b353cf69fb17a7c23c64510a69b8d65a2c845
[root@dockera ~]# docker exec -it 77 /bin/bash
[root@77cc9ee9c228 /]# cd /etc/yum.repos.d/
[root@77cc9ee9c228 yum.repos.d]# ls    
CentOS-Base.repo       CentOS-Media.repo    CentOS-fasttrack.repo
CentOS-CR.repo         CentOS-Sources.repo
CentOS-Debuginfo.repo  CentOS-Vault.repo
[root@77cc9ee9c228 yum.repos.d]# rm -f *
[root@77cc9ee9c228 yum.repos.d]# vi local.repo
[local]
name=centos
baseurl=ftp://192.168.1.254/centos7
gpgcheck=0
enabled=1
[root@77cc9ee9c228 yum.repos.d]# yum -y install httpd
[root@77cc9ee9c228 yum.repos.d]# apachectl             //apache的启动命令
[root@77cc9ee9c228 yum.repos.d]# yum -y install net-tools
[root@77cc9ee9c228 yum.repos.d]# netstat -ntlup
[root@77cc9ee9c228 yum.repos.d]# vi /var/www/html/index.html
[root@77cc9ee9c228 yum.repos.d]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 0.0.0.0
[root@77cc9ee9c228 yum.repos.d]# exit
[root@dockera ~]# curl 172.17.0.3
hello world

[root@dockera ~]# docker ps                //查看nginx容器
[root@dockera ~]# docker exec -it 41 /bin/bash
root@4172198b61e5:/# dpkg -L nginx          //查看配置文件的位置
/etc/nginx/nginx.conf
root@4172198b61e5:/# cat /etc/nginx/nginx.conf
include /etc/nginx/conf.d/*.conf;
root@4172198b61e5:/# cd /etc/nginx/conf.d/
root@4172198b61e5:/etc/nginx/conf.d# ls
default.conf
root@4172198b61e5:/etc/nginx/conf.d# cat default.conf 
root   /usr/share/nginx/html;              //nginx默认首页
root@4172198b61e5:/etc/nginx/conf.d# echo hello > /usr/share/nginx/html/index.html 
root@4172198b61e5:/etc/nginx/conf.d# exit
exit
[root@dockera ~]# curl 172.17.0.2
hello
[root@dockera ~]# curl -i 172.17.0.2
Server: nginx/1.11.5

hello

----------------------------------------------------------------------------------------------------------------
systemctl是一个和上帝进程systemd交流的工具，容器中是不能用的
----------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++
自定义镜像
1、删除所有容器
[root@dockera ~]# docker rm $(docker ps -aq)
[root@dockera ~]# docker ps -a

2、新建容器（不需要时间同步，本来就是系统的一部分）
[root@dockera ~]# docker run -it centos
[root@d446b12fddf2 /]# cd /etc/yum.repos.d/
[root@d446b12fddf2 yum.repos.d]# rm -f *
[root@d446b12fddf2 yum.repos.d]# vi local.repo
[local]
name=centos
baseurl=ftp://192.168.1.254/centos7
enabled=1
gpgcheck=0
[root@d446b12fddf2 yum.repos.d]# yum -y install vim net-tools psmisc iproute

注：百度vim的快捷键

3、清理缓存
[root@d446b12fddf2 yum.repos.d]# yum clean all
[root@d446b12fddf2 yum.repos.d]# history -c
[root@d446b12fddf2 yum.repos.d]# history -w

4、以前端盘为模板打包
[root@dockera ~]# docker commit d44 myos:lastest
[root@dockera ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE0
myos                lastest             300e94e4cccf        28 seconds ago      278 MB

docker commit
• 使用镜像启动容器,在该容器基础上修改另存为一个新镜像

++++++++++++++++++++++++++++++++++++++++++++++++++++++
Dockerfile（Docker脚本，自动化）
• Dockerfile语法格式
– FROM:基础镜像
– MAINTAINER:镜像创建者信息
– EXPOSE:开放的端口                        //多个端口，多个EXPOSE关键字
– ENV:设置环境变量                         //ssh进容器退出后，环境变量不变
– ADD:复制文件到镜像                       //文件必须和Dockerfile在同一文件夹
– RUN:制作镜像时执行的命令,可以有多个      //ssh进容器，执行命令就退出
– WORKDIR:定义容器默认工作目录              //永久切换容器目录cd
– CMD:容器启动时执行的命令,仅可以有一条CMD   //指定默认的启动命令，比如指定python命令，进入启动镜像时就会进入python环境

[root@dockera ~]# mkdir abc
[root@dockera ~]# cd abc/
[root@dockera abc]# vim Dockerfile     //文件名只能是Dockerfile
FROM centos:latest
RUN rm -f /etc/yum.repos.d/*.repo
ADD local.repo /etc/yum.repos.d/local.repo       //复制local.repo到容器里
RUN yum repolist
RUN yum -y install vim net-tools psmisc iproute
RUN yum -y install httpd
RUN yum install -y openssh-server initscripts
RUN echo 'aa' | passwd --stdin root
RUN sshd-keygen
ENV EnvironmentFile=/etc/sysconfig/sshd
EXPOSE 80
EXPOSE 22
CMD ["httpd","-D"]                 //httpd的启动命令：httpd -D

[root@dockera abc]# docker build -t myos:abc .   //docker build -t 新创建的容器名 Dockerfile所在目录

--------------------------------------------------------------------------
查看服务的启动命令
cat /usr/lib/systemd/system/httpd.service
--------------------------------------------------------------------------

1、制作一个docker的apache镜像设置默认首页
FROM myos:latest
RUN yum -y install httpd
WORKDIR /var/www/html
ENV EnvironmentFile=/etc/sysconfig/httpd
RUN echo hello world > index.html
EXPOSE 80
EXPOSE 443
CMD ["/usr/sbin/httpd","-D"]
[root@dockera abc]# docker build -t myos:httpd .

2、制作一个容器sshd httpd双服务，可以通过ssh更改默认首页
FROM myos:sshd                              //基于sshd服务容器上创建httpd服务
RUN yum -y install httpd
WORKDIR /var/www/html
ENV EnvironmentFile=/etc/sysconfig/httpd
RUN echo hello world > index.html
EXPOSE 80
EXPOSE 443
ADD run.sh /etc/rc.d/init.d/run.sh     //启动两个服务的脚本,编写脚本后要改权限755
---------------------------------------------------------------
#!/bin/bash
/usr/sbin/sshd -D &        //防止进程阻塞，执行不了下一条命令
/usr/sbin/httpd -D
---------------------------------------------------------------
CMD ["/etc/rc.d/init.d/run.sh"]         //执行脚本；上帝进程为run.sh
[root@dockera abc]# docker build -t myos:httpd .

+++++++++++++++++++++++++++++++++++++++++++++++++

自定义镜像仓库

[root@dockera abc]# cd /etc/docker/
[root@dockera docker]# ls
key.json
[root@dockera docker]# vim daemon.json
{
"insecure-registries" : ["192.168.1.20:5000"]  //启动docker容器的物理机地址
}
[root@dockera docker]# systemctl restart docker

1、启动私有仓库
[root@dockera docker]# docker run -itd -p 5000:5000 registry  //启动一个registry容器，上帝是一个shell脚本

真机访问192.168.1.20：5000/v2/
有{}就启动成功了

2、设置标签
[root@dockera docker]# docker tag busybox:latest 192.168.1.20:5000/busybox:latest

3、上传镜像
[root@dockera docker]# docker push 192.168.1.20:5000/busybox:latest

4、使用镜像
在第二台机器上
[root@dockerb ~]# scp dockerA:/etc/docker/daemon.json /etc/docker
[root@dockerb ~]# systemctl restart docker
[root@dockerb ~]# docker run -it 192.168.1.20:5000/busybox:latest
[root@dockerb ~]# docker images
REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE
192.168.1.20:5000/busybox   latest              59788edf1f3e        7 weeks ago         1.154 MB

查看镜像名称
http://192.168.1.20:5000/v2/_catalog
查看标签名称
http://192.168.1.20:5000/v2/myos/tags/list     //myos是镜像名

++++++++++++++++++++++++++++++++++++++++++++++++++

持久化存储
卷的概念
• docker容器本质是一个进程，不保持任何数据
• 重要数据请使用外部卷存储(数据持久化)
• 容器可以挂载真实机目录或共享存储为卷

[root@dockerb ~]# docker tag 192.168.1.20:5000/busybox busybox
[root@dockerb ~]# docker images
[root@dockerb ~]# mkdir /var/webroot
[root@dockerb ~]# echo 123456 > /var/webroot/f1
[root@dockerb ~]# docker run -it -v /var/webroot:/abc busybox  //-v挂载，将本机文件夹/var/webroot复制成容器的abc目录；容器自动创建/abc目录
/ # cd /abc
/abc # cat f1
123456

++++++++++++++++++++++++++++++++++++++++++++++++++++

共享存储基本概念
• 一台共享存储服务器可以提供给所有Docker主机使用
• 共享存储服务器(NAS、SAN、DAS等)
• 如:
– 使用NFS创建共享存储服务器
– 客户端挂载NFS共享,并最终映射到容器中

1、安装一台NFS服务器，共享一个目录
2、dockerA mount nfs 的共享目录，并且把这个目录映射进容器1（nginx）
3、dockerB mount nfs 的共享目录，并且把这个目录映射进容器2（httpd）
实现nginx和httpd共享一个web主页

]# virsh start --console node3
]# yum -y install nfs-utils
]# vim /etc/exports
/var/webroot  *(rw,no_root_squash)
]# mkdir /var/webroot
]# exportfs -avr
]# mount 192.168.1.10:/var/webroot/ /mnt/
]# cd /mnt/
]# touch f1

[root@dockera ~]# yum -y install nfs-utils
[root@dockera ~]# mkdir /var/webroot
[root@dockera ~]# mount -t nfs 192.168.1.10:/var/webroot /var/webroot
[root@dockera ~]# cd /var/webroot
[root@dockera webroot]# ll
[root@dockera webroot]# docker run -itd -v /var/webroot:/usr/share/nginx/html nginx
[root@dockera webroot]# echo 'hello nginx' > index.html
[root@dockera webroot]# docker ps

[root@dockerb ~]# yum -y install nfs-utils
[root@dockerb ~]# mkdir /var/webroot
[root@dockerb ~]# mount -t nfs 192.168.1.10:/var/webroot /var/webroot
[root@dockera ~]# docker run -itd -v /var/webroot:/var/www/html 192.168.1.20:5000/myos:httpd
[root@dockerb ~]# echo 'hello httpd' > /var/webroot/index.html

++++++++++++++++++++++++++++++++++++++++++++++++++++

Docker网络架构
Linux网桥

创建虚拟网卡
• 真实网卡配置文件
– cat /etc/sysconfig/network-scripts/ifcfg-eth0
• 虚拟网卡配置文件
– cat /etc/sysconfig/network-scripts/ifcfg-eth0:0
名称 eth0:1 
ip  换一个
重启网络

创建虚拟网桥
yum -y install bridge-utils         //虚拟交换机工具包
[root@jacob ~]# cat /etc/sysconfig/network-scripts/ifcfg-br0
TYPE=Bridge
BOOTPROTO=static
... ...
NAME=br0
DEVICE=br0
ONBOOT=yes
IPADDR=192.168.1.10
[root@jacob ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
TYPE=Ethernet
BOOTPROTO=static
... ...
NAME=eth0
DEVICE=eth0
BRIDGE=br0
ONBOOT=yes
IPADDR=192.168.1.10
[root@jacob ~]# ~]# brctl show

查看Docker默认网络模型
• 查看默认Docker创建的网络模型
[root@jacob ~]# docker network list
NETWORKID    NAME    DRIVER   SCOPE
c0ae28d57b18 bridge  bridge   local   桥接模型
b69d4c0c735f host    host     local   主机模型
4dc88be13b81 none    null     local   无网络
[root@jacob ~]# ip a s docker0
[root@jacob ~]# brctl show docker0   //启动容器会绑定该网桥

使用Docker创建网桥
• 新建Docker网络模型
]# docker network create --driver bridge docker1
]# docker network list
]# ip a s
]# docker network inspect docker1

• 查看默认Docker创建的网络模型
– 自定义网段
]# docker network create --subnet=172.30.0.0/16 docker1

使用自定义网桥
• 启动容器,使用刚刚创建的自定义网桥
[root@jacob ~]# docker run --network=bridge|host|none ... ...
[root@jacob ~]# docker run --network=docker1 -id nginx


端口绑定
客户端访问容器内的资源
• 默认容器通过SNAT可以访问外网
• 但外部网络的主机不可以访问容器内的资源
• 端口映射
– 使用端口映射可以实现外部网络访问容器内的资源
[root@jacob ~]# docker run -p 8080:80 -id nginx     //物理机端口：容器端口，把物理机变成nginx服务器
//如:真实机IP为192.168.1.10,
使用-p映射真实机的8080端口到容器中的80端口
[root@client ~]# firefox http://192.168.1.10

*kubernetes自己百度

=================================================================================
		             12.ARCHITECTURE-day01
=================================================================================
大型架构及配置技术

什么是ansible（管理大量主机）
• ansible是2013年推出的一款IT自动化和DevOps软件,2015年被RedHat收购。是基于Python研发,糅合很多老运维工具的优点,实现了批量操作系统配置,批量程序部署,批量运行命令等功能
• ansible可以实现:
– 自动化部署APP
– 自动化管理配置项
– 自动化持续交付
– 自动化(AWS)云服务管理

为什么选择ansible
• 选择一款配置管理软件,无外乎从以下几点来权衡利弊
– 活跃度(社区)
– 学习成本
– 使用成本
– 编码语言  python容易
– 性能
– 使用是否广泛  网上文档较多

• ansible优点
– 只需要SSH和Python即可使用
– 无客户端
– ansible功能强大,模块丰富
– 上手容易,门槛低（无客户端，无服务端，服务端就是一条命令）
– 基于Python开发,做二次开发更容易
– 使用公司比较多,社区活跃

ansible特性
• 模块化设计,调用特定的模块完成特定任务
• 基于Python语言实现
– paramiko
– PyYAML (半结构化语言)
– Jinja2
• 其模块支持JSON等标准输出格式,可以采用任何编程语言重写

• 部署简单
• 主从模式工作
• 支持自定义模块
• 支持playbook
• 易于使用
• 支持多层部署
• 支持异构IT环境

软件依赖关系
• 对管理主机
– 要求Python 2.6 或Python 2.7
• ansible 使用以下模块,都需要安装
– paramiko
– PyYAML
– Jinja2
– httplib2
– six
• 对于被托管主机
– ansible默认通过SSH协议管理机器
– 被管理主机要开启ssh服务,允许ansible主机登录
– 在托管节点上也需要安装Python2.5或以上的版本
– 如果托管节点上开启了SElinux,需要安装libselinux-python

安装ansible
• ansible可以基于源码运行
• 源码安装                                    //安装ansible的第一种方式
– pip,需要配置扩展软件包源extras             //以后可能需要安装python软件包
– git
yum install epel-release
yum install git python2-pip
– pip安装依赖模块
pip install paramiko PyYAML Jinja2 httplib2 six
• ansible源码下载
– git clone git://github.com/ansible/ansible.git
– yum install python-setuptools python-devel
– python setup.py build                  //make
– python setup.py install                 //make install
• pip方式安装
– pip install ansible

• yum扩展源安装简单,自动解决依赖关系(推荐)     //安装ansible的第二种方式
– http://mirror.centos.org/.../.../extras/
– yum install ansible
• 安装完成以后验证
– ansible --version

软件在centos官网找
http://mirror.centos.org/
https://mirrors.huaweicloud.com/centos/7/extras    //extras：扩展源，ansible软件包所在

1、环境准备
6台主机
1 ansible
2 web1 web2
2 db1  db2
1 cache
能ping通主机名
ansible包另做一个yum源
真机更新yum源命令
createrepo --update .
[root@ansible ~]# yum -y install ansible
[root@ansible ~]# ansible --version

ad-hoc  //执行临时的命令
playbook   //将临时命令写成脚本

主机定义与分组
• 安装ansible之后可以做一些简单的任务
• ansible配置文件查找顺序              //注：要求背
– 首先检测ANSIBLE_CONFIG变量定义的配置文件
– 其次检查当前目录下的 ./ansible.cfg 文件
– 再次检查当前用户家目录下 ~/ansible.cfg 文件
– 最后检查/etc/ansible/ansible.cfg文件
• /etc/ansible/ansible.cfg是ansible的默认配置文件路径
• ansible.cfg 配置文件
– inventory定义托管主机地址配置文件
– 先编辑/etc/ansible/hosts文件,写入远程主机的地址。
• 格式
– # 表示注释
[组名称]
主机名称或ip地址,登录用户名,密码、端口等信息
• 测试
– ansible [组名称] --list-hosts

[root@ansible ~]# cd /etc/ansible/
[root@ansible ansible]# ls
ansible.cfg  hosts  roles
[root@ansible ansible]# vim ansible.cfg
inventory      = /etc/ansible/hosts     //指定分组文件路径，主机的分组文件hosts
host_key_checking = False                //取消ssh连接时的 yes|no
[root@ansible ansible]# vim /etc/ansible/hosts
[web]         //分组
web1          //组成员
web2

[mysql]
db[1:2]                     //1:2为db1到db2两台主机，1:20为db1到db20多台主机

[cache]
cache

[app:children]     //子组：声明下面是组名
web
mysql

[app:vars]         //给app分组设置通用变量：app所有成员共享一组用户密码
ansible_ssh_user="root"
ansible_ssh_pass="a"

[root@ansible ansible]# ansible mysql --list-hosts
[root@ansible ansible]# ansible all --list-hosts    //全体成员
[root@ansible ansible]# ansible cache -m ping      //调用检测模块的ping模块
-----------------------------------------------------------------
没有密码，显示错误
方法1：交互式输入密码
[root@ansible ansible]# ansible cache -m ping -k
SSH password:
方法2：写配置文件
[root@ansible ansible]# vim /etc/ansible/hosts
[cache]
cache ansible_ssh_user="root" ansible_ssh_pass="a"
-----------------------------------------------------------------
[root@ansible cache]# sysctl -w net.ipv4.icmp_echo_ignore_all=1 //cache主机禁用ping模块；0启用ping模块
[root@ansible ansible]# ping -c 4 cache     //ping不通
[root@ansible ansible]# ansible cache -m ping   //成功，检测的是ssh

[root@ansible cache]# systemctl stop sshd
[root@ansible ansible]# rm -rf /root/.ansible/cp/* //ansible第一次连接会产生连接文件，要删掉连接文件才会断开连接
[root@ansible ansible]# ansible cache -m ping   //失败，但能ping通

自定义分组
[root@ansible ansible]# mkdir /var/myansible
[root@ansible ansible]# cd /var/myansible
[root@ansible myansible]# touch ansible.cfg
[root@ansible myansible]# vim ansible.cfg
[defaults]
inventory      = myhosts
host_key_checking = False 
[root@ansible myansible]# vim myhosts //自定义分组
[root@ansible myansible]# ansible app1 --list-hosts //根据ansible的检测顺序；换个文件夹就会报错；每个用户可以定义自己的分组；不同文件夹的ansible调用不同文件的ansible文件；检测到一个配置文件就不会检测了

+++++++++++++++++++++++++++++++++++++++++++++++++++++

动态主机
• 无限可能
– ansible Inventory包含静态和动态的Inventory,静态
Inventory指在文件/etc/ansible/hosts中指定的主机和组,
动态Inventory指通过外部脚本获取主机列表,按照其要求
格式返回给ansilbe命令
• Json
– JSON(JavaScript Object Notation,JavaScript对象表示
法),一种基于文本独立于语言的轻量级数据交换格式
• 注意事项:
– 主机部分必须是列表格式
– Hostdata行,其中的"hosts" 部分可以省略,但使用
时,必须是"hosts"

ansible命令基础
• ansible <host-pattern> [options]
– host-pattern 主机或定义的分组
– -M 指定模块路径
– -m 使用模块,默认command模块
– -a or --args模块参数
– -i inventory文件路径,或可执行脚本
– -k 使用交互式登录密码
– -e 定义变量
– -v 详细信息,-vvvv开启debug模式
• 列出要执行的主机
– ansible all --list-hosts
• 批量检测主机
– ansible all -m ping
• 批量执行命令
– ansible all -m command -a 'id' -k

一般格式：
ansible 主机或分组名称 -m 模块名称 -a 模块的参数

uptime:查看系统负载
----------------------------------------------------
给所有主机部署公钥
ansible all -m authorized_key -a "user=root exclusive=true manage_dir=true key='$(< /root/.ssh/id_rsa.pub)'" -k -v
//exclusive=true：如果和以前的公钥冲突，强制覆盖
//manage_dir=true：/root/.ssh/目录不存在，自动创建
-------------------------------------------------------
模块
ansible-doc和ping模块
• ansible-doc
– 模块的手册相当与shell的man,很重要
– ansible-doc -l              列出所有模块
– ansible-doc modulename       查看帮助
例子：ansible-doc ping    //查看ping模块
• ping 模块
– 测试网络连通性, ping模块没有参数
– 注:测试ssh的连通性
ansible host-pattern -m ping

command模块
• command模块
– 默认模块,远程执行命令
– 用法
ansible host-pattern -m command -a '[args]'
– 查看所有机器负载
ansible all -m command -a 'uptime'
– 查看日期和时间
ansible all -m command -a 'date +%F_%T'
• command模块注意事项:
– 该模块通过-a跟上要执行的命令可以直接执行,若命
令里有如下字符则执行不成功
– "<" , ">" , "|" , "&"
– 该模块不启动shell直接在ssh进程中执行,所有使用到
shell的命令执行都会失败
– 下列命令执行会失败
ansible all -m command -a 'ps aux|grep ssh'
ansible all -m command -a 'set'

shell|raw模块       //推荐使用shell模块
• shell | raw 模块
– shell 模块用法基本和command一样,区别是shell模块是通过/bin/sh进行执行命令,可以执行任意命令
– raw模块,用法和shell模块一样 ,可以执行任意命令，shell没用时可能换raw就可以了
– 区别是raw没有chdir、creates、removes参数
– 执行以下命令查看结果
ansible t1 -m command -a 'chdir=/tmp touch f1' //工作目录变为/tmp
ansible t1 -m shell -a 'chdir=/tmp touch f2'  //工作目录变为/tmp
ansible t1 -m raw -a 'chdir=/tmp touch f3'    //没有变化
-------------------------------------------------------------------------
使用shell模块给web1，db1添加用户z3，并设置密码
ansible web1 -m shell -a 'useradd z3'
ansible web1 -m shell -a 'echo 'aa' | passwd --stdin z3'

给web组添加用户li4，要求li4与z3不能同时出现在同一台主机上
]# vim au.sh
#!/bin/bash
if ! $(id z3 &> /dev/null);then
    useradd li4
    echo 'aa' | passwd --stdin li4
fi
]# ansible web1 -m script -a 'au.sh'
---------------------------------------------------------------------------
script模块
• script模块
– 命令太复杂?
– 在本地写脚本,然后使用script模块批量执行
ansible t1 -m script -a 'urscript'
– 注意:该脚本包含但不限于shell脚本,只要指定Sha-
bang解释器的脚本都可运行

copy模块
• copy 模块
– 复制文件到远程主机
– src:复制本地文件到远程主机,绝对路径和相对路径都可,
路径为目录时会递归复制。若路径以"/"结尾,只复制目录
里的内容,若不以"/"结尾,则复制包含目录在内的整个内
容,类似于rsync
– dest:必选项。远程主机的绝对路径,如果源文件是一个
目录,那该路径必须是目录
– backup:覆盖前先备份原文件,备份文件包含时间信
息。有两个选项:yes|no
– force:若目标主机包含该文件,但内容不同,如果设
置为yes,则强制覆盖,设为no,则只有当目标主机的
目标位置不存在该文件时才复制。默认为yes
– 复制文件
ansible t1 -m copy -a 'src=/root/alog dest=/root/a.log'
– 复制目录
ansible t1 -m copy -a 'src=urdir dest=/root/'

lineinfile|
• lineinfile
– 类似sed的一种行编辑替换模块
– path 目的文件
– regexp 正则表达式
– line 替换后的结果   //行匹配，要把整一行的结果写下来
ansible t1 -m lineinfile -a 'path="/etc/selinux/config"
regexp="^SELINUX=" line="SELINUX=disabled"'

replace模块
– 替换指定字符
ansible t1 -m replace -a 'path="/etc/selinux/config"
regexp="^(SELINUX=).*" replace="\1disabled"'
//^(SELINUX=).*：匹配开头为SELINUX=的行
// \1代表第一个regexp中括号的内容

yum模块
• yum模块
– 使用yum包管理器来管理软件包
– config_file:yum的配置文件
– disable_gpg_check:关闭gpg_check
– disablerepo:不启用某个源
– enablerepo:启用某个源
– name:要进行操作的软件包名字,也可传递一个url或一个本地的rpm包的路径
– state:状态(present,absent,latest)
• yum模块
– 删除软件包
ansible t1 -m yum -a 'name="lrzsz" state=absent'
– 删除多个软件包
ansible t1 -m yum -a 'name="lrzsz,lftp" state=absent'
– 安装软件包
ansible t1 -m yum -a 'name="lrzsz"'
– 安装多个软件包
ansible t1 -m yum -a 'name="lrzsz,lftp"'

service模块
• service模块
– name:必选项,服务名称
– enabled:是否开机启动 yes|no
– sleep:执行restarted,会在stop和start之间沉睡几秒钟
– state:对当前服务执行启动,停止、重启、重新加载等操
作(started,stopped,restarted,reloaded)
ansible t1 -m service -a 'name="sshd" enabled="yes"
state="started"'

setup模块
• setup模块
– 主要用于获取主机信息,playbooks里经常会用的另一
个参数gather_facts与该模块相关,setup模块下经常
用的是filter参数
– filter过滤所需信息
ansible t1 -m setup -a 'filter=ansible_distribution'

=================================================================================
		             12.ARCHITECTURE-day03
=================================================================================

ansible七种武器
• 第一种武器
– ansible 命令,用于执行临时性的工作,必须掌握
• 第二种武器
– ansible-doc是ansible模块的文档说明,针对每个模
块都有详细的说明及应用案例介绍,功能和Linux系统
man命令类似,必须掌握
• 第三种武器
– ansible-console是ansible为用户提供的交互式工具,
用户可以在ansible-console虚拟出来的终端上像Shell
一样使用ansible内置的各种命令,这为习惯使用Shell
交互方式的用户提供了良好的使用体验
• 第四种武器
– ansible-galaxy从github上下载管理Roles的一款工具,
与python的pip类似
• 第五种武器
– ansible-playbook是日常应用中使用频率最高的命令,工
作机制:通过读取先编写好的playbook文件实现批量管理,
可以理解为按一定条件组成的ansible任务集,必须掌握
• 第六种武器
– ansible-vault主要用于配置文件加密,如编写的playbook
文件中包含敏感信息,不想其他人随意查看,可用它加密/
解密这个文件
• 第七种武器
– ansible-pull
– ansible有两种工作模式pull/push ,默认使用push模
式工作,pull和push工作模式机制刚好相反
– 适用场景:有大批量机器需要配置,即便使用高并发
线程依旧要花费很多时间
– 通常在配置大批量机器的场景下使用,灵活性稍有欠
缺,但效率几乎可以无限提升,对运维人员的技术水
平和前瞻性规划有较高要求 

JSON简介
• JSON是什么
– JSON是JavaScript对象表示法,它是一种基于文本独
立于语言的轻量级数据交换格式
– JSON中的分隔符限于单引号" ' " 、小括号" () " 、中
括号" [ ] " 、大括号" { } " 、冒号 " : " 和逗号 " , "
• JSON 特性
– JSON是纯文本
– JSON具有"自我描述性"(人类可读)
– JSON具有层级结构(值中存在值)
– JSON可通过JavaScript进行解析

• JSON 语法规则
– 数据在名称/值对中
– 数据由逗号分隔
– 大括号保存对象
– 中括号保存数组
• JSON 数据的书写格式是:名称/值对
– 名称/值对包括字段名称(在双引号中),后面写一个
冒号,然后是值,例如:
"诗仙" : "李白"
• JSON语法规则之数组
{ "诗人":
  ["李白", "杜甫", "白居易", "李贺"]
}
• 复合复杂类型
{ "诗人":
  [ {"李白":"诗仙", "年代":"唐"},
    {"杜甫":"诗圣", "年代":"唐"},
    {"白居易":"诗魔", "年代":"唐"},
    {"李贺":"诗鬼", "年代":"唐"}
  ]
}

YAML简介（尽量少用tab缩进）
• YAML是什么
– 是一个可读性高,用来表达数据序列的格式
– YAML(YAML Ain't Markup Language)
– YAML参考了多种语言,如:C语言、Python、Perl等,并
从XML、电子邮件的数据格式中获得灵感,Clark Evans在
2001年首次发表了这种语言,目前已有数种编程语言或脚
本语言支持这种语言
• YAML基础语法
– YAML的结构通过空格来展示
– 数组使用"- "来表示（减号后面有空格）
– 键值对使用": "来表示（冒 号后面有空格）
– YAML使用一个固定的缩进风格表示数据层级结构关系
– 一般每个缩进级别由两个以上空格组成
– # 表示注释
• 注意:
– 不要使用tab,缩进是初学者容易出错的地方之一
– 同一层级缩进必须对齐
• YAML的键值表示方法
– 采用冒号分隔
– : 后面必须有一个空格
– YAML键值对例子
"诗仙" : "李白"
– 或
"李白":
  "诗仙"
– 复杂YAML的键值对嵌套
"诗人":
  "李白": "诗仙"
或
"诗人":
  "李白":
    "诗仙"
数组
["李白", "杜甫", "白居易", "李贺"]
• YAML 数组表示方法
– 使用一个短横杠加一个空格
– YAML数组例子
- "李白"
- "杜甫"
- "白居易"
- "李贺"
– 哈希数组复合表达式
"诗人":
- "李白"
- "杜甫"
- "白居易"
- "李贺"
– 高级复合表达式
"诗人":
  -
    "李白": "诗仙"
    "年代": "唐"
  -
    "杜甫": "诗圣"
    "年代": "唐“
  -
    "白居易": "诗魔"
    "年代": "唐"
  -
    "李贺": "诗鬼"
    "年代": "唐"

Jinja2模版简介
• Jinja2是什么
– Jinja2是基于Python的模板引擎,包含变量和表达式
两部分,两者在模板求值时会被替换为值,模板中还
有标签,控制模板的逻辑
• 为什么要学习Jinja2模版
– 因为playbook的模板使用Python的Jinja2模块来处理
• Jinja2模版基本语法
– 模板的表达式都是包含在分隔符"{{  }}"内的
– 控制语句都是包含在分隔符"{% %}"内的
– 模板支持注释,都是包含在分隔符"{# #}" 内,支持块注释
– 调用变量
{{varname}}
– 计算
{{2+3}}
– 判断
{{1 in [1,2,3]}}
• Jinja2模版控制语句
{% if name == '诗仙' %}
李白
{% elif name == '诗圣' %}
杜甫
{% elif name == '诗魔' %}
白居易
{% else %}
李贺
{% endif %}
• Jinja2模版控制语句
{% if name == ... ... %}
... ...
{% elif name == '于谦' %}
{% for method in [抽烟, 喝酒, 烫头] %}
{{do method}}
{% endfor %}
... ...
{% endif %}

• Jinja2过滤器
– 变量可以通过过滤器修改。过滤器与变量用管道符号
( | )分割,也可以用圆括号传递可选参数,多个过滤
器可以链式调用,前一个过滤器的输出会被作为后一
个过滤器的输入
• 例如
– 把一个列表用逗号连接起来:{{ list|join(', ') }}
– 过滤器这里不再一一列举,需要的可以查询在线文档
http://docs.jinkan.org/docs/jinja2/templates.html
#builtin-filters

playbook是什么
• playbook是什么
– playbook是ansible用于配置,部署和管理托管主机剧本,
通过playbook的详细描述,执行其中的一系列tasks,可
以让远端主机达到预期状态
– 也可以说,playbook字面意思即剧本,现实中由演员按
剧本表演,在ansible中由计算机进行安装,部署应用,
提供对外服务,以及组织计算机处理各种各样的事情
• 为什么要使用playbook
– 执行一些简单的任务,使用ad-hoc命令可以方便的解决问
题,但有时一个设施过于复杂时,执行ad-hoc命令是不合
适的,最好使用playbook
– playbook可以反复使用编写的代码,可以放到不同的机器
上面,像函数一样,最大化的利用代码,在使用ansible的
过程中,处理的大部分操作都是在编写playbook


playbook语法基础
• playbook语法格式
– playbook由YAML语言编写,遵循YAML标准
– 在同一行中,#之后的内容表示注释
– 同一个列表中的元素应该保持相同的缩进
– playbook由一个或多个play组成
– play中hosts,variables,roles,tasks等对象的表示方
法都是键值中间以": "分隔表示
– YAML还有一个小的怪癖,它的文件开始行都应该是 ---,
这是YAML格式的一部分,表明一个文件的开始
• playbook构成
– Target: 定义将要执行playbook的远程主机组
– Variable: 定义playbook运行时需要使用的变量
– Tasks: 定义将要在远程主机上执行的任务列表
– Handler: 定义task执行完成以后需要调用的任务
• playbook执行结果
• 使用ansible-playbook运行playbook文件,输出内容
为JSON格式,由不同颜色组成便于识别
– 绿色代表执行成功
– ***代表系统代表系统状态发生改变
– 红色代表执行失败

• 第一个playbook
---                                                # 第一行,表示开始 
- hosts: all
  remote_user: root
  tasks:
    - ping:

ansible-playbook myping.yml -f 5
– -f 并发进程数量,默认是5
– hosts行 内容是一个(多个)组或主机的patterns,以
逗号为分隔符
– remote_user 账户名
• tasks
– 每一个play包含了一个task列表(任务列表)
– 一个task在其所对应的所有主机上(通过 host pattern
匹配的所有主机)执行完毕之后,下一个task才会执行
– 有一点很重要,在一个play之中,所有hosts会获取相
同的任务指令,这是play的一个目的所在,即将一组选
出的hosts映射到task,执行相同的操作

• playbook执行命令
– 给所有主机添加用户plj,设置默认密码123456
– 要求第一次登录修改密码
---
- hosts: all
  remote_user: root
  tasks:
    - name: create user plj
      user: group=wheel uid=1000 name=plj
        - shell: echo 123456 | passwd --stdin plj
        - shell: chage -d 0 plj








=================================================================================
		             12.ARCHITECTURE-day03
=================================================================================

[root@room9pc01 ~]# w
 09:33:12 up  1:05,  2 users,  load average: 0.16, 0.05, 0.06
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     :0       :0               08:30   ?xdm?   3:05   0.12s /usr/libexec/gn
root     pts/0    :0               09:33    0.00s  0.07s  0.00s w
[root@room9pc01 ~]# ls /dev/pts/
0     ptmx  
[root@room9pc01 ~]# cat /dev/pts/0
^C
[root@room9pc01 ~]# wall "1"            //向所有端口发送消息

Broadcast message from root@room9pc01.tedu.cn (pts/0) (Fri Nov 23 09:34:02 2018):

1

[root@room9pc01 ~]# echo "11" > /dev/pts/0     //单独向0端口发送信息
11

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

exec    //原本意思：执行一个命令后退出；可以管理文件描述符；（在当前进程中）设置一个重定向永久有效

]# exec 1>f1   //将标准输出重定向到f1文件中
]# ls            //屏幕无输出，输出信息在f1文件中
]# echo 12345      //屏幕无输出，输出信息在f1文件中

]# exec 55>f1    //55是自己定义的一个文件描述符
]# echo abc >&55 
]# cat f1         
abc
]# exec 55<&-     //关闭文件描述符
]# echo abc >&55
-bash: Bad

]# exec 3<f1
]# cat <&3
abc

=================================================================================
		             12.ARCHITECTURE-day05
=================================================================================
http://hadoop.apache.org/docs/r2.7.6/
]# vim -O ifcfg-eth0 ifcfg-eth1   //同屏打开两个文件
]# vimdiff ifcfg-eth0 ifcfg-eth1   //同屏打开两个文件，不同的地方有颜色标记
]# diff -y --suppress-common-lines file1 file2


[root@hadoop-nn01 hadoop]# ./bin/hadoop fs -mkdir /abc  //在集群服务器上创建
[root@hadoop-nn01 hadoop]# ./bin/hadoop fs -ls /

-------------------------------------------------------------------------------------------------------------------------------
把本机文件上传到虚拟磁盘
put  get
[root@hadoop-nn01 hadoop]# ./bin/hadoop fs -put *.txt /abc/
[root@hadoop-nn01 hadoop]# ./bin/hadoop fs -ls /abc

[root@hadoop-nn01 hadoop]# cd /dev/shm/
[root@hadoop-nn01 shm]# ls
[root@hadoop-nn01 shm]# /usr/local/hadoop/bin/hadoop fs -get /abc/*.txt
[root@hadoop-nn01 shm]# ls
-------------------------------------------------------------------------------------------------------------------------------

[root@hadoop-nn01 hadoop]# ./bin/hadoop fs -ls hdfs://hadoop-nn01:9000/
[root@hadoop-nn01 hadoop]# ./bin/hadoop fs -ls /

数据分析
[root@hadoop-nn01 hadoop]# ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.6.jar wordcount /abc /output
[root@hadoop-nn01 hadoop]# ./bin/hadoop fs -cat output/*


增加新节点
1、启动一个机器 ssh免密登陆 java-1.8.0-openjdk-devel
2、拷贝hadoop到新机器
rsync -aSH --delete /usr/local/hadoop 192.168.1.15:/usr/local/
3、修改配置文件 /etc/hosts、/usr/local/hadoop/etc/hadoop/slaves
4、把配置文件同步到所有主机
5、在新节点上启动datanode
6、数据平衡
./bin/hdfs dfsadmin -setBalancerBandwidth 60000000
./sbin/start-balancer.sh

修复节点
• HDFS修复节点
– 修复节点比较简单,与增加节点基本一致
– 注意:新节点的ip和主机名要与损坏节点的一致
– 启动服务
# ./sbin/hadoop-daemon.sh start datanode
– 数据恢复是自动的
– 上线以后会自动恢复数据,如果数据量非常巨大,可能需要一定的时间

删除节点


yarn节点
• yarn的相关操作
– 由于Hadoop在2.x引入了yarn框架,对于计算节点的操作已经变得非常简单
– 增加节点
# sbin/yarn-daemon.sh start nodemanager
– 删除节点
# sbin/yarn-daemon.sh stop nodemanager
– 查看节点 (ResourceManager)
# ./bin/yarn node -list
• yarn的系统环境配置与HDFS的基础环境配置是相同的,这里不再重复列出
• 由于yarn不包含数据,所以在增加删除修复节点的时候比较简单,HDFS要注意数据安全

NFS网关
1、修改/etc/hosts同步给所有主机
2、在namenode、nfsgw添加用户
groupadd -g 200 nfsuser
useradd -u 200 -g 200 -r nfsuser
3、配置nfs主机授权
停止集群 namenode ./sbin/stop-all.sh  //出错：需要删除slaves文件中的newnode
清除日志 rm -rf logs/*
配置core-site.xml，同步到所有主机
启动hdfs集群 ./sbin/start-dfs.sh
4、在nfsgw上配置hdfs-site.xml
nfs.exports.allowed.hosts
nfs.dump.dir
5、更改权限
chown 200.200 nfstmp
setfacl -m user:nfsuser:rwx logs    //给予用户nfsuser写日志的权限
6、nfs启动与挂载
./sbin/hadoop-daemon.sh --script ./bin/hdfs start portmap

7、























